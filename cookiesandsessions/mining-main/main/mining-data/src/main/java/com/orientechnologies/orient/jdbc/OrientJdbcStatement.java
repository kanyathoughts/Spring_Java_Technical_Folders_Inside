/* Copyright (c) 2019 innoWake gmbh Germany. All rights reserved. */
package com.orientechnologies.orient.jdbc;

import static java.lang.Boolean.parseBoolean;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLSyntaxErrorException;
import java.sql.SQLWarning;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Properties;

import com.orientechnologies.common.exception.OException;
import com.orientechnologies.orient.core.db.document.ODatabaseDocument;
import com.orientechnologies.orient.core.exception.OQueryParsingException;
import com.orientechnologies.orient.core.sql.OCommandSQL;
import com.orientechnologies.orient.core.sql.executor.OInternalResultSet;
import com.orientechnologies.orient.core.sql.executor.OResult;
import com.orientechnologies.orient.core.sql.executor.OResultInternal;
import com.orientechnologies.orient.core.sql.executor.OResultSet;

/**
 * A patch for the original {@code OrientJdbcStatement}.
 */
public class OrientJdbcStatement implements Statement {

	protected final OrientJdbcConnection connection;
	protected final ODatabaseDocument database;
	protected final List<String> batches;
	protected final int resultSetType;
	protected final int resultSetConcurrency;
	protected final int resultSetHoldability;
	protected final Properties info;
	protected String sql;
	protected boolean closed;
	protected OResultSet oResultSet;
	protected OrientJdbcResultSet resultSet;

	public OrientJdbcStatement(final OrientJdbcConnection iConnection) {
		this(iConnection, ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY, ResultSet.HOLD_CURSORS_OVER_COMMIT);
	}

	public OrientJdbcStatement(OrientJdbcConnection iConnection, int resultSetType, int resultSetConcurrency) {
		this(iConnection, resultSetType, resultSetConcurrency, resultSetType);
	}

	public OrientJdbcStatement(OrientJdbcConnection iConnection, int resultSetType, int resultSetConcurrency, int resultSetHoldability) {
		this.connection = iConnection;
		this.database = iConnection.getDatabase();
		database.activateOnCurrentThread();
		batches = new ArrayList<>();
		this.resultSetType = resultSetType;
		this.resultSetConcurrency = resultSetConcurrency;
		this.resultSetHoldability = resultSetHoldability;
		info = connection.getInfo();
	}

	@Override
	public boolean execute(final String sqlCommand) throws SQLException {
		if ("".equals(sqlCommand)) {
			return false;
		}

		sql = sqlCommand;

		if (sql.equalsIgnoreCase("select 1")) {
			OResultInternal element = new OResultInternal();
			element.setProperty("1", Integer.valueOf(1));
			OInternalResultSet rs = new OInternalResultSet();
			rs.add(element);
			oResultSet = rs;
		} else {
			try {

				oResultSet = executeCommand(sql);

			} catch (OQueryParsingException e) {
				throw new SQLSyntaxErrorException("Error while parsing query", e);
			} catch (OException e) {
				throw new SQLException("Error while executing query", e);
			}
		}

		resultSet = new OrientJdbcResultSet(this, oResultSet, resultSetType, resultSetConcurrency, resultSetHoldability);
		return true;
	}

	@Override
	public ResultSet executeQuery(final String sql) throws SQLException {
		if (execute(sql)) {
			return resultSet;
		} else {
			return null;
		}
	}

	@Override
	public int executeUpdate(final String sql) throws SQLException {
		try {
			oResultSet = executeCommand(sql);

			Optional<OResult> res = oResultSet.stream().findFirst();

			if (res.isPresent()) {
				if (res.get().getProperty("count") != null) {
					return Math.toIntExact(((Long) res.get().getProperty("count")).longValue());
				} else {
					return 1;
				}
			} else {
				return 0;
			}
		} finally {
			/* WMIN-19: fixed NPE */
			if (oResultSet != null) {
				oResultSet.close();
			}
		}
	}

	protected OResultSet executeCommand(String query) throws SQLException {
		try {
			return database.command(query);
		} catch (OQueryParsingException e) {
			throw new SQLSyntaxErrorException("Error while parsing command", e);
		} catch (OException e) {
			throw new SQLException("Error while executing command", e);
		}
	}

	@Override
	public int executeUpdate(final String sql, int autoGeneratedKeys) throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(final String sql, int[] columnIndexes) throws SQLException {
		return 0;
	}

	@Override
	public int executeUpdate(final String sql, String[] columnNames) throws SQLException {
		return 0;
	}

	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	@Override
	public void close() throws SQLException {
		closed = true;
	}

	@Override
	public boolean execute(final String sql, int autoGeneratedKeys) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(final String sql, int[] columnIndexes) throws SQLException {
		return false;
	}

	@Override
	public boolean execute(final String sql, String[] columnNames) throws SQLException {
		return false;
	}

	@Override
	public void addBatch(final String sql) throws SQLException {
		batches.add(sql);
	}

	@Override
	public void cancel() throws SQLException {
		/* not supported */
	}

	@Override
	public void clearBatch() throws SQLException {
		batches.clear();
	}

	@Override
	public void clearWarnings() throws SQLException {
		/* not supported */
	}

	@Override
	public int[] executeBatch() throws SQLException {
		int[] results = new int[batches.size()];
		int i = 0;
		for (String batch : batches) {
			results[i++] = executeUpdate(batch);
		}
		return results;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return 0;
	}

	@Override
	public void setFetchDirection(final int direction) throws SQLException {
		/* not supported */
	}

	@Override
	public int getFetchSize() throws SQLException {
		return 0;
	}

	@Override
	public void setFetchSize(final int rows) throws SQLException {
		/* not supported */
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return null;
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxFieldSize(final int max) throws SQLException {
		/* not supported */
	}

	@Override
	public int getMaxRows() throws SQLException {
		return 0;
	}

	@Override
	public void setMaxRows(final int max) throws SQLException {
		/* not supported */
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return false;
	}

	@Override
	public boolean getMoreResults(final int current) throws SQLException {
		return false;
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return 0;
	}

	@Override
	public void setQueryTimeout(final int seconds) throws SQLException {
		/* not supported */
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		return resultSet;
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return resultSet.getConcurrency();
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return resultSet.getHoldability();
	}

	@Override
	public int getResultSetType() throws SQLException {
		return resultSet.getType();
	}

	@Override
	public int getUpdateCount() throws SQLException {
		if (isClosed()) {
			throw new SQLException("Statement already closed");
		}
		return -1;
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return null;
	}

	@Override
	public boolean isClosed() throws SQLException {
		return closed;
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return false;
	}

	@Override
	public void setPoolable(final boolean poolable) throws SQLException {
		/* not supported */
	}

	@Override
	public void setCursorName(final String name) throws SQLException {
		/* not supported */
	}

	@Override
	public void setEscapeProcessing(final boolean enable) throws SQLException {
		/* not supported */
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		try {
			/* the following if-then structure makes sense if the query can be a subclass of OCommandSQL. */
			if (this.sql == null) {
				return OCommandSQL.class.isAssignableFrom(iface);
			} else {
				return this.sql.getClass().isAssignableFrom(iface);
			}
		} catch (NullPointerException e) {
			throw new SQLException(e);
		}
	}

	@Override
	public <T> T unwrap(Class<T> iface) throws SQLException {
		try {
			return iface.cast(sql);
		} catch (ClassCastException e) {
			throw new SQLException(e);
		}
	}

	@Override
	public void closeOnCompletion() throws SQLException {
		/* not supported */
	}

	@Override
	public boolean isCloseOnCompletion() throws SQLException {
		return false;
	}

	protected String mayCleanForSpark(String sql) {
		/* SPARK support */
		if (parseBoolean(info.getProperty("spark", "false"))) {
			if (sql.endsWith("WHERE 1=0")) {
				sql = sql.replace("WHERE 1=0", " LIMIT 1");
			}
			return sql.replace('"', ' ');
		}
		return sql;
	}
}
