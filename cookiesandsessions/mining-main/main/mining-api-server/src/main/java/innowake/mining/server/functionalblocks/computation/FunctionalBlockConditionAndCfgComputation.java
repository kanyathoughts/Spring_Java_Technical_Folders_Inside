/*
 * Copyright (c) 2024 Deloitte. All rights reserved.
 */
package innowake.mining.server.functionalblocks.computation;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import innowake.lib.core.log.Logger;
import innowake.lib.core.log.LoggerFactory;
import innowake.lib.job.api.ProgressMonitor;
import innowake.mining.server.functionalblocks.FunctionalBlockUtil;
import innowake.mining.server.functionalblocks.generation.datalineagefunctionalblock.DataLineageFunctionalBlockGeneration;
import innowake.mining.server.functionalblocks.service.FunctionalBlockControlFlowGraphGenerationService;
import innowake.mining.shared.access.FunctionalBlockService;
import innowake.mining.shared.entities.functionalblocks.ExcludedBranch;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockFlag;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockPojo;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockPojoPrototype;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockType;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockWithChildrenAndLinks;
import innowake.mining.shared.entities.functionalblocks.ModulePart;
import innowake.mining.shared.entities.functionalblocks.ResolvedModulePart;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * This class is responsible for generating functional conditions and links for a functional block.
 * It is used for functional blocks that are generated by the {@link DataLineageFunctionalBlockGeneration} class.
 * It uses the {@link FunctionalBlockControlFlowGraphGenerationService} to generate the conditions and links.
 */
@Component
public class FunctionalBlockConditionAndCfgComputation implements FunctionalBlockComputation<Optional<FunctionalBlockWithChildrenAndLinks>> {

	private static final Logger LOG = LoggerFactory.getLogger(FunctionalBlockConditionAndCfgComputation.class);
	private final FunctionalBlockService functionalBlockService;
	private final FunctionalBlockControlFlowGraphGenerationService functionalBlockControlFlowGraphGenerationService;
	private final ObjectMapper objectMapper;

	public FunctionalBlockConditionAndCfgComputation(final FunctionalBlockService functionalBlockService,
			final FunctionalBlockControlFlowGraphGenerationService functionalBlockControlFlowGraphGenerationService, final ObjectMapper objectMapper) {
		this.functionalBlockService = functionalBlockService;
		this.functionalBlockControlFlowGraphGenerationService = functionalBlockControlFlowGraphGenerationService;
		this.objectMapper = objectMapper;
	}

	@Override
	public boolean accept(final FunctionalBlockPojo functionalBlock) {
		return FunctionalBlockUtil.hasType(functionalBlock, FunctionalBlockType.FUNCTIONAL_GROUP);
	}

	@Override
	public Optional<FunctionalBlockWithChildrenAndLinks> compute(final FunctionalBlockPojo functionalBlock, final ProgressMonitor progressMonitor) {
		final UUID functionalBlockUid = functionalBlock.getUid();
		final List<UUID> children = functionalBlock.getChildren();
		if ( children.isEmpty() ) {
			LOG.debug("Functional block with id {} has no children.", functionalBlockUid);
			return Optional.empty();
		}
		LOG.debug("Getting generated from map for functional block with id {}.", functionalBlockUid);

		final Optional<ResolvedModulePart> resolvedModulePart = functionalBlockService.getResolvedModuleParts(functionalBlock.getUid()).stream().findAny();

		if ( resolvedModulePart.isEmpty() ) {
			LOG.debug("Functional block with id {} contains no functional units.", functionalBlockUid);
			return Optional.empty();
		}

		/* using children deep to also find FUNCTIONAL_UNITs block in child blocks - for "splitting" the control flow graph */
		final List<FunctionalBlockPojo> functionalUnits = functionalBlockService.findChildrenDeep(functionalBlockUid, - 1,
				q -> q.withType(FunctionalBlockType.FUNCTIONAL_UNIT));

		final Set<String> moduleLinkHashes = functionalUnits.stream().flatMap(fu -> fu.getModuleParts().stream()).map(ModulePart :: getModuleLinkHash)
				.collect(Collectors.toSet());

		if ( moduleLinkHashes.size() > 1 ) {
			LOG.error("Functional block with id {} contains functional units with different module link hashes. So can't generate the CFG.",
					functionalBlockUid);
			return Optional.empty();
		}

		final FunctionalBlockPojoPrototype functionalBlockPojoProto = new FunctionalBlockPojoPrototype();
		functionalBlockPojoProto.setUid(functionalBlock.getUid());

		final List<ExcludedBranch> excludedBranches = getExcludedBranches(functionalBlock);

		Optional<FunctionalBlockWithChildrenAndLinks> optionalFunctionalBlockWithChildrenAndLinks = Optional.of(
				functionalBlockControlFlowGraphGenerationService.generateConditionsAndLinksForAnnotations(functionalBlock.getProject(),
						resolvedModulePart.get().getModuleId(), functionalBlockPojoProto, functionalUnits, excludedBranches));

		return optionalFunctionalBlockWithChildrenAndLinks.flatMap(
				blockWithChildrenAndLinks -> Optional.of(blockWithChildrenAndLinks.getFunctionalBlock().children).map(unsortedChildIds -> {
					List<UUID> childrenSet = new LinkedList<>(children);
					List<UUID> sortedChildIds = sortChildIds(unsortedChildIds.get(), childrenSet);
					blockWithChildrenAndLinks.getFunctionalBlock().children.set(sortedChildIds);
					return blockWithChildrenAndLinks;
				}));
	}

	private List<ExcludedBranch> getExcludedBranches(final FunctionalBlockPojo functionalBlock) {
		final Object o = functionalBlock.getFlags().get(FunctionalBlockFlag.FB_EXCLUDED_BRANCHES.name());
		if ( o == null ) {
			return Collections.emptyList();
		}
		return objectMapper.convertValue(o, new TypeReference<>() { });
	}

	@Override
	public void persist(final UUID functionalBlockId, final Optional<FunctionalBlockWithChildrenAndLinks> functionalBlockWithChildrenAndLinks) {
		functionalBlockService.deleteLinks(functionalBlockId);
		functionalBlockService.deleteConditionsAndStatementTypeChildren(functionalBlockId);
		if ( Objects.requireNonNull(functionalBlockWithChildrenAndLinks).isPresent() ) {
			final List<FunctionalBlockPojoPrototype> functionalBlockPrototypes = functionalBlockWithChildrenAndLinks.get().getChildren();
			for (final FunctionalBlockPojoPrototype block : functionalBlockPrototypes) {
				functionalBlockService.create(block);
			}
			updateFunctionalBlock(functionalBlockWithChildrenAndLinks.get().getFunctionalBlock(), true);
			if ( functionalBlockWithChildrenAndLinks.get().getFunctionalBlockLinks() != null && ! functionalBlockWithChildrenAndLinks.get()
					.getFunctionalBlockLinks().isEmpty() ) {
				functionalBlockService.setLinks(functionalBlockId, functionalBlockWithChildrenAndLinks.get().getFunctionalBlockLinks());
			}
		} else {
			FunctionalBlockPojoPrototype functionalBlockPojoPrototype = new FunctionalBlockPojoPrototype();
			functionalBlockPojoPrototype.setUid(functionalBlockId);
			updateFunctionalBlock(functionalBlockPojoPrototype, false);
		}
	}

	private void updateFunctionalBlock(final FunctionalBlockPojoPrototype functionalBlock, final boolean value) {
		final Map<String, Object> functionalBlockFlags = new HashMap<>();
		functionalBlockFlags.put(FunctionalBlockFlag.HAS_CFG.name(), value);
		functionalBlockFlags.put(FunctionalBlockFlag.COMPUTED_AT.name(), Instant.now().toEpochMilli());
		functionalBlock.setFlags(functionalBlockFlags);
		functionalBlockService.update(functionalBlock);
	}

	private List<UUID> sortChildIds(List<UUID> unsortedChildIds, List<UUID> childrenSet) {
		return unsortedChildIds.stream().sorted(Comparator.comparingInt(id -> {
			if ( childrenSet.contains(id) ) {
				return childrenSet.indexOf(id);
			} else {
				return Integer.MAX_VALUE;
			}
		})).toList();
	}
}
