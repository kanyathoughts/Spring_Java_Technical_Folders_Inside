/*
 * Copyright (c) 2023 Deloitte. All rights reserved.
 */
package innowake.mining.server.functionalblocks.computation;

import innowake.lib.job.api.ProgressMonitor;
import innowake.mining.server.functionalblocks.generation.ModuleBlockGeneration;
import innowake.mining.shared.access.BinaryValue;
import innowake.mining.shared.access.FunctionalBlockService;
import innowake.mining.shared.access.ModuleService;
import innowake.mining.shared.entities.ModulePojo;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockFlag;
import innowake.mining.shared.entities.functionalblocks.FunctionalBlockPojo;
import innowake.mining.shared.entities.functionalblocks.GeneratedFrom;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.stream.Collectors;

/**
 * For blocks that were generated from a Module, updates the {@linkplain GeneratedFrom#getContentChanged() content changed} timestamp
 * if the Module's content has changed or the {@linkplain GeneratedFrom#getMissingSince() missing since} timestamp if the Module went missing.
 */
@Component
public class ChangedAndMissingModulesComputation implements FunctionalBlockComputation<GeneratedFrom> {

	private final FunctionalBlockService functionalBlockService;
	private final ModuleService moduleService;

	public ChangedAndMissingModulesComputation(final FunctionalBlockService functionalBlockService, final ModuleService moduleService) {
		this.functionalBlockService = functionalBlockService;
		this.moduleService = moduleService;
	}

	@Override
	public boolean accept(final FunctionalBlockPojo functionalBlock) {
		/* this computation runs only on blocks generated by the ModuleBlockGeneration */
		return ModuleBlockGeneration.MODULE_BLOCK_GENERATION_ID.equals(functionalBlock.getFlags().get(FunctionalBlockFlag.GENERATED_BY.name()));
	}

	@Override
	public Map<FunctionalBlockPojo, GeneratedFrom> computeBatched(final List<FunctionalBlockPojo> functionalBlocks, final ProgressMonitor progressMonitor) {

		final Map<FunctionalBlockPojo, GeneratedFrom> result = new HashMap<>();
		if ( ! functionalBlocks.isEmpty()) {
			final Map<UUID, GeneratedFrom> generatedFromMap = functionalBlockService.getGeneratedFrom(
					functionalBlocks.stream().map(FunctionalBlockPojo::getUid).collect(Collectors.toList()));

			final Map<FunctionalBlockPojo, GeneratedFrom> functionalBlockPojoMap = generateAMapOfBlockAndGeneratedForm(generatedFromMap, functionalBlocks);
			final List<String> linkHashes = functionalBlockPojoMap.values().stream()
					.map(GeneratedFrom::getModuleLinkHash)
					.filter(Optional::isPresent)
					.map(Optional::get)
					.collect(Collectors.toList());
			final Map<String, ModulePojo> moduleMap = moduleService.findModules(q -> q.ofProject(functionalBlocks.get(0).getProject())
							.withLinkHashes(linkHashes)).stream()
					.collect(Collectors.toMap(ModulePojo::getLinkHash, m -> m));
			for (final var entry : functionalBlockPojoMap.entrySet()) {
				final FunctionalBlockPojo block = entry.getKey();
				final GeneratedFrom generatedFrom = entry.getValue();
				final Optional<String> moduleLinkHash = generatedFrom.getModuleLinkHash();
				if (moduleLinkHash.isPresent()) {
					final ModulePojo module = moduleMap.get(moduleLinkHash.get());

					if (module == null) {
						result.put(block, generatedFrom.withMissingSince(Instant.now()));
						continue;
					}

					final Optional<String> moduleContentHash = generatedFrom.getModuleContentHash();
					final Optional<BinaryValue> binaryValue = module.getContentHash();
					if (moduleContentHash.isPresent() && binaryValue.isPresent() &&
							! Objects.equals(binaryValue.get().toString(), moduleContentHash.get())) {
						result.put(block, generatedFrom
								.withModuleContentHash(binaryValue.get().toString())
								.withContentChanged(Instant.now()));
					}

					final Optional<String> generatedFromModuleDependencyHash = generatedFrom.getModuleDependencyHash();
					final Optional<String> moduleDependencyHash = module.getDependencyHash();

					if (moduleDependencyHash.isPresent() && generatedFromModuleDependencyHash.isPresent() &&
							! Objects.equals(generatedFromModuleDependencyHash.get(), moduleDependencyHash.get())) {
						result.put(block, generatedFrom
								.withModuleDependencyHash(moduleDependencyHash.get())
								.withDependencyChanged(Instant.now()));
					}
				}

			}
		}

		return result;
	}

	private Map<FunctionalBlockPojo, GeneratedFrom> generateAMapOfBlockAndGeneratedForm(final Map<UUID, GeneratedFrom> generatedFroms,
			final List<FunctionalBlockPojo> functionalBlockPojos) {

		final Map<FunctionalBlockPojo, GeneratedFrom> functionalBlockPojoMap = new HashMap<>();
		for (final FunctionalBlockPojo block : functionalBlockPojos) {
			functionalBlockPojoMap.put(block, generatedFroms.get(block.getUid()));
		}
		return functionalBlockPojoMap;
	}

	@Override
	public void persist(final UUID functionalBlockId, final GeneratedFrom data) {
		if (data != null) {
			functionalBlockService.setGeneratedFrom(functionalBlockId, data);
		}
	}

}
