/* tslint:disable */
/* eslint-disable */
/**
 * Mining Server REST API
 * This is the description of the mining server REST API endpoints.
 *
 * The version of the OpenAPI document: 99.9.99-TRUNK-MINING-SNAPSHOT
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AggregationRequestAnnotationFieldName
 */
export interface AggregationRequestAnnotationFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestAnnotationFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestAnnotationFieldName
     */
    'groupBy'?: Set<AggregationRequestAnnotationFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestAnnotationFieldName
     */
    'orderBy'?: Array<AggregationRequestAnnotationFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestAnnotationFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestAnnotationFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestAnnotationFieldNameGroupByEnum = {
    ID: 'ID',
    NAME: 'NAME',
    PROJECT_ID: 'PROJECT_ID',
    CATEGORY: 'CATEGORY',
    STATE: 'STATE',
    TYPE: 'TYPE',
    CREATED_BY_USER_ID: 'CREATED_BY_USER_ID',
    UPDATED_BY_USER_ID: 'UPDATED_BY_USER_ID',
    SOURCE_ATTACHMENT: 'SOURCE_ATTACHMENT',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    METADATA: 'METADATA',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestAnnotationFieldNameGroupByEnum = typeof AggregationRequestAnnotationFieldNameGroupByEnum[keyof typeof AggregationRequestAnnotationFieldNameGroupByEnum];
export const AggregationRequestAnnotationFieldNameOrderByEnum = {
    ID: 'ID',
    NAME: 'NAME',
    PROJECT_ID: 'PROJECT_ID',
    CATEGORY: 'CATEGORY',
    STATE: 'STATE',
    TYPE: 'TYPE',
    CREATED_BY_USER_ID: 'CREATED_BY_USER_ID',
    UPDATED_BY_USER_ID: 'UPDATED_BY_USER_ID',
    SOURCE_ATTACHMENT: 'SOURCE_ATTACHMENT',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    METADATA: 'METADATA',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestAnnotationFieldNameOrderByEnum = typeof AggregationRequestAnnotationFieldNameOrderByEnum[keyof typeof AggregationRequestAnnotationFieldNameOrderByEnum];
export const AggregationRequestAnnotationFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestAnnotationFieldNameFieldsEnum = typeof AggregationRequestAnnotationFieldNameFieldsEnum[keyof typeof AggregationRequestAnnotationFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationRequestDataDictionaryFieldName
 */
export interface AggregationRequestDataDictionaryFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestDataDictionaryFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestDataDictionaryFieldName
     */
    'groupBy'?: Set<AggregationRequestDataDictionaryFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestDataDictionaryFieldName
     */
    'orderBy'?: Array<AggregationRequestDataDictionaryFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestDataDictionaryFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestDataDictionaryFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestDataDictionaryFieldNameGroupByEnum = {
    PROJECT_ID: 'PROJECT_ID',
    ID: 'ID',
    DATA_ELEMENT_NAME: 'DATA_ELEMENT_NAME',
    DESCRIPTION: 'DESCRIPTION',
    FORMAT: 'FORMAT',
    LENGTH: 'LENGTH',
    OTHER_SCOPE_LINK: 'OTHER_SCOPE_LINK',
    OTHER_SCOPE_SOURCE: 'OTHER_SCOPE_SOURCE',
    CREATED_BY_USER_ID: 'CREATED_BY_USER_ID',
    UPDATED_BY_USER_ID: 'UPDATED_BY_USER_ID',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    SCOPE_LINK: 'SCOPE_LINK',
    SCOPE_ATTRIBUTES: 'SCOPE_ATTRIBUTES',
    IS_CANDIDATE: 'IS_CANDIDATE',
    PIC_CLAUSE: 'PIC_CLAUSE',
    DEFINED_LOCATION: 'DEFINED_LOCATION',
    STATE: 'STATE',
    IS_BUSINESS: 'IS_BUSINESS',
    FIELD_TRANSFORMATION: 'FIELD_TRANSFORMATION',
    SOURCE_INPUT: 'SOURCE_INPUT',
    TARGET_OUTPUT: 'TARGET_OUTPUT',
    IS_REFERENCED: 'IS_REFERENCED',
    FIELD_USAGE: 'FIELD_USAGE',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestDataDictionaryFieldNameGroupByEnum = typeof AggregationRequestDataDictionaryFieldNameGroupByEnum[keyof typeof AggregationRequestDataDictionaryFieldNameGroupByEnum];
export const AggregationRequestDataDictionaryFieldNameOrderByEnum = {
    PROJECT_ID: 'PROJECT_ID',
    ID: 'ID',
    DATA_ELEMENT_NAME: 'DATA_ELEMENT_NAME',
    DESCRIPTION: 'DESCRIPTION',
    FORMAT: 'FORMAT',
    LENGTH: 'LENGTH',
    OTHER_SCOPE_LINK: 'OTHER_SCOPE_LINK',
    OTHER_SCOPE_SOURCE: 'OTHER_SCOPE_SOURCE',
    CREATED_BY_USER_ID: 'CREATED_BY_USER_ID',
    UPDATED_BY_USER_ID: 'UPDATED_BY_USER_ID',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    SCOPE_LINK: 'SCOPE_LINK',
    SCOPE_ATTRIBUTES: 'SCOPE_ATTRIBUTES',
    IS_CANDIDATE: 'IS_CANDIDATE',
    PIC_CLAUSE: 'PIC_CLAUSE',
    DEFINED_LOCATION: 'DEFINED_LOCATION',
    STATE: 'STATE',
    IS_BUSINESS: 'IS_BUSINESS',
    FIELD_TRANSFORMATION: 'FIELD_TRANSFORMATION',
    SOURCE_INPUT: 'SOURCE_INPUT',
    TARGET_OUTPUT: 'TARGET_OUTPUT',
    IS_REFERENCED: 'IS_REFERENCED',
    FIELD_USAGE: 'FIELD_USAGE',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestDataDictionaryFieldNameOrderByEnum = typeof AggregationRequestDataDictionaryFieldNameOrderByEnum[keyof typeof AggregationRequestDataDictionaryFieldNameOrderByEnum];
export const AggregationRequestDataDictionaryFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestDataDictionaryFieldNameFieldsEnum = typeof AggregationRequestDataDictionaryFieldNameFieldsEnum[keyof typeof AggregationRequestDataDictionaryFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationRequestModuleFieldName
 */
export interface AggregationRequestModuleFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestModuleFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestModuleFieldName
     */
    'groupBy'?: Set<AggregationRequestModuleFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestModuleFieldName
     */
    'orderBy'?: Array<AggregationRequestModuleFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestModuleFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestModuleFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestModuleFieldNameGroupByEnum = {
    ID: 'ID',
    UID: 'UID',
    NAME: 'NAME',
    PROJECT_ID: 'PROJECT_ID',
    TECHNOLOGY: 'TECHNOLOGY',
    TYPE: 'TYPE',
    REQUIRES_REVIEW: 'REQUIRES_REVIEW',
    STORAGE: 'STORAGE',
    CREATOR: 'CREATOR',
    IDENTIFICATION: 'IDENTIFICATION',
    LINES_OF_CODE: 'LINES_OF_CODE',
    LINES_OF_COMMENT: 'LINES_OF_COMMENT',
    LINES_OF_DEAD_CODE: 'LINES_OF_DEAD_CODE',
    COMPLEXITY: 'COMPLEXITY',
    ERRORS: 'ERRORS',
    REPRESENTATION: 'REPRESENTATION',
    SQL_STATEMENTS: 'SQL_STATEMENTS',
    CONTAINING_MODULE_ID: 'CONTAINING_MODULE_ID',
    CONTAINING_MODULE_NAME: 'CONTAINING_MODULE_NAME',
    PHYSICAL_LINES_OF_CODE: 'PHYSICAL_LINES_OF_CODE',
    TAXONOMY_ID: 'TAXONOMY_ID',
    CATEGORIES: 'CATEGORIES',
    INTERFACE: 'INTERFACE',
    INBOUND: 'INBOUND',
    OUTBOUND: 'OUTBOUND',
    ORIGIN: 'ORIGIN'
} as const;

export type AggregationRequestModuleFieldNameGroupByEnum = typeof AggregationRequestModuleFieldNameGroupByEnum[keyof typeof AggregationRequestModuleFieldNameGroupByEnum];
export const AggregationRequestModuleFieldNameOrderByEnum = {
    ID: 'ID',
    UID: 'UID',
    NAME: 'NAME',
    PROJECT_ID: 'PROJECT_ID',
    TECHNOLOGY: 'TECHNOLOGY',
    TYPE: 'TYPE',
    REQUIRES_REVIEW: 'REQUIRES_REVIEW',
    STORAGE: 'STORAGE',
    CREATOR: 'CREATOR',
    IDENTIFICATION: 'IDENTIFICATION',
    LINES_OF_CODE: 'LINES_OF_CODE',
    LINES_OF_COMMENT: 'LINES_OF_COMMENT',
    LINES_OF_DEAD_CODE: 'LINES_OF_DEAD_CODE',
    COMPLEXITY: 'COMPLEXITY',
    ERRORS: 'ERRORS',
    REPRESENTATION: 'REPRESENTATION',
    SQL_STATEMENTS: 'SQL_STATEMENTS',
    CONTAINING_MODULE_ID: 'CONTAINING_MODULE_ID',
    CONTAINING_MODULE_NAME: 'CONTAINING_MODULE_NAME',
    PHYSICAL_LINES_OF_CODE: 'PHYSICAL_LINES_OF_CODE',
    TAXONOMY_ID: 'TAXONOMY_ID',
    CATEGORIES: 'CATEGORIES',
    INTERFACE: 'INTERFACE',
    INBOUND: 'INBOUND',
    OUTBOUND: 'OUTBOUND',
    ORIGIN: 'ORIGIN'
} as const;

export type AggregationRequestModuleFieldNameOrderByEnum = typeof AggregationRequestModuleFieldNameOrderByEnum[keyof typeof AggregationRequestModuleFieldNameOrderByEnum];
export const AggregationRequestModuleFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestModuleFieldNameFieldsEnum = typeof AggregationRequestModuleFieldNameFieldsEnum[keyof typeof AggregationRequestModuleFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationRequestRelationshipFieldName
 */
export interface AggregationRequestRelationshipFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestRelationshipFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestRelationshipFieldName
     */
    'groupBy'?: Set<AggregationRequestRelationshipFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestRelationshipFieldName
     */
    'orderBy'?: Array<AggregationRequestRelationshipFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestRelationshipFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestRelationshipFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestRelationshipFieldNameGroupByEnum = {
    ID: 'ID',
    RELATIONSHIP: 'RELATIONSHIP',
    DST_ID: 'DST_ID',
    SRC_ID: 'SRC_ID',
    DST_NAME: 'DST_NAME',
    SRC_NAME: 'SRC_NAME',
    DST_PROJECT_ID: 'DST_PROJECT_ID',
    SRC_PROJECT_ID: 'SRC_PROJECT_ID',
    DST_TECHNOLOGY: 'DST_TECHNOLOGY',
    SRC_TECHNOLOGY: 'SRC_TECHNOLOGY',
    DST_TYPE: 'DST_TYPE',
    SRC_TYPE: 'SRC_TYPE',
    PROPERTY_DB_ACCESS_TYPE: 'PROPERTY_DB_ACCESS_TYPE',
    PROPERTY_DB_ACCESS_OPERATION: 'PROPERTY_DB_ACCESS_OPERATION',
    SRC_LINKHASH: 'SRC_LINKHASH',
    DST_LINKHASH: 'DST_LINKHASH',
    SRC_STORAGE: 'SRC_STORAGE',
    DST_STORAGE: 'DST_STORAGE',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestRelationshipFieldNameGroupByEnum = typeof AggregationRequestRelationshipFieldNameGroupByEnum[keyof typeof AggregationRequestRelationshipFieldNameGroupByEnum];
export const AggregationRequestRelationshipFieldNameOrderByEnum = {
    ID: 'ID',
    RELATIONSHIP: 'RELATIONSHIP',
    DST_ID: 'DST_ID',
    SRC_ID: 'SRC_ID',
    DST_NAME: 'DST_NAME',
    SRC_NAME: 'SRC_NAME',
    DST_PROJECT_ID: 'DST_PROJECT_ID',
    SRC_PROJECT_ID: 'SRC_PROJECT_ID',
    DST_TECHNOLOGY: 'DST_TECHNOLOGY',
    SRC_TECHNOLOGY: 'SRC_TECHNOLOGY',
    DST_TYPE: 'DST_TYPE',
    SRC_TYPE: 'SRC_TYPE',
    PROPERTY_DB_ACCESS_TYPE: 'PROPERTY_DB_ACCESS_TYPE',
    PROPERTY_DB_ACCESS_OPERATION: 'PROPERTY_DB_ACCESS_OPERATION',
    SRC_LINKHASH: 'SRC_LINKHASH',
    DST_LINKHASH: 'DST_LINKHASH',
    SRC_STORAGE: 'SRC_STORAGE',
    DST_STORAGE: 'DST_STORAGE',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestRelationshipFieldNameOrderByEnum = typeof AggregationRequestRelationshipFieldNameOrderByEnum[keyof typeof AggregationRequestRelationshipFieldNameOrderByEnum];
export const AggregationRequestRelationshipFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestRelationshipFieldNameFieldsEnum = typeof AggregationRequestRelationshipFieldNameFieldsEnum[keyof typeof AggregationRequestRelationshipFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationRequestStatementFieldName
 */
export interface AggregationRequestStatementFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestStatementFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestStatementFieldName
     */
    'groupBy'?: Set<AggregationRequestStatementFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestStatementFieldName
     */
    'orderBy'?: Array<AggregationRequestStatementFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestStatementFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestStatementFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestStatementFieldNameGroupByEnum = {
    ID: 'ID',
    PROJECT_ID: 'PROJECT_ID',
    MODULE_ID: 'MODULE_ID',
    TECHNOLOGY: 'TECHNOLOGY',
    STATEMENT_TYPE: 'STATEMENT_TYPE',
    TEXT: 'TEXT',
    TEXT_LENGTH: 'TEXT_LENGTH',
    CUSTOM_COMPLEXITY: 'CUSTOM_COMPLEXITY',
    DISTINCT_TABLES: 'DISTINCT_TABLES',
    HALSTEAD_COMPLEXITY: 'HALSTEAD_COMPLEXITY',
    HALSTEAD_DIFFICULTY: 'HALSTEAD_DIFFICULTY',
    SQL_LENGTH: 'SQL_LENGTH',
    TABLES: 'TABLES',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestStatementFieldNameGroupByEnum = typeof AggregationRequestStatementFieldNameGroupByEnum[keyof typeof AggregationRequestStatementFieldNameGroupByEnum];
export const AggregationRequestStatementFieldNameOrderByEnum = {
    ID: 'ID',
    PROJECT_ID: 'PROJECT_ID',
    MODULE_ID: 'MODULE_ID',
    TECHNOLOGY: 'TECHNOLOGY',
    STATEMENT_TYPE: 'STATEMENT_TYPE',
    TEXT: 'TEXT',
    TEXT_LENGTH: 'TEXT_LENGTH',
    CUSTOM_COMPLEXITY: 'CUSTOM_COMPLEXITY',
    DISTINCT_TABLES: 'DISTINCT_TABLES',
    HALSTEAD_COMPLEXITY: 'HALSTEAD_COMPLEXITY',
    HALSTEAD_DIFFICULTY: 'HALSTEAD_DIFFICULTY',
    SQL_LENGTH: 'SQL_LENGTH',
    TABLES: 'TABLES',
    TAXONOMY_ID: 'TAXONOMY_ID'
} as const;

export type AggregationRequestStatementFieldNameOrderByEnum = typeof AggregationRequestStatementFieldNameOrderByEnum[keyof typeof AggregationRequestStatementFieldNameOrderByEnum];
export const AggregationRequestStatementFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestStatementFieldNameFieldsEnum = typeof AggregationRequestStatementFieldNameFieldsEnum[keyof typeof AggregationRequestStatementFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationRequestTaxonomyFieldName
 */
export interface AggregationRequestTaxonomyFieldName {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: object; }; }}
     * @memberof AggregationRequestTaxonomyFieldName
     */
    'filterObject'?: { [key: string]: { [key: string]: object; }; };
    /**
     * 
     * @type {Set<string>}
     * @memberof AggregationRequestTaxonomyFieldName
     */
    'groupBy'?: Set<AggregationRequestTaxonomyFieldNameGroupByEnum>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AggregationRequestTaxonomyFieldName
     */
    'orderBy'?: Array<AggregationRequestTaxonomyFieldNameOrderByEnum>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestTaxonomyFieldName
     */
    'fields'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AggregationRequestTaxonomyFieldName
     */
    'csvHeaders'?: { [key: string]: string; };
}

export const AggregationRequestTaxonomyFieldNameGroupByEnum = {
    PROJECT_ID: 'PROJECT_ID',
    ID: 'ID',
    NAME: 'NAME',
    TYPE_NAME: 'TYPE_NAME',
    CATEGORY_NAME: 'CATEGORY_NAME',
    MODULE_ID: 'MODULE_ID',
    MODULE_NAME: 'MODULE_NAME',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    MODULE_REPRESENTATION: 'MODULE_REPRESENTATION',
    MODULE_COMPLEXITY: 'MODULE_COMPLEXITY',
    MODULE_LINES_OF_CODE: 'MODULE_LINES_OF_CODE',
    MODULE_LINES_OF_COMMENT: 'MODULE_LINES_OF_COMMENT',
    MODULE_LINES_OF_DEAD_CODE: 'MODULE_LINES_OF_DEAD_CODE'
} as const;

export type AggregationRequestTaxonomyFieldNameGroupByEnum = typeof AggregationRequestTaxonomyFieldNameGroupByEnum[keyof typeof AggregationRequestTaxonomyFieldNameGroupByEnum];
export const AggregationRequestTaxonomyFieldNameOrderByEnum = {
    PROJECT_ID: 'PROJECT_ID',
    ID: 'ID',
    NAME: 'NAME',
    TYPE_NAME: 'TYPE_NAME',
    CATEGORY_NAME: 'CATEGORY_NAME',
    MODULE_ID: 'MODULE_ID',
    MODULE_NAME: 'MODULE_NAME',
    MODULE_TECHNOLOGY: 'MODULE_TECHNOLOGY',
    MODULE_TYPE: 'MODULE_TYPE',
    MODULE_REPRESENTATION: 'MODULE_REPRESENTATION',
    MODULE_COMPLEXITY: 'MODULE_COMPLEXITY',
    MODULE_LINES_OF_CODE: 'MODULE_LINES_OF_CODE',
    MODULE_LINES_OF_COMMENT: 'MODULE_LINES_OF_COMMENT',
    MODULE_LINES_OF_DEAD_CODE: 'MODULE_LINES_OF_DEAD_CODE'
} as const;

export type AggregationRequestTaxonomyFieldNameOrderByEnum = typeof AggregationRequestTaxonomyFieldNameOrderByEnum[keyof typeof AggregationRequestTaxonomyFieldNameOrderByEnum];
export const AggregationRequestTaxonomyFieldNameFieldsEnum = {
    MIN: 'MIN',
    MAX: 'MAX',
    SUM: 'SUM',
    AVG: 'AVG',
    LIST: 'LIST',
    COUNT: 'COUNT',
    COUNT_DISTINCT: 'COUNT_DISTINCT',
    MODE: 'MODE',
    MEDIAN: 'MEDIAN',
    VARIANCE: 'VARIANCE',
    STDDEV: 'STDDEV',
    PERCENTILE_70: 'PERCENTILE_70',
    PERCENTILE_80: 'PERCENTILE_80',
    PERCENTILE_90: 'PERCENTILE_90',
    PERCENTILE_95: 'PERCENTILE_95',
    PERCENTILE_99: 'PERCENTILE_99'
} as const;

export type AggregationRequestTaxonomyFieldNameFieldsEnum = typeof AggregationRequestTaxonomyFieldNameFieldsEnum[keyof typeof AggregationRequestTaxonomyFieldNameFieldsEnum];

/**
 * 
 * @export
 * @interface AggregationResultAnnotationFieldName
 */
export interface AggregationResultAnnotationFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultAnnotationFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultAnnotationFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AggregationResultDataDictionaryFieldName
 */
export interface AggregationResultDataDictionaryFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultDataDictionaryFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultDataDictionaryFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AggregationResultModuleFieldName
 */
export interface AggregationResultModuleFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultModuleFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultModuleFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AggregationResultRelationshipFieldName
 */
export interface AggregationResultRelationshipFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultRelationshipFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultRelationshipFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AggregationResultStatementFieldName
 */
export interface AggregationResultStatementFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultStatementFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultStatementFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AggregationResultTaxonomyFieldName
 */
export interface AggregationResultTaxonomyFieldName {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultTaxonomyFieldName
     */
    'group'?: { [key: string]: object; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AggregationResultTaxonomyFieldName
     */
    'fields'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface AliasDefinition
 */
export interface AliasDefinition {
    /**
     * 
     * @type {string}
     * @memberof AliasDefinition
     */
    'aliasFor'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasDefinition
     */
    'subSelection'?: string;
    /**
     * 
     * @type {string}
     * @memberof AliasDefinition
     */
    'jsonPath'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AliasDefinition
     */
    'parameters'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AnnotationCategory
 */
export interface AnnotationCategory {
    /**
     * 
     * @type {string}
     * @memberof AnnotationCategory
     */
    'recordId'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AnnotationCategory
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof AnnotationCategory
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationCategory
     */
    'name'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof AnnotationCategory
     */
    'projectId'?: EntityId;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnotationCategory
     */
    'types'?: Array<AnnotationCategoryTypesEnum>;
}

export const AnnotationCategoryTypesEnum = {
    DATABASE: 'DATABASE',
    DEAD_CODE: 'DEAD_CODE',
    EXCLUDE: 'EXCLUDE',
    RULE: 'RULE',
    FUNCTIONAL: 'FUNCTIONAL'
} as const;

export type AnnotationCategoryTypesEnum = typeof AnnotationCategoryTypesEnum[keyof typeof AnnotationCategoryTypesEnum];

/**
 * 
 * @export
 * @interface AnnotationPojo
 */
export interface AnnotationPojo {
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof AnnotationPojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'state'?: AnnotationPojoStateEnum;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'type'?: AnnotationPojoTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'categoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'categoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'updatedByUserId'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof AnnotationPojo
     */
    'moduleEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'module'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'moduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'modulePath'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof AnnotationPojo
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'sourceAttachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'englishTranslation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnotationPojo
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnotationPojo
     */
    'dataDictionaryEntries'?: Array<string>;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof AnnotationPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'length'?: number;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'offset'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'createdByUserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojo
     */
    'updatedByUserName'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojo
     */
    'id'?: number;
}

export const AnnotationPojoStateEnum = {
    CANDIDATE: 'CANDIDATE',
    IN_ANALYSIS: 'IN_ANALYSIS',
    FOR_REVIEW: 'FOR_REVIEW',
    REJECTED: 'REJECTED',
    APPROVED: 'APPROVED',
    INVALID: 'INVALID'
} as const;

export type AnnotationPojoStateEnum = typeof AnnotationPojoStateEnum[keyof typeof AnnotationPojoStateEnum];
export const AnnotationPojoTypeEnum = {
    DATABASE: 'DATABASE',
    DEAD_CODE: 'DEAD_CODE',
    EXCLUDE: 'EXCLUDE',
    RULE: 'RULE',
    FUNCTIONAL: 'FUNCTIONAL'
} as const;

export type AnnotationPojoTypeEnum = typeof AnnotationPojoTypeEnum[keyof typeof AnnotationPojoTypeEnum];

/**
 * 
 * @export
 * @interface AnnotationPojoPrototype
 */
export interface AnnotationPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AnnotationPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof AnnotationPojoPrototype
     */
    'module'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof AnnotationPojoPrototype
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'state'?: AnnotationPojoPrototypeStateEnum;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'type'?: AnnotationPojoPrototypeTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnnotationPojoPrototype
     */
    'categoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'updatedByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'sourceAttachment'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationPojoPrototype
     */
    'englishTranslation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AnnotationPojoPrototype
     */
    'reasons'?: Array<string>;
    /**
     * 
     * @type {EntityId}
     * @memberof AnnotationPojoPrototype
     */
    'id'?: EntityId;
}

export const AnnotationPojoPrototypeStateEnum = {
    CANDIDATE: 'CANDIDATE',
    IN_ANALYSIS: 'IN_ANALYSIS',
    FOR_REVIEW: 'FOR_REVIEW',
    REJECTED: 'REJECTED',
    APPROVED: 'APPROVED',
    INVALID: 'INVALID'
} as const;

export type AnnotationPojoPrototypeStateEnum = typeof AnnotationPojoPrototypeStateEnum[keyof typeof AnnotationPojoPrototypeStateEnum];
export const AnnotationPojoPrototypeTypeEnum = {
    DATABASE: 'DATABASE',
    DEAD_CODE: 'DEAD_CODE',
    EXCLUDE: 'EXCLUDE',
    RULE: 'RULE',
    FUNCTIONAL: 'FUNCTIONAL'
} as const;

export type AnnotationPojoPrototypeTypeEnum = typeof AnnotationPojoPrototypeTypeEnum[keyof typeof AnnotationPojoPrototypeTypeEnum];

/**
 * 
 * @export
 * @interface AnnotationReport
 */
export interface AnnotationReport {
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'recordId'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AnnotationReport
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof AnnotationReport
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof AnnotationReport
     */
    'moduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'annotationType'?: AnnotationReportAnnotationTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AnnotationReport
     */
    'categoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'categoryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'annotationState'?: AnnotationReportAnnotationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'sourceCode'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'taxonomy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'updatedByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'createdByUserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReport
     */
    'updatedByUserName'?: string;
}

export const AnnotationReportAnnotationTypeEnum = {
    DATABASE: 'DATABASE',
    DEAD_CODE: 'DEAD_CODE',
    EXCLUDE: 'EXCLUDE',
    RULE: 'RULE',
    FUNCTIONAL: 'FUNCTIONAL'
} as const;

export type AnnotationReportAnnotationTypeEnum = typeof AnnotationReportAnnotationTypeEnum[keyof typeof AnnotationReportAnnotationTypeEnum];
export const AnnotationReportAnnotationStateEnum = {
    CANDIDATE: 'CANDIDATE',
    IN_ANALYSIS: 'IN_ANALYSIS',
    FOR_REVIEW: 'FOR_REVIEW',
    REJECTED: 'REJECTED',
    APPROVED: 'APPROVED',
    INVALID: 'INVALID'
} as const;

export type AnnotationReportAnnotationStateEnum = typeof AnnotationReportAnnotationStateEnum[keyof typeof AnnotationReportAnnotationStateEnum];

/**
 * 
 * @export
 * @interface AnnotationReportResponse
 */
export interface AnnotationReportResponse {
    /**
     * 
     * @type {Array<AnnotationReport>}
     * @memberof AnnotationReportResponse
     */
    'annotationReports'?: Array<AnnotationReport>;
    /**
     * 
     * @type {number}
     * @memberof AnnotationReportResponse
     */
    'numberOfRecords'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof AnnotationReportResponse
     */
    'hasMoreRecords'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof AnnotationReportResponse
     */
    'recordLimit'?: number;
    /**
     * 
     * @type {Array<AnnotationReport>}
     * @memberof AnnotationReportResponse
     */
    'annotationReportList'?: Array<AnnotationReport>;
}
/**
 * 
 * @export
 * @interface AnnotationReportSearchParameter
 */
export interface AnnotationReportSearchParameter {
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'updatedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'moduleName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'moduleTaxonomy'?: string;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'annotationType'?: AnnotationReportSearchParameterAnnotationTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AnnotationReportSearchParameter
     */
    'annotationCategory'?: string;
}

export const AnnotationReportSearchParameterAnnotationTypeEnum = {
    DATABASE: 'DATABASE',
    DEAD_CODE: 'DEAD_CODE',
    EXCLUDE: 'EXCLUDE',
    RULE: 'RULE',
    FUNCTIONAL: 'FUNCTIONAL'
} as const;

export type AnnotationReportSearchParameterAnnotationTypeEnum = typeof AnnotationReportSearchParameterAnnotationTypeEnum[keyof typeof AnnotationReportSearchParameterAnnotationTypeEnum];

/**
 * 
 * @export
 * @interface AnnotationSearch
 */
export interface AnnotationSearch {
    /**
     * 
     * @type {Array<AnnotationPojo>}
     * @memberof AnnotationSearch
     */
    'elements'?: Array<AnnotationPojo>;
    /**
     * 
     * @type {number}
     * @memberof AnnotationSearch
     */
    'overallSize'?: number;
}
/**
 * 
 * @export
 * @interface ApplicationContext
 */
export interface ApplicationContext {
    /**
     * 
     * @type {ApplicationContext}
     * @memberof ApplicationContext
     */
    'parent'?: ApplicationContext;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContext
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContext
     */
    'displayName'?: string;
    /**
     * 
     * @type {object}
     * @memberof ApplicationContext
     */
    'autowireCapableBeanFactory'?: object;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContext
     */
    'applicationName'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApplicationContext
     */
    'startupDate'?: number;
    /**
     * 
     * @type {Environment}
     * @memberof ApplicationContext
     */
    'environment'?: Environment;
    /**
     * 
     * @type {number}
     * @memberof ApplicationContext
     */
    'beanDefinitionCount'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof ApplicationContext
     */
    'beanDefinitionNames'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ApplicationContext
     */
    'parentBeanFactory'?: object;
    /**
     * 
     * @type {ApplicationContextClassLoader}
     * @memberof ApplicationContext
     */
    'classLoader'?: ApplicationContextClassLoader;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoader
 */
export interface ApplicationContextClassLoader {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoader
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoader
     */
    'registeredAsParallelCapable'?: boolean;
    /**
     * 
     * @type {ApplicationContextClassLoaderParent}
     * @memberof ApplicationContextClassLoader
     */
    'parent'?: ApplicationContextClassLoaderParent;
    /**
     * 
     * @type {ApplicationContextClassLoaderParentUnnamedModule}
     * @memberof ApplicationContextClassLoader
     */
    'unnamedModule'?: ApplicationContextClassLoaderParentUnnamedModule;
    /**
     * 
     * @type {Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>}
     * @memberof ApplicationContextClassLoader
     */
    'definedPackages'?: Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoader
     */
    'defaultAssertionStatus'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoaderParent
 */
export interface ApplicationContextClassLoaderParent {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParent
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParent
     */
    'registeredAsParallelCapable'?: boolean;
    /**
     * 
     * @type {ApplicationContextClassLoaderParentUnnamedModule}
     * @memberof ApplicationContextClassLoaderParent
     */
    'unnamedModule'?: ApplicationContextClassLoaderParentUnnamedModule;
    /**
     * 
     * @type {Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>}
     * @memberof ApplicationContextClassLoaderParent
     */
    'definedPackages'?: Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParent
     */
    'defaultAssertionStatus'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoaderParentUnnamedModule
 */
export interface ApplicationContextClassLoaderParentUnnamedModule {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'name'?: string;
    /**
     * 
     * @type {ApplicationContextClassLoaderParentUnnamedModuleClassLoader}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'classLoader'?: ApplicationContextClassLoaderParentUnnamedModuleClassLoader;
    /**
     * 
     * @type {ApplicationContextClassLoaderParentUnnamedModuleDescriptor}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'descriptor'?: ApplicationContextClassLoaderParentUnnamedModuleDescriptor;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'named'?: boolean;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {Set<string>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'packages'?: Set<string>;
    /**
     * 
     * @type {object}
     * @memberof ApplicationContextClassLoaderParentUnnamedModule
     */
    'layer'?: object;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoaderParentUnnamedModuleClassLoader
 */
export interface ApplicationContextClassLoaderParentUnnamedModuleClassLoader {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoader
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoader
     */
    'registeredAsParallelCapable'?: boolean;
    /**
     * 
     * @type {Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoader
     */
    'definedPackages'?: Array<ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner>;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoader
     */
    'defaultAssertionStatus'?: boolean;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
 */
export interface ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner {
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'name'?: string;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'annotations'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'declaredAnnotations'?: Array<object>;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'sealed'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'specificationTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'specificationVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'specificationVendor'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'implementationTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'implementationVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleClassLoaderDefinedPackagesInner
     */
    'implementationVendor'?: string;
}
/**
 * 
 * @export
 * @interface ApplicationContextClassLoaderParentUnnamedModuleDescriptor
 */
export interface ApplicationContextClassLoaderParentUnnamedModuleDescriptor {
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleDescriptor
     */
    'open'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ApplicationContextClassLoaderParentUnnamedModuleDescriptor
     */
    'automatic'?: boolean;
}
/**
 * 
 * @export
 * @interface AssembledContent
 */
export interface AssembledContent {
    /**
     * 
     * @type {boolean}
     * @memberof AssembledContent
     */
    'available'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof AssembledContent
     */
    'content'?: string;
    /**
     * 
     * @type {Array<Inclusion>}
     * @memberof AssembledContent
     */
    'inclusions'?: Array<Inclusion>;
}
/**
 * 
 * @export
 * @interface Candidate
 */
export interface Candidate {
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Candidate
     */
    'pathPattern'?: string;
    /**
     * 
     * @type {Candidate}
     * @memberof Candidate
     */
    'containedIn'?: Candidate;
}
/**
 * 
 * @export
 * @interface ClientPojo
 */
export interface ClientPojo {
    /**
     * 
     * @type {string}
     * @memberof ClientPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof ClientPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {number}
     * @memberof ClientPojo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientPojo
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ClientPojo
     */
    'hasLogo'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ClientPojo
     */
    'markedDeleted'?: boolean;
}
/**
 * 
 * @export
 * @interface ClientPojoPrototype
 */
export interface ClientPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof ClientPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ClientPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof ClientPojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {string}
     * @memberof ClientPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ClientPojoPrototype
     */
    'id'?: EntityId;
}
/**
 * 
 * @export
 * @interface CodeViewerLink
 */
export interface CodeViewerLink {
    /**
     * 
     * @type {string}
     * @memberof CodeViewerLink
     */
    'linkType'?: CodeViewerLinkLinkTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CodeViewerLink
     */
    'linkTargetType'?: CodeViewerLinkLinkTargetTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CodeViewerLink
     */
    'relationshipLabel'?: string;
    /**
     * 
     * @type {string}
     * @memberof CodeViewerLink
     */
    'targetLabel'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof CodeViewerLink
     */
    'fromModuleId'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof CodeViewerLink
     */
    'fromModuleLocation'?: ModuleLocation;
    /**
     * 
     * @type {CodeViewerRange}
     * @memberof CodeViewerLink
     */
    'fromRange'?: CodeViewerRange;
    /**
     * 
     * @type {EntityId}
     * @memberof CodeViewerLink
     */
    'toModuleId'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof CodeViewerLink
     */
    'toModuleLocation'?: ModuleLocation;
    /**
     * 
     * @type {CodeViewerRange}
     * @memberof CodeViewerLink
     */
    'toRange'?: CodeViewerRange;
}

export const CodeViewerLinkLinkTypeEnum = {
    AST_BINDING: 'AST_BINDING',
    CONTROL_FLOW: 'CONTROL_FLOW',
    DEPENDENCY: 'DEPENDENCY',
    DATA_FLOW_READ_ACCESS: 'DATA_FLOW_READ_ACCESS',
    DATA_FLOW_WRITE_ACCESS: 'DATA_FLOW_WRITE_ACCESS'
} as const;

export type CodeViewerLinkLinkTypeEnum = typeof CodeViewerLinkLinkTypeEnum[keyof typeof CodeViewerLinkLinkTypeEnum];
export const CodeViewerLinkLinkTargetTypeEnum = {
    LOCAL: 'LOCAL',
    EXTERNAL: 'EXTERNAL'
} as const;

export type CodeViewerLinkLinkTargetTypeEnum = typeof CodeViewerLinkLinkTargetTypeEnum[keyof typeof CodeViewerLinkLinkTargetTypeEnum];

/**
 * 
 * @export
 * @interface CodeViewerLinkModel
 */
export interface CodeViewerLinkModel {
    /**
     * 
     * @type {Array<CodeViewerLink>}
     * @memberof CodeViewerLinkModel
     */
    'links'?: Array<CodeViewerLink>;
}
/**
 * 
 * @export
 * @interface CodeViewerRange
 */
export interface CodeViewerRange {
    /**
     * 
     * @type {number}
     * @memberof CodeViewerRange
     */
    'startLineNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CodeViewerRange
     */
    'startColumn'?: number;
    /**
     * 
     * @type {number}
     * @memberof CodeViewerRange
     */
    'endLineNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof CodeViewerRange
     */
    'endColumn'?: number;
}
/**
 * 
 * @export
 * @interface Column
 */
export interface Column {
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'dataType'?: string;
    /**
     * 
     * @type {string}
     * @memberof Column
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {number}
     * @memberof Column
     */
    'size'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Column
     */
    'autoIncremented'?: boolean;
}
/**
 * 
 * @export
 * @interface ColumnReference
 */
export interface ColumnReference {
    /**
     * 
     * @type {string}
     * @memberof ColumnReference
     */
    'foreignKey'?: string;
    /**
     * 
     * @type {string}
     * @memberof ColumnReference
     */
    'primaryKey'?: string;
}
/**
 * 
 * @export
 * @interface ContainedIn
 */
export interface ContainedIn {
    /**
     * 
     * @type {string}
     * @memberof ContainedIn
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainedIn
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainedIn
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainedIn
     */
    'pathPattern'?: string;
    /**
     * 
     * @type {Candidate}
     * @memberof ContainedIn
     */
    'containedIn'?: Candidate;
}
/**
 * 
 * @export
 * @interface ControlFlowEdge
 */
export interface ControlFlowEdge {
    /**
     * 
     * @type {string}
     * @memberof ControlFlowEdge
     */
    'fromId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowEdge
     */
    'toId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowEdge
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface ControlFlowGraph
 */
export interface ControlFlowGraph {
    /**
     * 
     * @type {Array<ControlFlowNode>}
     * @memberof ControlFlowGraph
     */
    'nodes'?: Array<ControlFlowNode>;
    /**
     * 
     * @type {Array<ControlFlowEdge>}
     * @memberof ControlFlowGraph
     */
    'edges'?: Array<ControlFlowEdge>;
    /**
     * 
     * @type {Array<AnnotationPojo>}
     * @memberof ControlFlowGraph
     */
    'annotations'?: Array<AnnotationPojo>;
    /**
     * 
     * @type {Array<ModuleLightweightPojo>}
     * @memberof ControlFlowGraph
     */
    'relatedModules'?: Array<ModuleLightweightPojo>;
}
/**
 * 
 * @export
 * @interface ControlFlowNode
 */
export interface ControlFlowNode {
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'module'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'entity'?: ControlFlowNodeEntityEnum;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'parent'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControlFlowNode
     */
    'label'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ControlFlowNode
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof ControlFlowNode
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControlFlowNode
     */
    'length'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ControlFlowNode
     */
    'superTypes'?: Set<string>;
}

export const ControlFlowNodeEntityEnum = {
    AST_NODE: 'AST_NODE',
    ANNOTATION: 'ANNOTATION',
    TERMINAL: 'TERMINAL'
} as const;

export type ControlFlowNodeEntityEnum = typeof ControlFlowNodeEntityEnum[keyof typeof ControlFlowNodeEntityEnum];

/**
 * 
 * @export
 * @interface CustomPropertyMetadata
 */
export interface CustomPropertyMetadata {
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'dataType'?: CustomPropertyMetadataDataTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'dataSource'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'fieldType'?: CustomPropertyMetadataFieldTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'customCategory'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof CustomPropertyMetadata
     */
    'pluginVisible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof CustomPropertyMetadata
     */
    'mandatory'?: boolean;
    /**
     * 
     * @type {object}
     * @memberof CustomPropertyMetadata
     */
    'min'?: object;
    /**
     * 
     * @type {object}
     * @memberof CustomPropertyMetadata
     */
    'max'?: object;
    /**
     * 
     * @type {boolean}
     * @memberof CustomPropertyMetadata
     */
    'readOnly'?: boolean;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof CustomPropertyMetadata
     */
    'showWhen'?: { [key: string]: object; };
    /**
     * 
     * @type {Array<string>}
     * @memberof CustomPropertyMetadata
     */
    'customViewNames'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof CustomPropertyMetadata
     */
    'customViewIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'validationRegex'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'validationErrorMessage'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomPropertyMetadata
     */
    'autoCompletionKey'?: string;
}

export const CustomPropertyMetadataDataTypeEnum = {
    BOOLEAN: 'BOOLEAN',
    INTEGER: 'INTEGER',
    SHORT: 'SHORT',
    LONG: 'LONG',
    FLOAT: 'FLOAT',
    DOUBLE: 'DOUBLE',
    DATETIME: 'DATETIME',
    STRING: 'STRING',
    REFERENCE: 'REFERENCE',
    EMBEDDEDLIST: 'EMBEDDEDLIST',
    LINKLIST: 'LINKLIST',
    EMBEDDEDMAP: 'EMBEDDEDMAP',
    BYTE: 'BYTE',
    DATE: 'DATE',
    DECIMAL: 'DECIMAL'
} as const;

export type CustomPropertyMetadataDataTypeEnum = typeof CustomPropertyMetadataDataTypeEnum[keyof typeof CustomPropertyMetadataDataTypeEnum];
export const CustomPropertyMetadataFieldTypeEnum = {
    DEFAULT: 'DEFAULT',
    TAG: 'TAG',
    SELECT: 'SELECT',
    NUMBER: 'NUMBER'
} as const;

export type CustomPropertyMetadataFieldTypeEnum = typeof CustomPropertyMetadataFieldTypeEnum[keyof typeof CustomPropertyMetadataFieldTypeEnum];

/**
 * 
 * @export
 * @interface CustomTableExtensionDescription
 */
export interface CustomTableExtensionDescription {
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'identifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'queryName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'rootTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof CustomTableExtensionDescription
     */
    'usage'?: string;
}
/**
 * 
 * @export
 * @interface DataDictionaryPojo
 */
export interface DataDictionaryPojo {
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof DataDictionaryPojo
     */
    'moduleEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'module'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'moduleId'?: number;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof DataDictionaryPojo
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'format'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof DataDictionaryPojo
     */
    'scopes'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'updatedByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'picClause'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'definedLocation'?: DataDictionaryPojoDefinedLocationEnum;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'state'?: DataDictionaryPojoStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojo
     */
    'isBusiness'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'fieldTransformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'sourceInput'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'targetOutput'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojo
     */
    'isReferenced'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'usage'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojo
     */
    'isCandidate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'fieldLevel'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'parentGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'groupPath'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'indentation'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'initialValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'translatedFieldValue'?: string;
    /**
     * 
     * @type {Array<EntityId>}
     * @memberof DataDictionaryPojo
     */
    'annotations'?: Array<EntityId>;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof DataDictionaryPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'createdByUserName'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'updatedByUserName'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojo
     */
    'dataElementName'?: string;
}

export const DataDictionaryPojoDefinedLocationEnum = {
    Program: 'Program',
    Copybook: 'Copybook',
    SubProgram: 'SubProgram',
    SubRoutine: 'SubRoutine',
    Procedure: 'Procedure',
    Package: 'Package',
    Begin: 'Begin'
} as const;

export type DataDictionaryPojoDefinedLocationEnum = typeof DataDictionaryPojoDefinedLocationEnum[keyof typeof DataDictionaryPojoDefinedLocationEnum];
export const DataDictionaryPojoStateEnum = {
    CANDIDATE: 'CANDIDATE',
    IN_ANALYSIS: 'IN_ANALYSIS',
    FOR_REVIEW: 'FOR_REVIEW',
    REJECTED: 'REJECTED',
    APPROVED: 'APPROVED',
    INVALID: 'INVALID'
} as const;

export type DataDictionaryPojoStateEnum = typeof DataDictionaryPojoStateEnum[keyof typeof DataDictionaryPojoStateEnum];

/**
 * 
 * @export
 * @interface DataDictionaryPojoPrototype
 */
export interface DataDictionaryPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof DataDictionaryPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof DataDictionaryPojoPrototype
     */
    'module'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof DataDictionaryPojoPrototype
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'format'?: string;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof DataDictionaryPojoPrototype
     */
    'scopes'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojoPrototype
     */
    'length'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'updatedByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'picClause'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'definedLocation'?: DataDictionaryPojoPrototypeDefinedLocationEnum;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'state'?: DataDictionaryPojoPrototypeStateEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojoPrototype
     */
    'isBusiness'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'fieldTransformation'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'sourceInput'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'targetOutput'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojoPrototype
     */
    'isReferenced'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'usage'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof DataDictionaryPojoPrototype
     */
    'isCandidate'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojoPrototype
     */
    'fieldLevel'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'parentGroup'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'groupPath'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataDictionaryPojoPrototype
     */
    'indentation'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'initialValue'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'translatedFieldValue'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof DataDictionaryPojoPrototype
     */
    'id'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof DataDictionaryPojoPrototype
     */
    'dataElementName'?: string;
}

export const DataDictionaryPojoPrototypeDefinedLocationEnum = {
    Program: 'Program',
    Copybook: 'Copybook',
    SubProgram: 'SubProgram',
    SubRoutine: 'SubRoutine',
    Procedure: 'Procedure',
    Package: 'Package',
    Begin: 'Begin'
} as const;

export type DataDictionaryPojoPrototypeDefinedLocationEnum = typeof DataDictionaryPojoPrototypeDefinedLocationEnum[keyof typeof DataDictionaryPojoPrototypeDefinedLocationEnum];
export const DataDictionaryPojoPrototypeStateEnum = {
    CANDIDATE: 'CANDIDATE',
    IN_ANALYSIS: 'IN_ANALYSIS',
    FOR_REVIEW: 'FOR_REVIEW',
    REJECTED: 'REJECTED',
    APPROVED: 'APPROVED',
    INVALID: 'INVALID'
} as const;

export type DataDictionaryPojoPrototypeStateEnum = typeof DataDictionaryPojoPrototypeStateEnum[keyof typeof DataDictionaryPojoPrototypeStateEnum];

/**
 * 
 * @export
 * @interface DataFieldFormat
 */
export interface DataFieldFormat {
    /**
     * 
     * @type {string}
     * @memberof DataFieldFormat
     */
    'fieldName'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof DataFieldFormat
     */
    'moduleId'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof DataFieldFormat
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof DataFieldFormat
     */
    'languageType'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataFieldFormat
     */
    'byteLength'?: number;
    /**
     * 
     * @type {number}
     * @memberof DataFieldFormat
     */
    'dataDictionaryEntryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataFieldFormat
     */
    'usage'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataFieldFormat
     */
    'definedLocation'?: DataFieldFormatDefinedLocationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof DataFieldFormat
     */
    'group'?: boolean;
}

export const DataFieldFormatDefinedLocationEnum = {
    Program: 'Program',
    Copybook: 'Copybook',
    SubProgram: 'SubProgram',
    SubRoutine: 'SubRoutine',
    Procedure: 'Procedure',
    Package: 'Package',
    Begin: 'Begin'
} as const;

export type DataFieldFormatDefinedLocationEnum = typeof DataFieldFormatDefinedLocationEnum[keyof typeof DataFieldFormatDefinedLocationEnum];

/**
 * 
 * @export
 * @interface DataFlowError
 */
export interface DataFlowError {
    /**
     * 
     * @type {string}
     * @memberof DataFlowError
     */
    'severity'?: DataFlowErrorSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof DataFlowError
     */
    'text'?: string;
}

export const DataFlowErrorSeverityEnum = {
    WARNING: 'WARNING',
    ERROR: 'ERROR'
} as const;

export type DataFlowErrorSeverityEnum = typeof DataFlowErrorSeverityEnum[keyof typeof DataFlowErrorSeverityEnum];

/**
 * 
 * @export
 * @interface DataFlowGraph
 */
export interface DataFlowGraph {
    /**
     * 
     * @type {Array<DataFlowGraphNodesInner>}
     * @memberof DataFlowGraph
     */
    'nodes'?: Array<DataFlowGraphNodesInner>;
}
/**
 * 
 * @export
 * @interface DataFlowGraphNode
 */
export interface DataFlowGraphNode {
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'type'?: DataFlowGraphNodeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'name'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof DataFlowGraphNode
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {Set<string>}
     * @memberof DataFlowGraphNode
     */
    'incomings'?: Set<string>;
    /**
     * 
     * @type {Set<string>}
     * @memberof DataFlowGraphNode
     */
    'outgoings'?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'direction'?: DataFlowGraphNodeDirectionEnum;
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'parentModule'?: string;
    /**
     * 
     * @type {Set<string>}
     * @memberof DataFlowGraphNode
     */
    'children'?: Set<string>;
    /**
     * 
     * @type {string}
     * @memberof DataFlowGraphNode
     */
    'statementLabel'?: string;
    /**
     * 
     * @type {SourceLocation}
     * @memberof DataFlowGraphNode
     */
    'sourceLocation'?: SourceLocation;
    /**
     * 
     * @type {Set<DataFlowError>}
     * @memberof DataFlowGraphNode
     */
    'errors'?: Set<DataFlowError>;
}

export const DataFlowGraphNodeTypeEnum = {
    MODULE: 'MODULE',
    FIELD: 'FIELD',
    STATEMENT: 'STATEMENT',
    DATA_INTERFACE: 'DATA_INTERFACE'
} as const;

export type DataFlowGraphNodeTypeEnum = typeof DataFlowGraphNodeTypeEnum[keyof typeof DataFlowGraphNodeTypeEnum];
export const DataFlowGraphNodeDirectionEnum = {
    BOTH: 'BOTH',
    INCOMING: 'INCOMING',
    OUTGOING: 'OUTGOING'
} as const;

export type DataFlowGraphNodeDirectionEnum = typeof DataFlowGraphNodeDirectionEnum[keyof typeof DataFlowGraphNodeDirectionEnum];

/**
 * @type DataFlowGraphNodesInner
 * @export
 */
export type DataFlowGraphNodesInner = DataInterfaceNode | FieldNode | ModuleNode | StatementNode;

/**
 * 
 * @export
 * @interface DataInterfaceNode
 */
export interface DataInterfaceNode extends DataFlowGraphNode {
}


/**
 * 
 * @export
 * @interface DependencyGraph
 */
export interface DependencyGraph {
    /**
     * 
     * @type {Array<ModulePojo>}
     * @memberof DependencyGraph
     */
    'modules'?: Array<ModulePojo>;
    /**
     * 
     * @type {Array<ModuleRelationshipPojo>}
     * @memberof DependencyGraph
     */
    'references'?: Array<ModuleRelationshipPojo>;
    /**
     * 
     * @type {Array<number>}
     * @memberof DependencyGraph
     */
    'rootModuleIds'?: Array<number>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DependencyGraph
     */
    'moduleTypes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof DependencyGraph
     */
    'relationshipTypes'?: Array<string>;
}
/**
 * @type EntityId
 * @export
 */
export type EntityId = number | string;

/**
 * 
 * @export
 * @interface Environment
 */
export interface Environment {
    /**
     * 
     * @type {Array<string>}
     * @memberof Environment
     */
    'activeProfiles'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof Environment
     */
    'defaultProfiles'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ErrorMarker
 */
export interface ErrorMarker {
    /**
     * 
     * @type {string}
     * @memberof ErrorMarker
     */
    'moduleId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ErrorMarker
     */
    'severity'?: ErrorMarkerSeverityEnum;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ErrorMarker
     */
    'moduleLocation'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ErrorMarker
     */
    'key'?: ErrorMarkerKeyEnum;
    /**
     * 
     * @type {string}
     * @memberof ErrorMarker
     */
    'cause'?: string;
    /**
     * 
     * @type {ErrorMarker}
     * @memberof ErrorMarker
     */
    'fromError'?: ErrorMarker;
}

export const ErrorMarkerSeverityEnum = {
    WARNING: 'WARNING',
    ERROR: 'ERROR'
} as const;

export type ErrorMarkerSeverityEnum = typeof ErrorMarkerSeverityEnum[keyof typeof ErrorMarkerSeverityEnum];
export const ErrorMarkerKeyEnum = {
    EMPTY_FILE: 'EMPTY_FILE',
    MODULE_ABORT: 'MODULE_ABORT',
    PARSE_ERROR: 'PARSE_ERROR',
    PARSE_TIMEOUT: 'PARSE_TIMEOUT',
    METRICS_CALCULATION_ERROR: 'METRICS_CALCULATION_ERROR',
    UNDISCOVERED_DEPENDENCY: 'UNDISCOVERED_DEPENDENCY',
    DEPENDENCY_RESOLUTION_ERROR: 'DEPENDENCY_RESOLUTION_ERROR',
    INVALID_SEARCH_ORDER_CONFIGURATION: 'INVALID_SEARCH_ORDER_CONFIGURATION'
} as const;

export type ErrorMarkerKeyEnum = typeof ErrorMarkerKeyEnum[keyof typeof ErrorMarkerKeyEnum];

/**
 * 
 * @export
 * @interface ExportFormatDescription
 */
export interface ExportFormatDescription {
    /**
     * 
     * @type {string}
     * @memberof ExportFormatDescription
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFormatDescription
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExportFormatDescription
     */
    'extensionType'?: ExportFormatDescriptionExtensionTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ExportFormatDescription
     */
    'requiredRole'?: ExportFormatDescriptionRequiredRoleEnum;
    /**
     * 
     * @type {string}
     * @memberof ExportFormatDescription
     */
    'requiredNature'?: ExportFormatDescriptionRequiredNatureEnum;
    /**
     * 
     * @type {Array<ParameterDescription>}
     * @memberof ExportFormatDescription
     */
    'parameterDescriptions'?: Array<ParameterDescription>;
    /**
     * 
     * @type {ShowOnExportPage}
     * @memberof ExportFormatDescription
     */
    'showOnExportPage'?: ShowOnExportPage;
    /**
     * 
     * @type {UploadDescription}
     * @memberof ExportFormatDescription
     */
    'uploadDescription'?: UploadDescription;
}

export const ExportFormatDescriptionExtensionTypeEnum = {
    EXPORT_EXTENSION: 'EXPORT_EXTENSION',
    JOB_EXTENSION: 'JOB_EXTENSION'
} as const;

export type ExportFormatDescriptionExtensionTypeEnum = typeof ExportFormatDescriptionExtensionTypeEnum[keyof typeof ExportFormatDescriptionExtensionTypeEnum];
export const ExportFormatDescriptionRequiredRoleEnum = {
    VIEWER: 'VIEWER',
    EDITOR: 'EDITOR',
    MANAGER: 'MANAGER',
    CLIENT_ADMIN: 'CLIENT_ADMIN',
    ADMIN: 'ADMIN'
} as const;

export type ExportFormatDescriptionRequiredRoleEnum = typeof ExportFormatDescriptionRequiredRoleEnum[keyof typeof ExportFormatDescriptionRequiredRoleEnum];
export const ExportFormatDescriptionRequiredNatureEnum = {
    DISCOVERY_LIGHT: 'DISCOVERY_LIGHT',
    DISCOVERY: 'DISCOVERY',
    MINING: 'MINING'
} as const;

export type ExportFormatDescriptionRequiredNatureEnum = typeof ExportFormatDescriptionRequiredNatureEnum[keyof typeof ExportFormatDescriptionRequiredNatureEnum];

/**
 * 
 * @export
 * @interface Feature
 */
export interface Feature {
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'recordId'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof Feature
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'id'?: FeatureIdEnum;
    /**
     * 
     * @type {string}
     * @memberof Feature
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Feature
     */
    'enabled'?: boolean;
}

export const FeatureIdEnum = {
    ECLIPSE_DEEP_LINK: 'ECLIPSE_DEEP_LINK',
    INCREMENTAL_SCAN: 'INCREMENTAL_SCAN',
    PL1_EXPERIMENTAL: 'PL1_EXPERIMENTAL',
    JAVA_COLLECT_METHOD_CALLS: 'JAVA_COLLECT_METHOD_CALLS',
    CONFLUENCE_EXPORT: 'CONFLUENCE_EXPORT',
    COLLECT_PARSER_ERRORS: 'COLLECT_PARSER_ERRORS',
    DEPENDENCY_GRAPH_EXPLORE: 'DEPENDENCY_GRAPH_EXPLORE',
    LEGACY_WEB_VIEWS_IN_ECLIPSE: 'LEGACY_WEB_VIEWS_IN_ECLIPSE',
    GENERATIVE_AI_TRANSLATIONS: 'GENERATIVE_AI_TRANSLATIONS',
    CODE_VIEWER_HYPERLINKING: 'CODE_VIEWER_HYPERLINKING',
    CODE_VIEWER_ASSEMBLED_VIEW: 'CODE_VIEWER_ASSEMBLED_VIEW',
    CONSIDER_DATA_FLOW: 'CONSIDER_DATA_FLOW',
    ORDERED_ANNOTATION_RULE_CSV_EXPORTER: 'ORDERED_ANNOTATION_RULE_CSV_EXPORTER',
    FUNCTIONAL_BLOCK_UI_PRODUCT_VISION: 'FUNCTIONAL_BLOCK_UI_PRODUCT_VISION',
    REACHABILITY_BLOCK_UI: 'REACHABILITY_BLOCK_UI',
    REACHABILITY_BLOCK_UI_SALES: 'REACHABILITY_BLOCK_UI_SALES',
    ANNOTATION_CSV_IMPORT: 'ANNOTATION_CSV_IMPORT',
    DISABLE_ANNOTATION_DATA_DICTIONARY_MANUAL_LINKING: 'DISABLE_ANNOTATION_DATA_DICTIONARY_MANUAL_LINKING',
    IDENTIFY_DDE_ONLY: 'IDENTIFY_DDE_ONLY',
    SEMANTIC_SEARCH: 'SEMANTIC_SEARCH',
    GENERATE_FUNCTIONAL_BLOCK_AS_PER_MODULE_STRUCTURE: 'GENERATE_FUNCTIONAL_BLOCK_AS_PER_MODULE_STRUCTURE',
    CREATE_MODULE_FROM_SCHEDULER_INFO: 'CREATE_MODULE_FROM_SCHEDULER_INFO',
    LINK_MODULE_USING_SCHEDULER_INFO: 'LINK_MODULE_USING_SCHEDULER_INFO',
    DETAILED_TAXONOMY_GRAPHML_EXPORT: 'DETAILED_TAXONOMY_GRAPHML_EXPORT'
} as const;

export type FeatureIdEnum = typeof FeatureIdEnum[keyof typeof FeatureIdEnum];

/**
 * 
 * @export
 * @interface FieldInfoPojo
 */
export interface FieldInfoPojo {
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'id'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof FieldInfoPojo
     */
    'moduleEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'module'?: string;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoPojo
     */
    'moduleId'?: number;
    /**
     * 
     * @type {number}
     * @memberof FieldInfoPojo
     */
    'ordinal'?: number;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'usage'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FieldInfoPojo
     */
    'modifiers'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'reference'?: string;
    /**
     * 
     * @type {string}
     * @memberof FieldInfoPojo
     */
    'comment'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FieldInfoPojo
     */
    'properties'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface FieldNode
 */
export interface FieldNode extends DataFlowGraphNode {
}


/**
 * 
 * @export
 * @interface ForeignKey
 */
export interface ForeignKey {
    /**
     * 
     * @type {string}
     * @memberof ForeignKey
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ColumnReference>}
     * @memberof ForeignKey
     */
    'columnReferences'?: Array<ColumnReference>;
}
/**
 * 
 * @export
 * @interface FunctionalBlockMergeRequest
 */
export interface FunctionalBlockMergeRequest {
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockMergeRequest
     */
    'commonParent'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockMergeRequest
     */
    'mergeParent'?: string;
    /**
     * 
     * @type {FunctionalBlockPojoPrototype}
     * @memberof FunctionalBlockMergeRequest
     */
    'mergeParentPrototype'?: FunctionalBlockPojoPrototype;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionalBlockMergeRequest
     */
    'mergeChildren'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FunctionalBlockMergeRequest
     */
    'removeEmptyBlocks'?: boolean;
}
/**
 * 
 * @export
 * @interface FunctionalBlockPojo
 */
export interface FunctionalBlockPojo {
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof FunctionalBlockPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {EntityId}
     * @memberof FunctionalBlockPojo
     */
    'projectId'?: EntityId;
    /**
     * 
     * @type {Array<ModulePart>}
     * @memberof FunctionalBlockPojo
     */
    'moduleParts'?: Array<ModulePart>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionalBlockPojo
     */
    'parents'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionalBlockPojo
     */
    'children'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojo
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FunctionalBlockPojo
     */
    'flags'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojo
     */
    'updated'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof FunctionalBlockPojo
     */
    'project'?: EntityId;
}
/**
 * 
 * @export
 * @interface FunctionalBlockPojoPrototype
 */
export interface FunctionalBlockPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FunctionalBlockPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {EntityId}
     * @memberof FunctionalBlockPojoPrototype
     */
    'project'?: EntityId;
    /**
     * 
     * @type {Array<ModulePart>}
     * @memberof FunctionalBlockPojoPrototype
     */
    'moduleParts'?: Array<ModulePart>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FunctionalBlockPojoPrototype
     */
    'children'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FunctionalBlockPojoPrototype
     */
    'description'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof FunctionalBlockPojoPrototype
     */
    'flags'?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface GenAiAnnotationRequest
 */
export interface GenAiAnnotationRequest {
    /**
     * 
     * @type {AnnotationPojoPrototype}
     * @memberof GenAiAnnotationRequest
     */
    'annotation'?: AnnotationPojoPrototype;
    /**
     * 
     * @type {GenAiRequestOptions}
     * @memberof GenAiAnnotationRequest
     */
    'options'?: GenAiRequestOptions;
}
/**
 * 
 * @export
 * @interface GenAiRequestOptions
 */
export interface GenAiRequestOptions {
    /**
     * 
     * @type {string}
     * @memberof GenAiRequestOptions
     */
    'context'?: string;
}
/**
 * 
 * @export
 * @interface HotSpot
 */
export interface HotSpot {
    /**
     * 
     * @type {ModulePojo}
     * @memberof HotSpot
     */
    'module'?: ModulePojo;
    /**
     * 
     * @type {number}
     * @memberof HotSpot
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface Inclusion
 */
export interface Inclusion {
    /**
     * 
     * @type {ModuleLightweightPojo}
     * @memberof Inclusion
     */
    'originModule'?: ModuleLightweightPojo;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof Inclusion
     */
    'assembledLocation'?: ModuleLocation;
    /**
     * 
     * @type {CodeViewerRange}
     * @memberof Inclusion
     */
    'assembledRange'?: CodeViewerRange;
}
/**
 * 
 * @export
 * @interface Index
 */
export interface Index {
    /**
     * 
     * @type {string}
     * @memberof Index
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Index
     */
    'columns'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Index
     */
    'indexType'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Index
     */
    'unique'?: boolean;
}
/**
 * 
 * @export
 * @interface JobInformation
 */
export interface JobInformation {
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'jobId'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'jobName'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'jobDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'stepDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'submitTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'scheduledStartTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'startTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'finishTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'eta'?: string;
    /**
     * 
     * @type {string}
     * @memberof JobInformation
     */
    'status'?: JobInformationStatusEnum;
    /**
     * 
     * @type {ResultStatus}
     * @memberof JobInformation
     */
    'resultStatus'?: ResultStatus;
    /**
     * 
     * @type {number}
     * @memberof JobInformation
     */
    'totalWorkUnits'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobInformation
     */
    'processedWorkUnits'?: number;
    /**
     * 
     * @type {Array<Message>}
     * @memberof JobInformation
     */
    'messages'?: Array<Message>;
    /**
     * 
     * @type {number}
     * @memberof JobInformation
     */
    'projectId'?: number;
    /**
     * 
     * @type {number}
     * @memberof JobInformation
     */
    'moduleId'?: number;
}

export const JobInformationStatusEnum = {
    UNKNOWN: 'UNKNOWN',
    SCHEDULED: 'SCHEDULED',
    RUNNING: 'RUNNING',
    SUCCESS: 'SUCCESS',
    FAILURE: 'FAILURE',
    TIMEOUT: 'TIMEOUT',
    CANCEL_REQUESTED: 'CANCEL_REQUESTED',
    CANCELED: 'CANCELED'
} as const;

export type JobInformationStatusEnum = typeof JobInformationStatusEnum[keyof typeof JobInformationStatusEnum];

/**
 * 
 * @export
 * @interface LegacyDatabase
 */
export interface LegacyDatabase {
    /**
     * 
     * @type {string}
     * @memberof LegacyDatabase
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Schema>}
     * @memberof LegacyDatabase
     */
    'schemes'?: Array<Schema>;
    /**
     * 
     * @type {string}
     * @memberof LegacyDatabase
     */
    'crawlDate'?: string;
}
/**
 * 
 * @export
 * @interface LicenseExpirationInfo
 */
export interface LicenseExpirationInfo {
    /**
     * 
     * @type {string}
     * @memberof LicenseExpirationInfo
     */
    'expiryDate'?: string;
    /**
     * 
     * @type {number}
     * @memberof LicenseExpirationInfo
     */
    'days'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof LicenseExpirationInfo
     */
    'neverExpires'?: boolean;
}
/**
 * 
 * @export
 * @interface LinkedModule
 */
export interface LinkedModule {
    /**
     * 
     * @type {string}
     * @memberof LinkedModule
     */
    'modulePath'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof LinkedModule
     */
    'toLocation'?: ModuleLocation;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof LinkedModule
     */
    'fromLocation'?: ModuleLocation;
}
/**
 * 
 * @export
 * @interface Member
 */
export interface Member {
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Member
     */
    'email'?: string;
    /**
     * 
     * @type {Array<ProjectRole>}
     * @memberof Member
     */
    'projectRoles'?: Array<ProjectRole>;
}
/**
 * 
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'severity'?: MessageSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof Message
     */
    'text'?: string;
    /**
     * 
     * @type {number}
     * @memberof Message
     */
    'ordinal'?: number;
}

export const MessageSeverityEnum = {
    INFO: 'INFO',
    WARNING: 'WARNING',
    ERROR: 'ERROR'
} as const;

export type MessageSeverityEnum = typeof MessageSeverityEnum[keyof typeof MessageSeverityEnum];

/**
 * 
 * @export
 * @interface MiningDataPointDefinition
 */
export interface MiningDataPointDefinition {
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'parentTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'scalarType'?: MiningDataPointDefinitionScalarTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'referenceTypeName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinition
     */
    'isArray'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinition
     */
    'isNullable'?: boolean;
    /**
     * 
     * @type {AliasDefinition}
     * @memberof MiningDataPointDefinition
     */
    'aliasDefinition'?: AliasDefinition;
    /**
     * 
     * @type {Array<number>}
     * @memberof MiningDataPointDefinition
     */
    'projectIds'?: Array<number>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MiningDataPointDefinition
     */
    'providedBy'?: Set<string>;
    /**
     * 
     * @type {Array<MiningDataPointDefinition>}
     * @memberof MiningDataPointDefinition
     */
    'parameters'?: Array<MiningDataPointDefinition>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MiningDataPointDefinition
     */
    'usages'?: Set<string>;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof MiningDataPointDefinition
     */
    'usageAttributes'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinition
     */
    'array'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinition
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinition
     */
    'alias'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinition
     */
    'nullable'?: boolean;
    /**
     * 
     * @type {AliasDefinition}
     * @memberof MiningDataPointDefinition
     */
    'aliasFor'?: AliasDefinition;
}

export const MiningDataPointDefinitionScalarTypeEnum = {
    Int: 'Int',
    Long: 'Long',
    Float: 'Float',
    String: 'String',
    Boolean: 'Boolean',
    DateTime: 'DateTime',
    Timestamp: 'Timestamp',
    UUID: 'UUID',
    JSON: 'JSON',
    EntityId: 'EntityId',
    empty: ''
} as const;

export type MiningDataPointDefinitionScalarTypeEnum = typeof MiningDataPointDefinitionScalarTypeEnum[keyof typeof MiningDataPointDefinitionScalarTypeEnum];

/**
 * 
 * @export
 * @interface MiningDataPointDefinitionWithPath
 */
export interface MiningDataPointDefinitionWithPath {
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'parentTypeName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'scalarType'?: MiningDataPointDefinitionWithPathScalarTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'referenceTypeName'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'isArray'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'isNullable'?: boolean;
    /**
     * 
     * @type {AliasDefinition}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'aliasFor'?: AliasDefinition;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'path'?: string;
    /**
     * 
     * @type {Array<number>}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'projectIds'?: Array<number>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'providedBy'?: Set<string>;
    /**
     * 
     * @type {Array<MiningDataPointDefinition>}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'parameters'?: Array<MiningDataPointDefinition>;
    /**
     * 
     * @type {Set<string>}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'usages'?: Set<string>;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'usageAttributes'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'displayName'?: string;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'array'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'alias'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof MiningDataPointDefinitionWithPath
     */
    'nullable'?: boolean;
}

export const MiningDataPointDefinitionWithPathScalarTypeEnum = {
    Int: 'Int',
    Long: 'Long',
    Float: 'Float',
    String: 'String',
    Boolean: 'Boolean',
    DateTime: 'DateTime',
    Timestamp: 'Timestamp',
    UUID: 'UUID',
    JSON: 'JSON',
    EntityId: 'EntityId',
    empty: ''
} as const;

export type MiningDataPointDefinitionWithPathScalarTypeEnum = typeof MiningDataPointDefinitionWithPathScalarTypeEnum[keyof typeof MiningDataPointDefinitionWithPathScalarTypeEnum];

/**
 * 
 * @export
 * @interface ModelAlgorithmOption
 */
export interface ModelAlgorithmOption {
    /**
     * 
     * @type {string}
     * @memberof ModelAlgorithmOption
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAlgorithmOption
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAlgorithmOption
     */
    'value'?: string;
}
/**
 * 
 * @export
 * @interface ModelBelongsToClusters
 */
export interface ModelBelongsToClusters {
    /**
     * 
     * @type {EntityId}
     * @memberof ModelBelongsToClusters
     */
    'moduleId'?: EntityId;
    /**
     * 
     * @type {Array<ModelDnaCluster>}
     * @memberof ModelBelongsToClusters
     */
    'clusters'?: Array<ModelDnaCluster>;
}
/**
 * 
 * @export
 * @interface ModelCluster
 */
export interface ModelCluster {
    /**
     * 
     * @type {number}
     * @memberof ModelCluster
     */
    'moduleCount'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCluster
     */
    'clusterDescription'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCluster
     */
    'clusterIndex'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCluster
     */
    'communityId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCluster
     */
    'clusterTitle'?: string;
}
/**
 * 
 * @export
 * @interface ModelClustering
 */
export interface ModelClustering {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ModelClustering
     */
    'algorithm'?: { [key: string]: string; };
    /**
     * 
     * @type {Array<ModelAlgorithmOption>}
     * @memberof ModelClustering
     */
    'options'?: Array<ModelAlgorithmOption>;
    /**
     * 
     * @type {Array<ModelCluster>}
     * @memberof ModelClustering
     */
    'clusters'?: Array<ModelCluster>;
}
/**
 * 
 * @export
 * @interface ModelDna
 */
export interface ModelDna {
    /**
     * 
     * @type {number}
     * @memberof ModelDna
     */
    'moduleCount'?: number;
    /**
     * 
     * @type {Array<ModelClustering>}
     * @memberof ModelDna
     */
    'clusterings'?: Array<ModelClustering>;
}
/**
 * 
 * @export
 * @interface ModelDnaAlgorithm
 */
export interface ModelDnaAlgorithm {
    /**
     * 
     * @type {string}
     * @memberof ModelDnaAlgorithm
     */
    'Sequencer'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelDnaAlgorithm
     */
    'Similarity'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelDnaAlgorithm
     */
    'Clustering'?: string;
}
/**
 * 
 * @export
 * @interface ModelDnaCluster
 */
export interface ModelDnaCluster {
    /**
     * 
     * @type {number}
     * @memberof ModelDnaCluster
     */
    'clusterIndex'?: number;
    /**
     * 
     * @type {ModelDnaAlgorithm}
     * @memberof ModelDnaCluster
     */
    'algorithm'?: ModelDnaAlgorithm;
}
/**
 * 
 * @export
 * @interface ModuleBasePojo
 */
export interface ModuleBasePojo {
    /**
     * 
     * @type {number}
     * @memberof ModuleBasePojo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'technology'?: ModuleBasePojoTechnologyEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'type'?: ModuleBasePojoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'identification'?: ModuleBasePojoIdentificationEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'linkHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'representation'?: ModuleBasePojoRepresentationEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModuleBasePojo
     */
    'info'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'uid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleBasePojo
     */
    'moduleType'?: ModuleBasePojoModuleTypeEnum;
}

export const ModuleBasePojoTechnologyEnum = {
    COBOL: 'COBOL',
    NATURAL: 'NATURAL',
    PL1: 'PL1',
    JCL: 'JCL',
    ASSEMBLER: 'ASSEMBLER',
    RESOURCE: 'RESOURCE',
    CSD: 'CSD',
    NONE: 'NONE',
    UNKNOWN: 'UNKNOWN',
    XML: 'XML',
    BINARY: 'BINARY',
    EASYTRIEVE: 'EASYTRIEVE',
    IMS: 'IMS',
    C: 'C',
    CPP: 'CPP',
    VMS: 'VMS',
    ORACLE: 'ORACLE',
    SQL: 'SQL',
    JAVA: 'JAVA',
    ECL: 'ECL',
    CICS: 'CICS',
    SCHEDULER: 'SCHEDULER',
    BASIC: 'BASIC',
    VB: 'VB',
    WINDOWS: 'WINDOWS',
    SERVICE: 'SERVICE',
    MARK4: 'MARK4'
} as const;

export type ModuleBasePojoTechnologyEnum = typeof ModuleBasePojoTechnologyEnum[keyof typeof ModuleBasePojoTechnologyEnum];
export const ModuleBasePojoTypeEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type ModuleBasePojoTypeEnum = typeof ModuleBasePojoTypeEnum[keyof typeof ModuleBasePojoTypeEnum];
export const ModuleBasePojoIdentificationEnum = {
    IDENTIFIED: 'IDENTIFIED',
    MISSING: 'MISSING'
} as const;

export type ModuleBasePojoIdentificationEnum = typeof ModuleBasePojoIdentificationEnum[keyof typeof ModuleBasePojoIdentificationEnum];
export const ModuleBasePojoRepresentationEnum = {
    PHYSICAL: 'PHYSICAL',
    VIRTUAL: 'VIRTUAL'
} as const;

export type ModuleBasePojoRepresentationEnum = typeof ModuleBasePojoRepresentationEnum[keyof typeof ModuleBasePojoRepresentationEnum];
export const ModuleBasePojoModuleTypeEnum = {
    UNKNOWN: 'UNKNOWN',
    UNKNOWN_UTILITY: 'UNKNOWN_UTILITY',
    UNKNOWN_PROGRAM: 'UNKNOWN_PROGRAM',
    ASSEMBLER_PROGRAM: 'ASSEMBLER_PROGRAM',
    ASSEMBLER_MACRO: 'ASSEMBLER_MACRO',
    BASIC_PROGRAM: 'BASIC_PROGRAM',
    BASIC_SUBROUTINE: 'BASIC_SUBROUTINE',
    BASIC_FUNCTION: 'BASIC_FUNCTION',
    BASIC_OBJECT: 'BASIC_OBJECT',
    BINARY: 'BINARY',
    C_PROGRAM: 'C_PROGRAM',
    C_HEADER: 'C_HEADER',
    C_FUNCTION: 'C_FUNCTION',
    CPP_PROGRAM: 'CPP_PROGRAM',
    CPP_HEADER: 'CPP_HEADER',
    COBOL_PROGRAM: 'COBOL_PROGRAM',
    COBOL_COPYBOOK: 'COBOL_COPYBOOK',
    COBOL_COPYLIB: 'COBOL_COPYLIB',
    COBOL_COPYPROC: 'COBOL_COPYPROC',
    CICS_BMS_MAPSET: 'CICS_BMS_MAPSET',
    CICS_BMS_MAP: 'CICS_BMS_MAP',
    CICS_TSQ: 'CICS_TSQ',
    CICS_TDQ: 'CICS_TDQ',
    CSD_LIST: 'CSD_LIST',
    CSD_TRANSACTION: 'CSD_TRANSACTION',
    CSD_PROGRAM: 'CSD_PROGRAM',
    CSD_FILE: 'CSD_FILE',
    CSD_EXTRACT: 'CSD_EXTRACT',
    EASYTRIEVE_PROGRAM: 'EASYTRIEVE_PROGRAM',
    EASYTRIEVE_INSTREAM: 'EASYTRIEVE_INSTREAM',
    EASYTRIEVE_MACRO_FILE: 'EASYTRIEVE_MACRO_FILE',
    ECL: 'ECL',
    ECL_JOB: 'ECL_JOB',
    IMS_DBD: 'IMS_DBD',
    IMS_DBD_COMPRTN: 'IMS_DBD_COMPRTN',
    IMS_DBD_DATASET: 'IMS_DBD_DATASET',
    IMS_DBD_SEGMENT: 'IMS_DBD_SEGMENT',
    IMS_HELPTXT: 'IMS_HELPTXT',
    IMS_HDAMPARM: 'IMS_HDAMPARM',
    IMS_PSB: 'IMS_PSB',
    IMS_PCB: 'IMS_PCB',
    IMS_ALT_PCB: 'IMS_ALT_PCB',
    IMS_SYSGEN_EXPORT: 'IMS_SYSGEN_EXPORT',
    IMS_SYSGEN_TRANSACTION: 'IMS_SYSGEN_TRANSACTION',
    IMS_SYSGEN_APPLICATION: 'IMS_SYSGEN_APPLICATION',
    IMS_MFS: 'IMS_MFS',
    IMS_MFS_MOD: 'IMS_MFS_MOD',
    IMS_MFS_MID: 'IMS_MFS_MID',
    IMS_TDFXTRCT: 'IMS_TDFXTRCT',
    JAVA_COMPILATION_UNIT: 'JAVA_COMPILATION_UNIT',
    JAVA_PACKAGE: 'JAVA_PACKAGE',
    JAVA_INTERFACE: 'JAVA_INTERFACE',
    JAVA_TYPE: 'JAVA_TYPE',
    JAVA_ENUM: 'JAVA_ENUM',
    JAVA_ANNOTATION: 'JAVA_ANNOTATION',
    JAVA_JSF: 'JAVA_JSF',
    JAVA_JSP: 'JAVA_JSP',
    JAVA_METHOD: 'JAVA_METHOD',
    JCL_JOB: 'JCL_JOB',
    JCL_PROC: 'JCL_PROC',
    JCL_INLINE_PROC: 'JCL_INLINE_PROC',
    JCL_EXEC: 'JCL_EXEC',
    JCL_EXEC_PGM: 'JCL_EXEC_PGM',
    JCL_PGM: 'JCL_PGM',
    JCL_CFG: 'JCL_CFG',
    JCL_INFO: 'JCL_INFO',
    JCL_CONTROLCARD: 'JCL_CONTROLCARD',
    JCL_INCLUDE: 'JCL_INCLUDE',
    NATURAL_PROGRAM: 'NATURAL_PROGRAM',
    NATURAL_PROGRAM_REPORTING: 'NATURAL_PROGRAM_REPORTING',
    NATURAL_SUBROUTINE: 'NATURAL_SUBROUTINE',
    NATURAL_SUBROUTINE_REPORTING: 'NATURAL_SUBROUTINE_REPORTING',
    NATURAL_SUBPROGRAM: 'NATURAL_SUBPROGRAM',
    NATURAL_SUBPROGRAM_REPORTING: 'NATURAL_SUBPROGRAM_REPORTING',
    NATURAL_COPYCODE: 'NATURAL_COPYCODE',
    NATURAL_COPYCODE_REPORTING: 'NATURAL_COPYCODE_REPORTING',
    NATURAL_CLASS: 'NATURAL_CLASS',
    NATURAL_CPM: 'NATURAL_CPM',
    NATURAL_ADAPTVIEW: 'NATURAL_ADAPTVIEW',
    NATURAL_FUNCTION: 'NATURAL_FUNCTION',
    NATURAL_FUNCTION_REPORTING: 'NATURAL_FUNCTION_REPORTING',
    NATURAL_HELP: 'NATURAL_HELP',
    NATURAL_HELP_REPORTING: 'NATURAL_HELP_REPORTING',
    NATURAL_ADAPTER: 'NATURAL_ADAPTER',
    NATURAL_MAP: 'NATURAL_MAP',
    NATURAL_MAP_REPORTING: 'NATURAL_MAP_REPORTING',
    NATURAL_DIALOG: 'NATURAL_DIALOG',
    NATURAL_DIALOG_PRIV_RES: 'NATURAL_DIALOG_PRIV_RES',
    NATURAL_GDA: 'NATURAL_GDA',
    NATURAL_IW_GDA: 'NATURAL_IW_GDA',
    NATURAL_PDA: 'NATURAL_PDA',
    NATURAL_IW_PDA: 'NATURAL_IW_PDA',
    NATURAL_LDA: 'NATURAL_LDA',
    NATURAL_IW_LDA: 'NATURAL_IW_LDA',
    NATURAL_DDM: 'NATURAL_DDM',
    NATURAL_TEXT: 'NATURAL_TEXT',
    NATURAL_ERROR_MESSAGE: 'NATURAL_ERROR_MESSAGE',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROC: 'SQLMOD_PROC',
    RDB_DATABASE: 'RDB_DATABASE',
    PL1_PROGRAM: 'PL1_PROGRAM',
    PL1_MAINPROGRAM: 'PL1_MAINPROGRAM',
    PL1_COPYBOOK: 'PL1_COPYBOOK',
    PL1_SUBROUTINE: 'PL1_SUBROUTINE',
    PL1_FUNCTION: 'PL1_FUNCTION',
    RESOURCE_FILE: 'RESOURCE_FILE',
    RESOURCE_TPFDF_DATASET: 'RESOURCE_TPFDF_DATASET',
    RESOURCE_LIB: 'RESOURCE_LIB',
    RESOURCE_LISTCAT: 'RESOURCE_LISTCAT',
    RESOURCE_VSAM_FILE: 'RESOURCE_VSAM_FILE',
    RESOURCE_GDG_FILE: 'RESOURCE_GDG_FILE',
    RESOURCE_RECORD: 'RESOURCE_RECORD',
    SQL_STORED_PROCEDURE: 'SQL_STORED_PROCEDURE',
    SQL_SCRIPT: 'SQL_SCRIPT',
    SQL_TABLE: 'SQL_TABLE',
    SQL_INDEX: 'SQL_INDEX',
    SQL_VIEW: 'SQL_VIEW',
    SQL_TRIGGER: 'SQL_TRIGGER',
    SQL_SCHEMA: 'SQL_SCHEMA',
    SQL_TEMPORARY_TABLE: 'SQL_TEMPORARY_TABLE',
    SQL_SYNONYM: 'SQL_SYNONYM',
    DCL: 'DCL',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    XML: 'XML',
    XML_XHTML: 'XML_XHTML',
    VB_MODULE: 'VB_MODULE',
    VB_CLASS: 'VB_CLASS',
    VB_FORM: 'VB_FORM',
    VB_CONTROL: 'VB_CONTROL',
    VB_PROJECT: 'VB_PROJECT',
    VB_WORKSPACE: 'VB_WORKSPACE',
    VB_ACTIVEX_DOCUMENT: 'VB_ACTIVEX_DOCUMENT',
    VB_DESIGNER_FILE: 'VB_DESIGNER_FILE',
    WINDOWS_DLL: 'WINDOWS_DLL',
    WINDOWS_OCX: 'WINDOWS_OCX',
    SERVICE: 'SERVICE',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD',
    MARK4_PROGRAM: 'MARK4_PROGRAM'
} as const;

export type ModuleBasePojoModuleTypeEnum = typeof ModuleBasePojoModuleTypeEnum[keyof typeof ModuleBasePojoModuleTypeEnum];

/**
 * 
 * @export
 * @interface ModuleLightweightPojo
 */
export interface ModuleLightweightPojo {
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModuleLightweightPojo
     */
    'id'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof ModuleLightweightPojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModuleLightweightPojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'technology'?: ModuleLightweightPojoTechnologyEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'type'?: ModuleLightweightPojoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'linkHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'representation'?: ModuleLightweightPojoRepresentationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleLightweightPojo
     */
    'identified'?: boolean;
    /**
     * 
     * @type {EntityId}
     * @memberof ModuleLightweightPojo
     */
    'parentEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'parent'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModuleLightweightPojo
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'parentPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'identification'?: ModuleLightweightPojoIdentificationEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModuleLightweightPojo
     */
    'info'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModuleLightweightPojo
     */
    'moduleType'?: ModuleLightweightPojoModuleTypeEnum;
}

export const ModuleLightweightPojoTechnologyEnum = {
    COBOL: 'COBOL',
    NATURAL: 'NATURAL',
    PL1: 'PL1',
    JCL: 'JCL',
    ASSEMBLER: 'ASSEMBLER',
    RESOURCE: 'RESOURCE',
    CSD: 'CSD',
    NONE: 'NONE',
    UNKNOWN: 'UNKNOWN',
    XML: 'XML',
    BINARY: 'BINARY',
    EASYTRIEVE: 'EASYTRIEVE',
    IMS: 'IMS',
    C: 'C',
    CPP: 'CPP',
    VMS: 'VMS',
    ORACLE: 'ORACLE',
    SQL: 'SQL',
    JAVA: 'JAVA',
    ECL: 'ECL',
    CICS: 'CICS',
    SCHEDULER: 'SCHEDULER',
    BASIC: 'BASIC',
    VB: 'VB',
    WINDOWS: 'WINDOWS',
    SERVICE: 'SERVICE',
    MARK4: 'MARK4'
} as const;

export type ModuleLightweightPojoTechnologyEnum = typeof ModuleLightweightPojoTechnologyEnum[keyof typeof ModuleLightweightPojoTechnologyEnum];
export const ModuleLightweightPojoTypeEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type ModuleLightweightPojoTypeEnum = typeof ModuleLightweightPojoTypeEnum[keyof typeof ModuleLightweightPojoTypeEnum];
export const ModuleLightweightPojoRepresentationEnum = {
    PHYSICAL: 'PHYSICAL',
    VIRTUAL: 'VIRTUAL'
} as const;

export type ModuleLightweightPojoRepresentationEnum = typeof ModuleLightweightPojoRepresentationEnum[keyof typeof ModuleLightweightPojoRepresentationEnum];
export const ModuleLightweightPojoIdentificationEnum = {
    IDENTIFIED: 'IDENTIFIED',
    MISSING: 'MISSING'
} as const;

export type ModuleLightweightPojoIdentificationEnum = typeof ModuleLightweightPojoIdentificationEnum[keyof typeof ModuleLightweightPojoIdentificationEnum];
export const ModuleLightweightPojoModuleTypeEnum = {
    UNKNOWN: 'UNKNOWN',
    UNKNOWN_UTILITY: 'UNKNOWN_UTILITY',
    UNKNOWN_PROGRAM: 'UNKNOWN_PROGRAM',
    ASSEMBLER_PROGRAM: 'ASSEMBLER_PROGRAM',
    ASSEMBLER_MACRO: 'ASSEMBLER_MACRO',
    BASIC_PROGRAM: 'BASIC_PROGRAM',
    BASIC_SUBROUTINE: 'BASIC_SUBROUTINE',
    BASIC_FUNCTION: 'BASIC_FUNCTION',
    BASIC_OBJECT: 'BASIC_OBJECT',
    BINARY: 'BINARY',
    C_PROGRAM: 'C_PROGRAM',
    C_HEADER: 'C_HEADER',
    C_FUNCTION: 'C_FUNCTION',
    CPP_PROGRAM: 'CPP_PROGRAM',
    CPP_HEADER: 'CPP_HEADER',
    COBOL_PROGRAM: 'COBOL_PROGRAM',
    COBOL_COPYBOOK: 'COBOL_COPYBOOK',
    COBOL_COPYLIB: 'COBOL_COPYLIB',
    COBOL_COPYPROC: 'COBOL_COPYPROC',
    CICS_BMS_MAPSET: 'CICS_BMS_MAPSET',
    CICS_BMS_MAP: 'CICS_BMS_MAP',
    CICS_TSQ: 'CICS_TSQ',
    CICS_TDQ: 'CICS_TDQ',
    CSD_LIST: 'CSD_LIST',
    CSD_TRANSACTION: 'CSD_TRANSACTION',
    CSD_PROGRAM: 'CSD_PROGRAM',
    CSD_FILE: 'CSD_FILE',
    CSD_EXTRACT: 'CSD_EXTRACT',
    EASYTRIEVE_PROGRAM: 'EASYTRIEVE_PROGRAM',
    EASYTRIEVE_INSTREAM: 'EASYTRIEVE_INSTREAM',
    EASYTRIEVE_MACRO_FILE: 'EASYTRIEVE_MACRO_FILE',
    ECL: 'ECL',
    ECL_JOB: 'ECL_JOB',
    IMS_DBD: 'IMS_DBD',
    IMS_DBD_COMPRTN: 'IMS_DBD_COMPRTN',
    IMS_DBD_DATASET: 'IMS_DBD_DATASET',
    IMS_DBD_SEGMENT: 'IMS_DBD_SEGMENT',
    IMS_HELPTXT: 'IMS_HELPTXT',
    IMS_HDAMPARM: 'IMS_HDAMPARM',
    IMS_PSB: 'IMS_PSB',
    IMS_PCB: 'IMS_PCB',
    IMS_ALT_PCB: 'IMS_ALT_PCB',
    IMS_SYSGEN_EXPORT: 'IMS_SYSGEN_EXPORT',
    IMS_SYSGEN_TRANSACTION: 'IMS_SYSGEN_TRANSACTION',
    IMS_SYSGEN_APPLICATION: 'IMS_SYSGEN_APPLICATION',
    IMS_MFS: 'IMS_MFS',
    IMS_MFS_MOD: 'IMS_MFS_MOD',
    IMS_MFS_MID: 'IMS_MFS_MID',
    IMS_TDFXTRCT: 'IMS_TDFXTRCT',
    JAVA_COMPILATION_UNIT: 'JAVA_COMPILATION_UNIT',
    JAVA_PACKAGE: 'JAVA_PACKAGE',
    JAVA_INTERFACE: 'JAVA_INTERFACE',
    JAVA_TYPE: 'JAVA_TYPE',
    JAVA_ENUM: 'JAVA_ENUM',
    JAVA_ANNOTATION: 'JAVA_ANNOTATION',
    JAVA_JSF: 'JAVA_JSF',
    JAVA_JSP: 'JAVA_JSP',
    JAVA_METHOD: 'JAVA_METHOD',
    JCL_JOB: 'JCL_JOB',
    JCL_PROC: 'JCL_PROC',
    JCL_INLINE_PROC: 'JCL_INLINE_PROC',
    JCL_EXEC: 'JCL_EXEC',
    JCL_EXEC_PGM: 'JCL_EXEC_PGM',
    JCL_PGM: 'JCL_PGM',
    JCL_CFG: 'JCL_CFG',
    JCL_INFO: 'JCL_INFO',
    JCL_CONTROLCARD: 'JCL_CONTROLCARD',
    JCL_INCLUDE: 'JCL_INCLUDE',
    NATURAL_PROGRAM: 'NATURAL_PROGRAM',
    NATURAL_PROGRAM_REPORTING: 'NATURAL_PROGRAM_REPORTING',
    NATURAL_SUBROUTINE: 'NATURAL_SUBROUTINE',
    NATURAL_SUBROUTINE_REPORTING: 'NATURAL_SUBROUTINE_REPORTING',
    NATURAL_SUBPROGRAM: 'NATURAL_SUBPROGRAM',
    NATURAL_SUBPROGRAM_REPORTING: 'NATURAL_SUBPROGRAM_REPORTING',
    NATURAL_COPYCODE: 'NATURAL_COPYCODE',
    NATURAL_COPYCODE_REPORTING: 'NATURAL_COPYCODE_REPORTING',
    NATURAL_CLASS: 'NATURAL_CLASS',
    NATURAL_CPM: 'NATURAL_CPM',
    NATURAL_ADAPTVIEW: 'NATURAL_ADAPTVIEW',
    NATURAL_FUNCTION: 'NATURAL_FUNCTION',
    NATURAL_FUNCTION_REPORTING: 'NATURAL_FUNCTION_REPORTING',
    NATURAL_HELP: 'NATURAL_HELP',
    NATURAL_HELP_REPORTING: 'NATURAL_HELP_REPORTING',
    NATURAL_ADAPTER: 'NATURAL_ADAPTER',
    NATURAL_MAP: 'NATURAL_MAP',
    NATURAL_MAP_REPORTING: 'NATURAL_MAP_REPORTING',
    NATURAL_DIALOG: 'NATURAL_DIALOG',
    NATURAL_DIALOG_PRIV_RES: 'NATURAL_DIALOG_PRIV_RES',
    NATURAL_GDA: 'NATURAL_GDA',
    NATURAL_IW_GDA: 'NATURAL_IW_GDA',
    NATURAL_PDA: 'NATURAL_PDA',
    NATURAL_IW_PDA: 'NATURAL_IW_PDA',
    NATURAL_LDA: 'NATURAL_LDA',
    NATURAL_IW_LDA: 'NATURAL_IW_LDA',
    NATURAL_DDM: 'NATURAL_DDM',
    NATURAL_TEXT: 'NATURAL_TEXT',
    NATURAL_ERROR_MESSAGE: 'NATURAL_ERROR_MESSAGE',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROC: 'SQLMOD_PROC',
    RDB_DATABASE: 'RDB_DATABASE',
    PL1_PROGRAM: 'PL1_PROGRAM',
    PL1_MAINPROGRAM: 'PL1_MAINPROGRAM',
    PL1_COPYBOOK: 'PL1_COPYBOOK',
    PL1_SUBROUTINE: 'PL1_SUBROUTINE',
    PL1_FUNCTION: 'PL1_FUNCTION',
    RESOURCE_FILE: 'RESOURCE_FILE',
    RESOURCE_TPFDF_DATASET: 'RESOURCE_TPFDF_DATASET',
    RESOURCE_LIB: 'RESOURCE_LIB',
    RESOURCE_LISTCAT: 'RESOURCE_LISTCAT',
    RESOURCE_VSAM_FILE: 'RESOURCE_VSAM_FILE',
    RESOURCE_GDG_FILE: 'RESOURCE_GDG_FILE',
    RESOURCE_RECORD: 'RESOURCE_RECORD',
    SQL_STORED_PROCEDURE: 'SQL_STORED_PROCEDURE',
    SQL_SCRIPT: 'SQL_SCRIPT',
    SQL_TABLE: 'SQL_TABLE',
    SQL_INDEX: 'SQL_INDEX',
    SQL_VIEW: 'SQL_VIEW',
    SQL_TRIGGER: 'SQL_TRIGGER',
    SQL_SCHEMA: 'SQL_SCHEMA',
    SQL_TEMPORARY_TABLE: 'SQL_TEMPORARY_TABLE',
    SQL_SYNONYM: 'SQL_SYNONYM',
    DCL: 'DCL',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    XML: 'XML',
    XML_XHTML: 'XML_XHTML',
    VB_MODULE: 'VB_MODULE',
    VB_CLASS: 'VB_CLASS',
    VB_FORM: 'VB_FORM',
    VB_CONTROL: 'VB_CONTROL',
    VB_PROJECT: 'VB_PROJECT',
    VB_WORKSPACE: 'VB_WORKSPACE',
    VB_ACTIVEX_DOCUMENT: 'VB_ACTIVEX_DOCUMENT',
    VB_DESIGNER_FILE: 'VB_DESIGNER_FILE',
    WINDOWS_DLL: 'WINDOWS_DLL',
    WINDOWS_OCX: 'WINDOWS_OCX',
    SERVICE: 'SERVICE',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD',
    MARK4_PROGRAM: 'MARK4_PROGRAM'
} as const;

export type ModuleLightweightPojoModuleTypeEnum = typeof ModuleLightweightPojoModuleTypeEnum[keyof typeof ModuleLightweightPojoModuleTypeEnum];

/**
 * 
 * @export
 * @interface ModuleLocation
 */
export interface ModuleLocation {
    /**
     * 
     * @type {number}
     * @memberof ModuleLocation
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleLocation
     */
    'length'?: number;
}
/**
 * 
 * @export
 * @interface ModuleMatcher
 */
export interface ModuleMatcher {
    /**
     * 
     * @type {Array<EntityId>}
     * @memberof ModuleMatcher
     */
    'ids'?: Array<EntityId>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleMatcher
     */
    'pathPatterns'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ModuleNode
 */
export interface ModuleNode extends DataFlowGraphNode {
    /**
     * 
     * @type {number}
     * @memberof ModuleNode
     */
    'moduleId'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ModuleNode
     */
    'dataInterfaces'?: Set<string>;
}


/**
 * 
 * @export
 * @interface ModuleNodeAllOf
 */
export interface ModuleNodeAllOf {
    /**
     * 
     * @type {number}
     * @memberof ModuleNodeAllOf
     */
    'moduleId'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ModuleNodeAllOf
     */
    'dataInterfaces'?: Set<string>;
}
/**
 * 
 * @export
 * @interface ModulePart
 */
export interface ModulePart {
    /**
     * 
     * @type {string}
     * @memberof ModulePart
     */
    'moduleLinkHash'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModulePart
     */
    'location'?: ModuleLocation;
}
/**
 * 
 * @export
 * @interface ModulePojo
 */
export interface ModulePojo {
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'nid'?: number;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof ModulePojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'technology'?: ModulePojoTechnologyEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'type'?: ModulePojoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'storage'?: ModulePojoStorageEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'origin'?: ModulePojoOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'creator'?: ModulePojoCreatorEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'identification'?: ModulePojoIdentificationEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModulePojo
     */
    'info'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'source'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'contentHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'linkHash'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModulePojo
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'representation'?: ModulePojoRepresentationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ModulePojo
     */
    'requiresReview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'modifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'metricsDate'?: string;
    /**
     * 
     * @type {SourceMetricsPojo}
     * @memberof ModulePojo
     */
    'sourceMetrics'?: SourceMetricsPojo;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'content'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'errors'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'statements'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'sqlStatements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModulePojo
     */
    'sourceCodeAvailable'?: boolean;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojo
     */
    'parentEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'parent'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'parentId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'parentPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojo
     */
    'dependencyHash'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModulePojo
     */
    'id'?: number;
}

export const ModulePojoTechnologyEnum = {
    COBOL: 'COBOL',
    NATURAL: 'NATURAL',
    PL1: 'PL1',
    JCL: 'JCL',
    ASSEMBLER: 'ASSEMBLER',
    RESOURCE: 'RESOURCE',
    CSD: 'CSD',
    NONE: 'NONE',
    UNKNOWN: 'UNKNOWN',
    XML: 'XML',
    BINARY: 'BINARY',
    EASYTRIEVE: 'EASYTRIEVE',
    IMS: 'IMS',
    C: 'C',
    CPP: 'CPP',
    VMS: 'VMS',
    ORACLE: 'ORACLE',
    SQL: 'SQL',
    JAVA: 'JAVA',
    ECL: 'ECL',
    CICS: 'CICS',
    SCHEDULER: 'SCHEDULER',
    BASIC: 'BASIC',
    VB: 'VB',
    WINDOWS: 'WINDOWS',
    SERVICE: 'SERVICE',
    MARK4: 'MARK4'
} as const;

export type ModulePojoTechnologyEnum = typeof ModulePojoTechnologyEnum[keyof typeof ModulePojoTechnologyEnum];
export const ModulePojoTypeEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type ModulePojoTypeEnum = typeof ModulePojoTypeEnum[keyof typeof ModulePojoTypeEnum];
export const ModulePojoStorageEnum = {
    FILE: 'FILE',
    FILE_SECTION: 'FILE_SECTION',
    DATABASE: 'DATABASE',
    NETWORK: 'NETWORK',
    UNDEFINED: 'UNDEFINED',
    SYSTEM: 'SYSTEM',
    QUEUE: 'QUEUE'
} as const;

export type ModulePojoStorageEnum = typeof ModulePojoStorageEnum[keyof typeof ModulePojoStorageEnum];
export const ModulePojoOriginEnum = {
    CUSTOM: 'CUSTOM',
    ENVIRONMENT: 'ENVIRONMENT'
} as const;

export type ModulePojoOriginEnum = typeof ModulePojoOriginEnum[keyof typeof ModulePojoOriginEnum];
export const ModulePojoCreatorEnum = {
    DISCOVERY: 'DISCOVERY',
    API: 'API',
    SCHEDULER_INFO: 'SCHEDULER_INFO'
} as const;

export type ModulePojoCreatorEnum = typeof ModulePojoCreatorEnum[keyof typeof ModulePojoCreatorEnum];
export const ModulePojoIdentificationEnum = {
    IDENTIFIED: 'IDENTIFIED',
    MISSING: 'MISSING'
} as const;

export type ModulePojoIdentificationEnum = typeof ModulePojoIdentificationEnum[keyof typeof ModulePojoIdentificationEnum];
export const ModulePojoRepresentationEnum = {
    PHYSICAL: 'PHYSICAL',
    VIRTUAL: 'VIRTUAL'
} as const;

export type ModulePojoRepresentationEnum = typeof ModulePojoRepresentationEnum[keyof typeof ModulePojoRepresentationEnum];

/**
 * 
 * @export
 * @interface ModulePojoPrototype
 */
export interface ModulePojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModulePojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof ModulePojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojoPrototype
     */
    'project'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'technology'?: ModulePojoPrototypeTechnologyEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'type'?: ModulePojoPrototypeTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'storage'?: ModulePojoPrototypeStorageEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'origin'?: ModulePojoPrototypeOriginEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'creator'?: ModulePojoPrototypeCreatorEnum;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'identification'?: ModulePojoPrototypeIdentificationEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModulePojoPrototype
     */
    'info'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'description'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojoPrototype
     */
    'source'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'contentHash'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'linkHash'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModulePojoPrototype
     */
    'location'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'representation'?: ModulePojoPrototypeRepresentationEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ModulePojoPrototype
     */
    'requiresReview'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'modifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'metricsDate'?: string;
    /**
     * 
     * @type {SourceMetricsPojoPrototype}
     * @memberof ModulePojoPrototype
     */
    'sourceMetrics'?: SourceMetricsPojoPrototype;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'content'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojoPrototype
     */
    'parent'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'parentPath'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModulePojoPrototype
     */
    'dependencyHash'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ModulePojoPrototype
     */
    'id'?: EntityId;
}

export const ModulePojoPrototypeTechnologyEnum = {
    COBOL: 'COBOL',
    NATURAL: 'NATURAL',
    PL1: 'PL1',
    JCL: 'JCL',
    ASSEMBLER: 'ASSEMBLER',
    RESOURCE: 'RESOURCE',
    CSD: 'CSD',
    NONE: 'NONE',
    UNKNOWN: 'UNKNOWN',
    XML: 'XML',
    BINARY: 'BINARY',
    EASYTRIEVE: 'EASYTRIEVE',
    IMS: 'IMS',
    C: 'C',
    CPP: 'CPP',
    VMS: 'VMS',
    ORACLE: 'ORACLE',
    SQL: 'SQL',
    JAVA: 'JAVA',
    ECL: 'ECL',
    CICS: 'CICS',
    SCHEDULER: 'SCHEDULER',
    BASIC: 'BASIC',
    VB: 'VB',
    WINDOWS: 'WINDOWS',
    SERVICE: 'SERVICE',
    MARK4: 'MARK4'
} as const;

export type ModulePojoPrototypeTechnologyEnum = typeof ModulePojoPrototypeTechnologyEnum[keyof typeof ModulePojoPrototypeTechnologyEnum];
export const ModulePojoPrototypeTypeEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type ModulePojoPrototypeTypeEnum = typeof ModulePojoPrototypeTypeEnum[keyof typeof ModulePojoPrototypeTypeEnum];
export const ModulePojoPrototypeStorageEnum = {
    FILE: 'FILE',
    FILE_SECTION: 'FILE_SECTION',
    DATABASE: 'DATABASE',
    NETWORK: 'NETWORK',
    UNDEFINED: 'UNDEFINED',
    SYSTEM: 'SYSTEM',
    QUEUE: 'QUEUE'
} as const;

export type ModulePojoPrototypeStorageEnum = typeof ModulePojoPrototypeStorageEnum[keyof typeof ModulePojoPrototypeStorageEnum];
export const ModulePojoPrototypeOriginEnum = {
    CUSTOM: 'CUSTOM',
    ENVIRONMENT: 'ENVIRONMENT'
} as const;

export type ModulePojoPrototypeOriginEnum = typeof ModulePojoPrototypeOriginEnum[keyof typeof ModulePojoPrototypeOriginEnum];
export const ModulePojoPrototypeCreatorEnum = {
    DISCOVERY: 'DISCOVERY',
    API: 'API',
    SCHEDULER_INFO: 'SCHEDULER_INFO'
} as const;

export type ModulePojoPrototypeCreatorEnum = typeof ModulePojoPrototypeCreatorEnum[keyof typeof ModulePojoPrototypeCreatorEnum];
export const ModulePojoPrototypeIdentificationEnum = {
    IDENTIFIED: 'IDENTIFIED',
    MISSING: 'MISSING'
} as const;

export type ModulePojoPrototypeIdentificationEnum = typeof ModulePojoPrototypeIdentificationEnum[keyof typeof ModulePojoPrototypeIdentificationEnum];
export const ModulePojoPrototypeRepresentationEnum = {
    PHYSICAL: 'PHYSICAL',
    VIRTUAL: 'VIRTUAL'
} as const;

export type ModulePojoPrototypeRepresentationEnum = typeof ModulePojoPrototypeRepresentationEnum[keyof typeof ModulePojoPrototypeRepresentationEnum];

/**
 * 
 * @export
 * @interface ModuleRelationshipPojo
 */
export interface ModuleRelationshipPojo {
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'srcModule'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModuleRelationshipPojo
     */
    'srcLocation'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'dstModule'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModuleRelationshipPojo
     */
    'dstLocation'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'type'?: ModuleRelationshipPojoTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'direction'?: ModuleRelationshipPojoDirectionEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModuleRelationshipPojo
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'dependencyBinding'?: ModuleRelationshipPojoDependencyBindingEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'dependencyAttributes'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ModuleRelationshipPojo
     */
    'validIfReachedFrom'?: Array<string>;
    /**
     * 
     * @type {ModuleBasePojo}
     * @memberof ModuleRelationshipPojo
     */
    'srcModuleDetails'?: ModuleBasePojo;
    /**
     * 
     * @type {ModuleBasePojo}
     * @memberof ModuleRelationshipPojo
     */
    'dstModuleDetails'?: ModuleBasePojo;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'dependencyDefinition'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleRelationshipPojo
     */
    'fromDeadCode'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojo
     */
    'relationship'?: ModuleRelationshipPojoRelationshipEnum;
}

export const ModuleRelationshipPojoTypeEnum = {
    NONE: 'NONE',
    INCLUDES: 'INCLUDES',
    CONTAINS: 'CONTAINS',
    REFERENCES: 'REFERENCES',
    CALLS: 'CALLS',
    ACCESSES: 'ACCESSES',
    ARTIFICIAL: 'ARTIFICIAL',
    PRECEDES: 'PRECEDES'
} as const;

export type ModuleRelationshipPojoTypeEnum = typeof ModuleRelationshipPojoTypeEnum[keyof typeof ModuleRelationshipPojoTypeEnum];
export const ModuleRelationshipPojoDirectionEnum = {
    IN: 'IN',
    OUT: 'OUT',
    BOTH: 'BOTH'
} as const;

export type ModuleRelationshipPojoDirectionEnum = typeof ModuleRelationshipPojoDirectionEnum[keyof typeof ModuleRelationshipPojoDirectionEnum];
export const ModuleRelationshipPojoDependencyBindingEnum = {
    EARLY: 'EARLY',
    LATE: 'LATE',
    UNKNOWN: 'UNKNOWN'
} as const;

export type ModuleRelationshipPojoDependencyBindingEnum = typeof ModuleRelationshipPojoDependencyBindingEnum[keyof typeof ModuleRelationshipPojoDependencyBindingEnum];
export const ModuleRelationshipPojoRelationshipEnum = {
    NONE: 'NONE',
    INCLUDES: 'INCLUDES',
    CONTAINS: 'CONTAINS',
    REFERENCES: 'REFERENCES',
    CALLS: 'CALLS',
    ACCESSES: 'ACCESSES',
    ARTIFICIAL: 'ARTIFICIAL',
    PRECEDES: 'PRECEDES'
} as const;

export type ModuleRelationshipPojoRelationshipEnum = typeof ModuleRelationshipPojoRelationshipEnum[keyof typeof ModuleRelationshipPojoRelationshipEnum];

/**
 * 
 * @export
 * @interface ModuleRelationshipPojoPrototype
 */
export interface ModuleRelationshipPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'id'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'srcModule'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'srcLocation'?: ModuleLocation;
    /**
     * 
     * @type {EntityId}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'dstModule'?: EntityId;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'dstLocation'?: ModuleLocation;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'type'?: ModuleRelationshipPojoPrototypeTypeEnum;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'properties'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'dependencyBinding'?: ModuleRelationshipPojoPrototypeDependencyBindingEnum;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'dependencyAttributes'?: string;
    /**
     * 
     * @type {Array<EntityId>}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'validIfReachedFrom'?: Array<EntityId>;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'dependencyDefinition'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'fromDeadCode'?: boolean;
    /**
     * 
     * @type {ModuleRelationshipPojoPrototype}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'relationship'?: ModuleRelationshipPojoPrototype;
    /**
     * 
     * @type {string}
     * @memberof ModuleRelationshipPojoPrototype
     */
    'uuid'?: string;
}

export const ModuleRelationshipPojoPrototypeTypeEnum = {
    NONE: 'NONE',
    INCLUDES: 'INCLUDES',
    CONTAINS: 'CONTAINS',
    REFERENCES: 'REFERENCES',
    CALLS: 'CALLS',
    ACCESSES: 'ACCESSES',
    ARTIFICIAL: 'ARTIFICIAL',
    PRECEDES: 'PRECEDES'
} as const;

export type ModuleRelationshipPojoPrototypeTypeEnum = typeof ModuleRelationshipPojoPrototypeTypeEnum[keyof typeof ModuleRelationshipPojoPrototypeTypeEnum];
export const ModuleRelationshipPojoPrototypeDependencyBindingEnum = {
    EARLY: 'EARLY',
    LATE: 'LATE',
    UNKNOWN: 'UNKNOWN'
} as const;

export type ModuleRelationshipPojoPrototypeDependencyBindingEnum = typeof ModuleRelationshipPojoPrototypeDependencyBindingEnum[keyof typeof ModuleRelationshipPojoPrototypeDependencyBindingEnum];

/**
 * 
 * @export
 * @interface ModuleStatisticsResponse
 */
export interface ModuleStatisticsResponse {
    /**
     * 
     * @type {number}
     * @memberof ModuleStatisticsResponse
     */
    'count'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleStatisticsResponse
     */
    'withErrorsCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleStatisticsResponse
     */
    'sourceCodeLineCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleStatisticsResponse
     */
    'sourceFileCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof ModuleStatisticsResponse
     */
    'missingCount'?: number;
    /**
     * 
     * @type {{ [key: string]: number; }}
     * @memberof ModuleStatisticsResponse
     */
    'moduleTechnologyList'?: { [key: string]: number; };
    /**
     * 
     * @type {Array<ModuleTechnologyStatistic>}
     * @memberof ModuleStatisticsResponse
     */
    'technologies'?: Array<ModuleTechnologyStatistic>;
}
/**
 * 
 * @export
 * @interface ModuleTechnologyStatistic
 */
export interface ModuleTechnologyStatistic {
    /**
     * 
     * @type {string}
     * @memberof ModuleTechnologyStatistic
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ModuleTechnologyStatistic
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface OfflineTokenInfo
 */
export interface OfflineTokenInfo {
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'subject'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'bearerToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'refreshToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof OfflineTokenInfo
     */
    'dateCreated'?: string;
}
/**
 * 
 * @export
 * @interface PageMember
 */
export interface PageMember {
    /**
     * 
     * @type {number}
     * @memberof PageMember
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMember
     */
    'totalPages'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageMember
     */
    'size'?: number;
    /**
     * 
     * @type {Array<Member>}
     * @memberof PageMember
     */
    'content'?: Array<Member>;
    /**
     * 
     * @type {number}
     * @memberof PageMember
     */
    'number'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageMember
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageMember
     */
    'first'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PageMember
     */
    'last'?: boolean;
    /**
     * 
     * @type {PageableObject}
     * @memberof PageMember
     */
    'pageable'?: PageableObject;
    /**
     * 
     * @type {number}
     * @memberof PageMember
     */
    'numberOfElements'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageMember
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface PageableObject
 */
export interface PageableObject {
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'offset'?: number;
    /**
     * 
     * @type {SortObject}
     * @memberof PageableObject
     */
    'sort'?: SortObject;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'unpaged'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageNumber'?: number;
    /**
     * 
     * @type {number}
     * @memberof PageableObject
     */
    'pageSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PageableObject
     */
    'paged'?: boolean;
}
/**
 * 
 * @export
 * @interface PagedClientPojo
 */
export interface PagedClientPojo {
    /**
     * 
     * @type {Array<ClientPojo>}
     * @memberof PagedClientPojo
     */
    'content'?: Array<ClientPojo>;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'firstElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'lastElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedClientPojo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface PagedJobInformation
 */
export interface PagedJobInformation {
    /**
     * 
     * @type {Array<JobInformation>}
     * @memberof PagedJobInformation
     */
    'content'?: Array<JobInformation>;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'firstElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'lastElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedJobInformation
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface PagedProjectPojo
 */
export interface PagedProjectPojo {
    /**
     * 
     * @type {Array<ProjectPojo>}
     * @memberof PagedProjectPojo
     */
    'content'?: Array<ProjectPojo>;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'offset'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'totalElements'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'firstElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'lastElement'?: number;
    /**
     * 
     * @type {number}
     * @memberof PagedProjectPojo
     */
    'size'?: number;
}
/**
 * 
 * @export
 * @interface ParameterDescription
 */
export interface ParameterDescription {
    /**
     * 
     * @type {string}
     * @memberof ParameterDescription
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterDescription
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParameterDescription
     */
    'type'?: ParameterDescriptionTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ParameterDescription
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParameterDescription
     */
    'defaultValue'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParameterDescription
     */
    'allowMultiple'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParameterDescription
     */
    'example'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ParameterDescription
     */
    'allowableValues'?: Array<string>;
}

export const ParameterDescriptionTypeEnum = {
    STRING: 'STRING',
    NUMBER: 'NUMBER',
    BOOLEAN: 'BOOLEAN'
} as const;

export type ParameterDescriptionTypeEnum = typeof ParameterDescriptionTypeEnum[keyof typeof ParameterDescriptionTypeEnum];

/**
 * 
 * @export
 * @interface PrimaryKey
 */
export interface PrimaryKey {
    /**
     * 
     * @type {string}
     * @memberof PrimaryKey
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PrimaryKey
     */
    'columns'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProjectPojo
 */
export interface ProjectPojo {
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof ProjectPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {EntityId}
     * @memberof ProjectPojo
     */
    'clientEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'client'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'clientId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectPojo
     */
    'markedDeleted'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'sourceCodeRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'metricsBaseRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'metricsVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'metricsDate'?: string;
    /**
     * 
     * @type {Array<SearchOrder>}
     * @memberof ProjectPojo
     */
    'searchOrders'?: Array<SearchOrder>;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'defaultTaxonomyCategoryId'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojo
     */
    'technicalTaxonomyCategoryId'?: number;
    /**
     * 
     * @type {{ [key: string]: Set<string>; }}
     * @memberof ProjectPojo
     */
    'customPropertyClasses'?: { [key: string]: Set<string>; };
    /**
     * 
     * @type {string}
     * @memberof ProjectPojo
     */
    'metaDataBackupId'?: string;
}
/**
 * 
 * @export
 * @interface ProjectPojoCustomProperties
 */
export interface ProjectPojoCustomProperties {
    [key: string]: object | any;

    /**
     * 
     * @type {boolean}
     * @memberof ProjectPojoCustomProperties
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface ProjectPojoPrototype
 */
export interface ProjectPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof ProjectPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ProjectPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof ProjectPojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof ProjectPojoPrototype
     */
    'client'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojoPrototype
     */
    'sourceCodeRevision'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojoPrototype
     */
    'metricsBaseRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojoPrototype
     */
    'metricsVersion'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojoPrototype
     */
    'metricsDate'?: string;
    /**
     * 
     * @type {Array<SearchOrder>}
     * @memberof ProjectPojoPrototype
     */
    'searchOrders'?: Array<SearchOrder>;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojoPrototype
     */
    'defaultTaxonomyCategory'?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectPojoPrototype
     */
    'technicalTaxonomyCategory'?: number;
    /**
     * 
     * @type {Set<string>}
     * @memberof ProjectPojoPrototype
     */
    'natures'?: Set<ProjectPojoPrototypeNaturesEnum>;
    /**
     * 
     * @type {string}
     * @memberof ProjectPojoPrototype
     */
    'metaDataBackupId'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof ProjectPojoPrototype
     */
    'id'?: EntityId;
}

export const ProjectPojoPrototypeNaturesEnum = {
    DISCOVERY: 'DISCOVERY',
    DISCOVERY_LIGHT: 'DISCOVERY_LIGHT',
    MINING: 'MINING',
    DB_CUTTER: 'DB_CUTTER'
} as const;

export type ProjectPojoPrototypeNaturesEnum = typeof ProjectPojoPrototypeNaturesEnum[keyof typeof ProjectPojoPrototypeNaturesEnum];

/**
 * 
 * @export
 * @interface ProjectRole
 */
export interface ProjectRole {
    /**
     * 
     * @type {number}
     * @memberof ProjectRole
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectRole
     */
    'userRole'?: ProjectRoleUserRoleEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProjectRole
     */
    'projectNatures'?: Array<ProjectRoleProjectNaturesEnum>;
}

export const ProjectRoleUserRoleEnum = {
    VIEWER: 'VIEWER',
    EDITOR: 'EDITOR',
    MANAGER: 'MANAGER',
    CLIENT_ADMIN: 'CLIENT_ADMIN',
    ADMIN: 'ADMIN'
} as const;

export type ProjectRoleUserRoleEnum = typeof ProjectRoleUserRoleEnum[keyof typeof ProjectRoleUserRoleEnum];
export const ProjectRoleProjectNaturesEnum = {
    DISCOVERY: 'DISCOVERY',
    DISCOVERY_LIGHT: 'DISCOVERY_LIGHT',
    MINING: 'MINING',
    DB_CUTTER: 'DB_CUTTER'
} as const;

export type ProjectRoleProjectNaturesEnum = typeof ProjectRoleProjectNaturesEnum[keyof typeof ProjectRoleProjectNaturesEnum];

/**
 * 
 * @export
 * @interface PropagationData
 */
export interface PropagationData {
    /**
     * 
     * @type {number}
     * @memberof PropagationData
     */
    'moduleId'?: number;
    /**
     * 
     * @type {Set<EntityId>}
     * @memberof PropagationData
     */
    'taxonomies'?: Set<EntityId>;
}
/**
 * 
 * @export
 * @interface ReachabilityAnalysisRequest
 */
export interface ReachabilityAnalysisRequest {
    /**
     * 
     * @type {string}
     * @memberof ReachabilityAnalysisRequest
     */
    'analysisType'?: ReachabilityAnalysisRequestAnalysisTypeEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof ReachabilityAnalysisRequest
     */
    'moduleTypes'?: Array<ReachabilityAnalysisRequestModuleTypesEnum>;
    /**
     * 
     * @type {Array<EntityId>}
     * @memberof ReachabilityAnalysisRequest
     */
    'moduleTaxonomies'?: Array<EntityId>;
    /**
     * 
     * @type {boolean}
     * @memberof ReachabilityAnalysisRequest
     */
    'recalculateAll'?: boolean;
}

export const ReachabilityAnalysisRequestAnalysisTypeEnum = {
    BOTTOM_UP: 'BOTTOM_UP',
    TOP_DOWN: 'TOP_DOWN'
} as const;

export type ReachabilityAnalysisRequestAnalysisTypeEnum = typeof ReachabilityAnalysisRequestAnalysisTypeEnum[keyof typeof ReachabilityAnalysisRequestAnalysisTypeEnum];
export const ReachabilityAnalysisRequestModuleTypesEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type ReachabilityAnalysisRequestModuleTypesEnum = typeof ReachabilityAnalysisRequestModuleTypesEnum[keyof typeof ReachabilityAnalysisRequestModuleTypesEnum];

/**
 * 
 * @export
 * @interface ReachabilityBlockGraphFilterRequest
 */
export interface ReachabilityBlockGraphFilterRequest {
    /**
     * 
     * @type {Set<EntityId>}
     * @memberof ReachabilityBlockGraphFilterRequest
     */
    'taxonomyIds'?: Set<EntityId>;
    /**
     * 
     * @type {Set<EntityId>}
     * @memberof ReachabilityBlockGraphFilterRequest
     */
    'functionalBlockIds'?: Set<EntityId>;
    /**
     * 
     * @type {Set<TechnologyType>}
     * @memberof ReachabilityBlockGraphFilterRequest
     */
    'technologyTypes'?: Set<TechnologyType>;
    /**
     * 
     * @type {Set<string>}
     * @memberof ReachabilityBlockGraphFilterRequest
     */
    'relationshipTypes'?: Set<ReachabilityBlockGraphFilterRequestRelationshipTypesEnum>;
}

export const ReachabilityBlockGraphFilterRequestRelationshipTypesEnum = {
    NONE: 'NONE',
    INCLUDES: 'INCLUDES',
    CONTAINS: 'CONTAINS',
    REFERENCES: 'REFERENCES',
    CALLS: 'CALLS',
    ACCESSES: 'ACCESSES',
    ARTIFICIAL: 'ARTIFICIAL',
    PRECEDES: 'PRECEDES'
} as const;

export type ReachabilityBlockGraphFilterRequestRelationshipTypesEnum = typeof ReachabilityBlockGraphFilterRequestRelationshipTypesEnum[keyof typeof ReachabilityBlockGraphFilterRequestRelationshipTypesEnum];

/**
 * 
 * @export
 * @interface ReachabilityNetworkGraphFilterRequest
 */
export interface ReachabilityNetworkGraphFilterRequest {
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof ReachabilityNetworkGraphFilterRequest
     */
    'filterObject'?: { [key: string]: object; };
    /**
     * 
     * @type {Set<TechnologyType>}
     * @memberof ReachabilityNetworkGraphFilterRequest
     */
    'technologyTypes'?: Set<TechnologyType>;
    /**
     * 
     * @type {string}
     * @memberof ReachabilityNetworkGraphFilterRequest
     */
    'functionalBlockLinkType'?: ReachabilityNetworkGraphFilterRequestFunctionalBlockLinkTypeEnum;
}

export const ReachabilityNetworkGraphFilterRequestFunctionalBlockLinkTypeEnum = {
    RA_ACCESS: 'RA_ACCESS',
    RA_SHARED_RESOURCE: 'RA_SHARED_RESOURCE',
    RA_FROM_SCHEDULER_INFO: 'RA_FROM_SCHEDULER_INFO',
    DIRECTED: 'DIRECTED',
    CALL_CHAIN: 'CALL_CHAIN'
} as const;

export type ReachabilityNetworkGraphFilterRequestFunctionalBlockLinkTypeEnum = typeof ReachabilityNetworkGraphFilterRequestFunctionalBlockLinkTypeEnum[keyof typeof ReachabilityNetworkGraphFilterRequestFunctionalBlockLinkTypeEnum];

/**
 * 
 * @export
 * @interface RedirectView
 */
export interface RedirectView {
    /**
     * 
     * @type {ApplicationContext}
     * @memberof RedirectView
     */
    'applicationContext'?: ApplicationContext;
    /**
     * 
     * @type {RedirectViewServletContext}
     * @memberof RedirectView
     */
    'servletContext'?: RedirectViewServletContext;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'contentType'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'requestContextAttribute'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof RedirectView
     */
    'staticAttributes'?: { [key: string]: object; };
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'exposePathVariables'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'exposeContextBeansAsAttributes'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectView
     */
    'exposedContextBeanNames'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'beanName'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'url'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'contextRelative'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'http10Compatible'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'exposeModelAttributes'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'encodingScheme'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'statusCode'?: RedirectViewStatusCodeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'expandUriTemplateVariables'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'propagateQueryParams'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectView
     */
    'hosts'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'propagateQueryProperties'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectView
     */
    'redirectView'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RedirectView
     */
    'attributes'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof RedirectView
     */
    'attributesMap'?: { [key: string]: object; };
    /**
     * 
     * @type {string}
     * @memberof RedirectView
     */
    'attributesCSV'?: string;
}

export const RedirectViewStatusCodeEnum = {
    _100_CONTINUE: '100 CONTINUE',
    _101_SWITCHING_PROTOCOLS: '101 SWITCHING_PROTOCOLS',
    _102_PROCESSING: '102 PROCESSING',
    _103_CHECKPOINT: '103 CHECKPOINT',
    _200_OK: '200 OK',
    _201_CREATED: '201 CREATED',
    _202_ACCEPTED: '202 ACCEPTED',
    _203_NON_AUTHORITATIVE_INFORMATION: '203 NON_AUTHORITATIVE_INFORMATION',
    _204_NO_CONTENT: '204 NO_CONTENT',
    _205_RESET_CONTENT: '205 RESET_CONTENT',
    _206_PARTIAL_CONTENT: '206 PARTIAL_CONTENT',
    _207_MULTI_STATUS: '207 MULTI_STATUS',
    _208_ALREADY_REPORTED: '208 ALREADY_REPORTED',
    _226_IM_USED: '226 IM_USED',
    _300_MULTIPLE_CHOICES: '300 MULTIPLE_CHOICES',
    _301_MOVED_PERMANENTLY: '301 MOVED_PERMANENTLY',
    _302_FOUND: '302 FOUND',
    _302_MOVED_TEMPORARILY: '302 MOVED_TEMPORARILY',
    _303_SEE_OTHER: '303 SEE_OTHER',
    _304_NOT_MODIFIED: '304 NOT_MODIFIED',
    _305_USE_PROXY: '305 USE_PROXY',
    _307_TEMPORARY_REDIRECT: '307 TEMPORARY_REDIRECT',
    _308_PERMANENT_REDIRECT: '308 PERMANENT_REDIRECT',
    _400_BAD_REQUEST: '400 BAD_REQUEST',
    _401_UNAUTHORIZED: '401 UNAUTHORIZED',
    _402_PAYMENT_REQUIRED: '402 PAYMENT_REQUIRED',
    _403_FORBIDDEN: '403 FORBIDDEN',
    _404_NOT_FOUND: '404 NOT_FOUND',
    _405_METHOD_NOT_ALLOWED: '405 METHOD_NOT_ALLOWED',
    _406_NOT_ACCEPTABLE: '406 NOT_ACCEPTABLE',
    _407_PROXY_AUTHENTICATION_REQUIRED: '407 PROXY_AUTHENTICATION_REQUIRED',
    _408_REQUEST_TIMEOUT: '408 REQUEST_TIMEOUT',
    _409_CONFLICT: '409 CONFLICT',
    _410_GONE: '410 GONE',
    _411_LENGTH_REQUIRED: '411 LENGTH_REQUIRED',
    _412_PRECONDITION_FAILED: '412 PRECONDITION_FAILED',
    _413_PAYLOAD_TOO_LARGE: '413 PAYLOAD_TOO_LARGE',
    _413_REQUEST_ENTITY_TOO_LARGE: '413 REQUEST_ENTITY_TOO_LARGE',
    _414_URI_TOO_LONG: '414 URI_TOO_LONG',
    _414_REQUEST_URI_TOO_LONG: '414 REQUEST_URI_TOO_LONG',
    _415_UNSUPPORTED_MEDIA_TYPE: '415 UNSUPPORTED_MEDIA_TYPE',
    _416_REQUESTED_RANGE_NOT_SATISFIABLE: '416 REQUESTED_RANGE_NOT_SATISFIABLE',
    _417_EXPECTATION_FAILED: '417 EXPECTATION_FAILED',
    _418_I_AM_A_TEAPOT: '418 I_AM_A_TEAPOT',
    _419_INSUFFICIENT_SPACE_ON_RESOURCE: '419 INSUFFICIENT_SPACE_ON_RESOURCE',
    _420_METHOD_FAILURE: '420 METHOD_FAILURE',
    _421_DESTINATION_LOCKED: '421 DESTINATION_LOCKED',
    _422_UNPROCESSABLE_ENTITY: '422 UNPROCESSABLE_ENTITY',
    _423_LOCKED: '423 LOCKED',
    _424_FAILED_DEPENDENCY: '424 FAILED_DEPENDENCY',
    _425_TOO_EARLY: '425 TOO_EARLY',
    _426_UPGRADE_REQUIRED: '426 UPGRADE_REQUIRED',
    _428_PRECONDITION_REQUIRED: '428 PRECONDITION_REQUIRED',
    _429_TOO_MANY_REQUESTS: '429 TOO_MANY_REQUESTS',
    _431_REQUEST_HEADER_FIELDS_TOO_LARGE: '431 REQUEST_HEADER_FIELDS_TOO_LARGE',
    _451_UNAVAILABLE_FOR_LEGAL_REASONS: '451 UNAVAILABLE_FOR_LEGAL_REASONS',
    _500_INTERNAL_SERVER_ERROR: '500 INTERNAL_SERVER_ERROR',
    _501_NOT_IMPLEMENTED: '501 NOT_IMPLEMENTED',
    _502_BAD_GATEWAY: '502 BAD_GATEWAY',
    _503_SERVICE_UNAVAILABLE: '503 SERVICE_UNAVAILABLE',
    _504_GATEWAY_TIMEOUT: '504 GATEWAY_TIMEOUT',
    _505_HTTP_VERSION_NOT_SUPPORTED: '505 HTTP_VERSION_NOT_SUPPORTED',
    _506_VARIANT_ALSO_NEGOTIATES: '506 VARIANT_ALSO_NEGOTIATES',
    _507_INSUFFICIENT_STORAGE: '507 INSUFFICIENT_STORAGE',
    _508_LOOP_DETECTED: '508 LOOP_DETECTED',
    _509_BANDWIDTH_LIMIT_EXCEEDED: '509 BANDWIDTH_LIMIT_EXCEEDED',
    _510_NOT_EXTENDED: '510 NOT_EXTENDED',
    _511_NETWORK_AUTHENTICATION_REQUIRED: '511 NETWORK_AUTHENTICATION_REQUIRED'
} as const;

export type RedirectViewStatusCodeEnum = typeof RedirectViewStatusCodeEnum[keyof typeof RedirectViewStatusCodeEnum];

/**
 * 
 * @export
 * @interface RedirectViewServletContext
 */
export interface RedirectViewServletContext {
    /**
     * 
     * @type {ApplicationContextClassLoaderParentUnnamedModuleClassLoader}
     * @memberof RedirectViewServletContext
     */
    'classLoader'?: ApplicationContextClassLoaderParentUnnamedModuleClassLoader;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContext
     */
    'majorVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContext
     */
    'minorVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'contextPath'?: string;
    /**
     * 
     * @type {object}
     * @memberof RedirectViewServletContext
     * @deprecated
     */
    'servletNames'?: object;
    /**
     * 
     * @type {object}
     * @memberof RedirectViewServletContext
     * @deprecated
     */
    'servlets'?: object;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'serverInfo'?: string;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContext
     */
    'sessionTimeout'?: number;
    /**
     * 
     * @type {object}
     * @memberof RedirectViewServletContext
     */
    'attributeNames'?: object;
    /**
     * 
     * @type {object}
     * @memberof RedirectViewServletContext
     */
    'initParameterNames'?: object;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContext
     */
    'effectiveMajorVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContext
     */
    'effectiveMinorVersion'?: number;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'requestCharacterEncoding'?: string;
    /**
     * 
     * @type {{ [key: string]: RedirectViewServletContextFilterRegistrationsValue; }}
     * @memberof RedirectViewServletContext
     */
    'filterRegistrations'?: { [key: string]: RedirectViewServletContextFilterRegistrationsValue; };
    /**
     * 
     * @type {Set<string>}
     * @memberof RedirectViewServletContext
     */
    'sessionTrackingModes'?: Set<RedirectViewServletContextSessionTrackingModesEnum>;
    /**
     * 
     * @type {Set<string>}
     * @memberof RedirectViewServletContext
     */
    'defaultSessionTrackingModes'?: Set<RedirectViewServletContextDefaultSessionTrackingModesEnum>;
    /**
     * 
     * @type {RedirectViewServletContextJspConfigDescriptor}
     * @memberof RedirectViewServletContext
     */
    'jspConfigDescriptor'?: RedirectViewServletContextJspConfigDescriptor;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'virtualServerName'?: string;
    /**
     * 
     * @type {RedirectViewServletContextSessionCookieConfig}
     * @memberof RedirectViewServletContext
     */
    'sessionCookieConfig'?: RedirectViewServletContextSessionCookieConfig;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'servletContextName'?: string;
    /**
     * 
     * @type {{ [key: string]: RedirectViewServletContextServletRegistrationsValue; }}
     * @memberof RedirectViewServletContext
     */
    'servletRegistrations'?: { [key: string]: RedirectViewServletContextServletRegistrationsValue; };
    /**
     * 
     * @type {Set<string>}
     * @memberof RedirectViewServletContext
     */
    'effectiveSessionTrackingModes'?: Set<RedirectViewServletContextEffectiveSessionTrackingModesEnum>;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContext
     */
    'responseCharacterEncoding'?: string;
}

export const RedirectViewServletContextSessionTrackingModesEnum = {
    COOKIE: 'COOKIE',
    URL: 'URL',
    SSL: 'SSL'
} as const;

export type RedirectViewServletContextSessionTrackingModesEnum = typeof RedirectViewServletContextSessionTrackingModesEnum[keyof typeof RedirectViewServletContextSessionTrackingModesEnum];
export const RedirectViewServletContextDefaultSessionTrackingModesEnum = {
    COOKIE: 'COOKIE',
    URL: 'URL',
    SSL: 'SSL'
} as const;

export type RedirectViewServletContextDefaultSessionTrackingModesEnum = typeof RedirectViewServletContextDefaultSessionTrackingModesEnum[keyof typeof RedirectViewServletContextDefaultSessionTrackingModesEnum];
export const RedirectViewServletContextEffectiveSessionTrackingModesEnum = {
    COOKIE: 'COOKIE',
    URL: 'URL',
    SSL: 'SSL'
} as const;

export type RedirectViewServletContextEffectiveSessionTrackingModesEnum = typeof RedirectViewServletContextEffectiveSessionTrackingModesEnum[keyof typeof RedirectViewServletContextEffectiveSessionTrackingModesEnum];

/**
 * 
 * @export
 * @interface RedirectViewServletContextFilterRegistrationsValue
 */
export interface RedirectViewServletContextFilterRegistrationsValue {
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextFilterRegistrationsValue
     */
    'urlPatternMappings'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextFilterRegistrationsValue
     */
    'servletNameMappings'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextFilterRegistrationsValue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextFilterRegistrationsValue
     */
    'className'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RedirectViewServletContextFilterRegistrationsValue
     */
    'initParameters'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RedirectViewServletContextJspConfigDescriptor
 */
export interface RedirectViewServletContextJspConfigDescriptor {
    /**
     * 
     * @type {Array<RedirectViewServletContextJspConfigDescriptorTaglibsInner>}
     * @memberof RedirectViewServletContextJspConfigDescriptor
     */
    'taglibs'?: Array<RedirectViewServletContextJspConfigDescriptorTaglibsInner>;
    /**
     * 
     * @type {Array<RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner>}
     * @memberof RedirectViewServletContextJspConfigDescriptor
     */
    'jspPropertyGroups'?: Array<RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner>;
}
/**
 * 
 * @export
 * @interface RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
 */
export interface RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner {
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'buffer'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'defaultContentType'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'urlPatterns'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'pageEncoding'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'isXml'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'elIgnored'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'includePreludes'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'includeCodas'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'deferredSyntaxAllowedAsLiteral'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'trimDirectiveWhitespaces'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'scriptingInvalid'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorJspPropertyGroupsInner
     */
    'errorOnUndeclaredNamespace'?: string;
}
/**
 * 
 * @export
 * @interface RedirectViewServletContextJspConfigDescriptorTaglibsInner
 */
export interface RedirectViewServletContextJspConfigDescriptorTaglibsInner {
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorTaglibsInner
     */
    'taglibURI'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextJspConfigDescriptorTaglibsInner
     */
    'taglibLocation'?: string;
}
/**
 * 
 * @export
 * @interface RedirectViewServletContextServletRegistrationsValue
 */
export interface RedirectViewServletContextServletRegistrationsValue {
    /**
     * 
     * @type {Array<string>}
     * @memberof RedirectViewServletContextServletRegistrationsValue
     */
    'mappings'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextServletRegistrationsValue
     */
    'runAsRole'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextServletRegistrationsValue
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextServletRegistrationsValue
     */
    'className'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof RedirectViewServletContextServletRegistrationsValue
     */
    'initParameters'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface RedirectViewServletContextSessionCookieConfig
 */
export interface RedirectViewServletContextSessionCookieConfig {
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'comment'?: string;
    /**
     * 
     * @type {string}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'domain'?: string;
    /**
     * 
     * @type {number}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'maxAge'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'secure'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RedirectViewServletContextSessionCookieConfig
     */
    'httpOnly'?: boolean;
}
/**
 * 
 * @export
 * @interface ResultStatus
 */
export interface ResultStatus {
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    'severity'?: ResultStatusSeverityEnum;
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof ResultStatus
     */
    'stackTrace'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ResultStatus
     */
    'hasCollectableResult'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ResultStatus
     */
    'internalResult'?: boolean;
}

export const ResultStatusSeverityEnum = {
    ERROR: 'ERROR',
    CANCELED: 'CANCELED',
    WARNING: 'WARNING',
    OK: 'OK',
    UNDEFINED: 'UNDEFINED'
} as const;

export type ResultStatusSeverityEnum = typeof ResultStatusSeverityEnum[keyof typeof ResultStatusSeverityEnum];

/**
 * 
 * @export
 * @interface Routine
 */
export interface Routine {
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    'name'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Routine
     */
    'parameters'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    'type'?: RoutineTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    'bodyType'?: RoutineBodyTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Routine
     */
    'definition'?: string;
}

export const RoutineTypeEnum = {
    PROCEDURE: 'PROCEDURE',
    FUNCTION: 'FUNCTION'
} as const;

export type RoutineTypeEnum = typeof RoutineTypeEnum[keyof typeof RoutineTypeEnum];
export const RoutineBodyTypeEnum = {
    UNKNOWN: 'UNKNOWN',
    SQL: 'SQL',
    EXTERNAL: 'EXTERNAL'
} as const;

export type RoutineBodyTypeEnum = typeof RoutineBodyTypeEnum[keyof typeof RoutineBodyTypeEnum];

/**
 * 
 * @export
 * @interface SavedSearchCountResponse
 */
export interface SavedSearchCountResponse {
    /**
     * 
     * @type {SavedSearchPojo}
     * @memberof SavedSearchCountResponse
     */
    'savedSearch'?: SavedSearchPojo;
    /**
     * 
     * @type {number}
     * @memberof SavedSearchCountResponse
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface SavedSearchPojo
 */
export interface SavedSearchPojo {
    /**
     * 
     * @type {number}
     * @memberof SavedSearchPojo
     */
    'id'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof SavedSearchPojo
     */
    'clientEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'client'?: string;
    /**
     * 
     * @type {number}
     * @memberof SavedSearchPojo
     */
    'clientId'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof SavedSearchPojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof SavedSearchPojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'savedSearch'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'scope'?: SavedSearchPojoScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'usage'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SavedSearchPojo
     */
    'modifiers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'createdByUserId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojo
     */
    'createdByUserName'?: string;
}

export const SavedSearchPojoScopeEnum = {
    INDIVIDUAL: 'INDIVIDUAL',
    PROJECT: 'PROJECT',
    CLIENT: 'CLIENT',
    GLOBAL: 'GLOBAL'
} as const;

export type SavedSearchPojoScopeEnum = typeof SavedSearchPojoScopeEnum[keyof typeof SavedSearchPojoScopeEnum];

/**
 * 
 * @export
 * @interface SavedSearchPojoPrototype
 */
export interface SavedSearchPojoPrototype {
    /**
     * 
     * @type {number}
     * @memberof SavedSearchPojoPrototype
     */
    'id'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof SavedSearchPojoPrototype
     */
    'client'?: EntityId;
    /**
     * 
     * @type {EntityId}
     * @memberof SavedSearchPojoPrototype
     */
    'project'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojoPrototype
     */
    'savedSearch'?: string;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojoPrototype
     */
    'scope'?: SavedSearchPojoPrototypeScopeEnum;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojoPrototype
     */
    'usage'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SavedSearchPojoPrototype
     */
    'modifiers'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof SavedSearchPojoPrototype
     */
    'createdByUserId'?: string;
}

export const SavedSearchPojoPrototypeScopeEnum = {
    INDIVIDUAL: 'INDIVIDUAL',
    PROJECT: 'PROJECT',
    CLIENT: 'CLIENT',
    GLOBAL: 'GLOBAL'
} as const;

export type SavedSearchPojoPrototypeScopeEnum = typeof SavedSearchPojoPrototypeScopeEnum[keyof typeof SavedSearchPojoPrototypeScopeEnum];

/**
 * 
 * @export
 * @interface Schema
 */
export interface Schema {
    /**
     * 
     * @type {string}
     * @memberof Schema
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Table>}
     * @memberof Schema
     */
    'tables'?: Array<Table>;
    /**
     * 
     * @type {Array<View>}
     * @memberof Schema
     */
    'views'?: Array<View>;
    /**
     * 
     * @type {Array<Routine>}
     * @memberof Schema
     */
    'routines'?: Array<Routine>;
    /**
     * 
     * @type {Array<Trigger>}
     * @memberof Schema
     */
    'triggers'?: Array<Trigger>;
}
/**
 * 
 * @export
 * @interface SchemaInfoPojo
 */
export interface SchemaInfoPojo {
    /**
     * 
     * @type {string}
     * @memberof SchemaInfoPojo
     */
    'moduleUid'?: string;
    /**
     * 
     * @type {number}
     * @memberof SchemaInfoPojo
     */
    'moduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SchemaInfoPojo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof SchemaInfoPojo
     */
    'technology'?: string;
    /**
     * 
     * @type {number}
     * @memberof SchemaInfoPojo
     */
    'tables'?: number;
    /**
     * 
     * @type {number}
     * @memberof SchemaInfoPojo
     */
    'views'?: number;
    /**
     * 
     * @type {number}
     * @memberof SchemaInfoPojo
     */
    'procedures'?: number;
    /**
     * 
     * @type {number}
     * @memberof SchemaInfoPojo
     */
    'triggers'?: number;
}
/**
 * 
 * @export
 * @interface SearchOrder
 */
export interface SearchOrder {
    /**
     * 
     * @type {Source}
     * @memberof SearchOrder
     */
    'source'?: Source;
    /**
     * 
     * @type {Array<Target>}
     * @memberof SearchOrder
     */
    'targets'?: Array<Target>;
}
/**
 * 
 * @export
 * @interface SemanticSearchDocumentPojo
 */
export interface SemanticSearchDocumentPojo {
    /**
     * 
     * @type {number}
     * @memberof SemanticSearchDocumentPojo
     */
    'score'?: number;
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchDocumentPojo
     */
    'context'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SemanticSearchDocumentPojo
     */
    'meta'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface SemanticSearchResultPojo
 */
export interface SemanticSearchResultPojo {
    /**
     * 
     * @type {string}
     * @memberof SemanticSearchResultPojo
     */
    'answer'?: string;
    /**
     * 
     * @type {Array<SemanticSearchDocumentPojo>}
     * @memberof SemanticSearchResultPojo
     */
    'savedSearches'?: Array<SemanticSearchDocumentPojo>;
    /**
     * 
     * @type {Array<SemanticSearchDocumentPojo>}
     * @memberof SemanticSearchResultPojo
     */
    'documents'?: Array<SemanticSearchDocumentPojo>;
}
/**
 * 
 * @export
 * @interface ShowOnExportPage
 */
export interface ShowOnExportPage {
    /**
     * 
     * @type {boolean}
     * @memberof ShowOnExportPage
     */
    'show'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ShowOnExportPage
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ShowOnExportPage
     */
    'label'?: string;
}
/**
 * 
 * @export
 * @interface SortObject
 */
export interface SortObject {
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'empty'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'sorted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof SortObject
     */
    'unsorted'?: boolean;
}
/**
 * 
 * @export
 * @interface Source
 */
export interface Source {
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Source
     */
    'pathPattern'?: string;
    /**
     * 
     * @type {Candidate}
     * @memberof Source
     */
    'containedIn'?: Candidate;
}
/**
 * 
 * @export
 * @interface SourceLocation
 */
export interface SourceLocation {
    /**
     * 
     * @type {number}
     * @memberof SourceLocation
     */
    'moduleId'?: number;
    /**
     * 
     * @type {string}
     * @memberof SourceLocation
     */
    'moduleName'?: string;
    /**
     * 
     * @type {ModuleLocation}
     * @memberof SourceLocation
     */
    'moduleLocation'?: ModuleLocation;
}
/**
 * 
 * @export
 * @interface SourceMetricsPojo
 */
export interface SourceMetricsPojo {
    /**
     * 
     * @type {EntityId}
     * @memberof SourceMetricsPojo
     */
    'moduleEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof SourceMetricsPojo
     */
    'module'?: string;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'moduleId'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'physicalLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'codeLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'commentLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'complexityMcCabe'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojo
     */
    'deadCodeLines'?: number;
}
/**
 * 
 * @export
 * @interface SourceMetricsPojoPrototype
 */
export interface SourceMetricsPojoPrototype {
    /**
     * 
     * @type {EntityId}
     * @memberof SourceMetricsPojoPrototype
     */
    'module'?: EntityId;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojoPrototype
     */
    'physicalLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojoPrototype
     */
    'codeLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojoPrototype
     */
    'commentLines'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojoPrototype
     */
    'complexityMcCabe'?: number;
    /**
     * 
     * @type {number}
     * @memberof SourceMetricsPojoPrototype
     */
    'deadCodeLines'?: number;
}
/**
 * 
 * @export
 * @interface StatementNode
 */
export interface StatementNode extends DataFlowGraphNode {
}


/**
 * 
 * @export
 * @interface SubmitJobExtensionV2Request
 */
export interface SubmitJobExtensionV2Request {
    /**
     * 
     * @type {File}
     * @memberof SubmitJobExtensionV2Request
     */
    'file'?: File;
}
/**
 * 
 * @export
 * @interface Table
 */
export interface Table {
    /**
     * 
     * @type {string}
     * @memberof Table
     */
    'name'?: string;
    /**
     * 
     * @type {Array<Column>}
     * @memberof Table
     */
    'columns'?: Array<Column>;
    /**
     * 
     * @type {Array<Index>}
     * @memberof Table
     */
    'indices'?: Array<Index>;
    /**
     * 
     * @type {PrimaryKey}
     * @memberof Table
     */
    'primaryKey'?: PrimaryKey;
    /**
     * 
     * @type {Array<ForeignKey>}
     * @memberof Table
     */
    'foreignKeys'?: Array<ForeignKey>;
}
/**
 * 
 * @export
 * @interface Target
 */
export interface Target {
    /**
     * 
     * @type {string}
     * @memberof Target
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Target
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Target
     */
    'path'?: string;
    /**
     * 
     * @type {string}
     * @memberof Target
     */
    'pathPattern'?: string;
    /**
     * 
     * @type {ContainedIn}
     * @memberof Target
     */
    'parent'?: ContainedIn;
    /**
     * 
     * @type {Candidate}
     * @memberof Target
     */
    'containedIn'?: Candidate;
}
/**
 * 
 * @export
 * @interface TaxonomyAssignmentsGetRequest
 */
export interface TaxonomyAssignmentsGetRequest {
    /**
     * 
     * @type {ModuleMatcher}
     * @memberof TaxonomyAssignmentsGetRequest
     */
    'modules'?: ModuleMatcher;
}
/**
 * 
 * @export
 * @interface TaxonomyAssignmentsGetResponse
 */
export interface TaxonomyAssignmentsGetResponse {
    /**
     * 
     * @type {number}
     * @memberof TaxonomyAssignmentsGetResponse
     */
    'moduleCount'?: number;
    /**
     * 
     * @type {Array<TaxonomyGetAssignment>}
     * @memberof TaxonomyAssignmentsGetResponse
     */
    'taxonomies'?: Array<TaxonomyGetAssignment>;
}
/**
 * 
 * @export
 * @interface TaxonomyAssignmentsSetRequest
 */
export interface TaxonomyAssignmentsSetRequest {
    /**
     * 
     * @type {ModuleMatcher}
     * @memberof TaxonomyAssignmentsSetRequest
     */
    'modules'?: ModuleMatcher;
    /**
     * 
     * @type {Array<TaxonomySetAssignment>}
     * @memberof TaxonomyAssignmentsSetRequest
     */
    'taxonomies'?: Array<TaxonomySetAssignment>;
}
/**
 * 
 * @export
 * @interface TaxonomyCategoryPojo
 */
export interface TaxonomyCategoryPojo {
    /**
     * 
     * @type {number}
     * @memberof TaxonomyCategoryPojo
     */
    'id'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyCategoryPojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyCategoryPojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyCategoryPojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyCategoryPojo
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TaxonomyGetAssignment
 */
export interface TaxonomyGetAssignment {
    /**
     * 
     * @type {TaxonomyPojo}
     * @memberof TaxonomyGetAssignment
     */
    'taxonomy'?: TaxonomyPojo;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyGetAssignment
     */
    'state'?: TaxonomyGetAssignmentStateEnum;
}

export const TaxonomyGetAssignmentStateEnum = {
    ALL: 'ALL',
    SOME: 'SOME',
    NONE: 'NONE'
} as const;

export type TaxonomyGetAssignmentStateEnum = typeof TaxonomyGetAssignmentStateEnum[keyof typeof TaxonomyGetAssignmentStateEnum];

/**
 * 
 * @export
 * @interface TaxonomyPojo
 */
export interface TaxonomyPojo {
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojo
     */
    'uid'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyPojo
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyPojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyPojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {TaxonomyTypePojo}
     * @memberof TaxonomyPojo
     */
    'type'?: TaxonomyTypePojo;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojo
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyPojo
     */
    'taxonomyReferenceCount'?: number;
    /**
     * 
     * @type {ProjectPojoCustomProperties}
     * @memberof TaxonomyPojo
     */
    'customProperties'?: ProjectPojoCustomProperties;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyPojo
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface TaxonomyPojoPrototype
 */
export interface TaxonomyPojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojoPrototype
     */
    'uid'?: string;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof TaxonomyPojoPrototype
     */
    'customProperties'?: { [key: string]: object; };
    /**
     * 
     * @type {number}
     * @memberof TaxonomyPojoPrototype
     */
    'nid'?: number;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyPojoPrototype
     */
    'project'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojoPrototype
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyPojoPrototype
     */
    'name'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyPojoPrototype
     */
    'id'?: EntityId;
}
/**
 * 
 * @export
 * @interface TaxonomyReport
 */
export interface TaxonomyReport {
    /**
     * 
     * @type {ModulePojo}
     * @memberof TaxonomyReport
     */
    'module'?: ModulePojo;
    /**
     * 
     * @type {Array<TaxonomyPojo>}
     * @memberof TaxonomyReport
     */
    'taxonomies'?: Array<TaxonomyPojo>;
}
/**
 * 
 * @export
 * @interface TaxonomySetAssignment
 */
export interface TaxonomySetAssignment {
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomySetAssignment
     */
    'taxonomyId'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof TaxonomySetAssignment
     */
    'state'?: TaxonomySetAssignmentStateEnum;
}

export const TaxonomySetAssignmentStateEnum = {
    ALL: 'ALL',
    SOME: 'SOME',
    NONE: 'NONE'
} as const;

export type TaxonomySetAssignmentStateEnum = typeof TaxonomySetAssignmentStateEnum[keyof typeof TaxonomySetAssignmentStateEnum];

/**
 * 
 * @export
 * @interface TaxonomyTypePojo
 */
export interface TaxonomyTypePojo {
    /**
     * 
     * @type {string}
     * @memberof TaxonomyTypePojo
     */
    'id'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyTypePojo
     */
    'projectEntity'?: EntityId;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyTypePojo
     */
    'project'?: string;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyTypePojo
     */
    'projectId'?: number;
    /**
     * 
     * @type {TaxonomyCategoryPojo}
     * @memberof TaxonomyTypePojo
     */
    'category'?: TaxonomyCategoryPojo;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyTypePojo
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TaxonomyTypePojoPrototype
 */
export interface TaxonomyTypePojoPrototype {
    /**
     * 
     * @type {string}
     * @memberof TaxonomyTypePojoPrototype
     */
    'id'?: string;
    /**
     * 
     * @type {EntityId}
     * @memberof TaxonomyTypePojoPrototype
     */
    'project'?: EntityId;
    /**
     * 
     * @type {number}
     * @memberof TaxonomyTypePojoPrototype
     */
    'categoryId'?: number;
    /**
     * 
     * @type {string}
     * @memberof TaxonomyTypePojoPrototype
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TechnologyType
 */
export interface TechnologyType {
    /**
     * 
     * @type {string}
     * @memberof TechnologyType
     */
    'technology'?: TechnologyTypeTechnologyEnum;
    /**
     * 
     * @type {string}
     * @memberof TechnologyType
     */
    'type'?: TechnologyTypeTypeEnum;
}

export const TechnologyTypeTechnologyEnum = {
    COBOL: 'COBOL',
    NATURAL: 'NATURAL',
    PL1: 'PL1',
    JCL: 'JCL',
    ASSEMBLER: 'ASSEMBLER',
    RESOURCE: 'RESOURCE',
    CSD: 'CSD',
    NONE: 'NONE',
    UNKNOWN: 'UNKNOWN',
    XML: 'XML',
    BINARY: 'BINARY',
    EASYTRIEVE: 'EASYTRIEVE',
    IMS: 'IMS',
    C: 'C',
    CPP: 'CPP',
    VMS: 'VMS',
    ORACLE: 'ORACLE',
    SQL: 'SQL',
    JAVA: 'JAVA',
    ECL: 'ECL',
    CICS: 'CICS',
    SCHEDULER: 'SCHEDULER',
    BASIC: 'BASIC',
    VB: 'VB',
    WINDOWS: 'WINDOWS',
    SERVICE: 'SERVICE',
    MARK4: 'MARK4'
} as const;

export type TechnologyTypeTechnologyEnum = typeof TechnologyTypeTechnologyEnum[keyof typeof TechnologyTypeTechnologyEnum];
export const TechnologyTypeTypeEnum = {
    ADAPTER: 'ADAPTER',
    ADAPTVIEW: 'ADAPTVIEW',
    ALT_PCB: 'ALT_PCB',
    BMS_MAP: 'BMS_MAP',
    BMS_MAPSET: 'BMS_MAPSET',
    CDO_FILE: 'CDO_FILE',
    CDO_RECORD: 'CDO_RECORD',
    CFG: 'CFG',
    CLASS: 'CLASS',
    CONTROLCARD: 'CONTROLCARD',
    COPYBOOK: 'COPYBOOK',
    COPYCODE: 'COPYCODE',
    COPYLIB: 'COPYLIB',
    COPYPROC: 'COPYPROC',
    CPM: 'CPM',
    DBD: 'DBD',
    DBD_COMPRTN: 'DBD_COMPRTN',
    DBD_DATASET: 'DBD_DATASET',
    DBD_SEGMENT: 'DBD_SEGMENT',
    DCL: 'DCL',
    DDM: 'DDM',
    DIALOG: 'DIALOG',
    DIALOG_PRIV_RES: 'DIALOG_PRIV_RES',
    ERROR_MESSAGE: 'ERROR_MESSAGE',
    EXEC: 'EXEC',
    EXEC_PGM: 'EXEC_PGM',
    EXTRACT: 'EXTRACT',
    FILE: 'FILE',
    TPFDF_DATASET: 'TPFDF_DATASET',
    FMS_FORM: 'FMS_FORM',
    IFDL_FORM: 'IFDL_FORM',
    FUNCTION: 'FUNCTION',
    GDA: 'GDA',
    HDAMPARM: 'HDAMPARM',
    HEADER: 'HEADER',
    HELP: 'HELP',
    INCLUDE: 'INCLUDE',
    INDEX: 'INDEX',
    INFO: 'INFO',
    INLINE_PROC: 'INLINE_PROC',
    INSTREAM: 'INSTREAM',
    JOB: 'JOB',
    LDA: 'LDA',
    LIST: 'LIST',
    LISTCAT: 'LISTCAT',
    MACRO: 'MACRO',
    MACRO_FILE: 'MACRO_FILE',
    MAINPROGRAM: 'MAINPROGRAM',
    MAP: 'MAP',
    MFS: 'MFS',
    OBJECT: 'OBJECT',
    PCB: 'PCB',
    PDA: 'PDA',
    PSB: 'PSB',
    PGM: 'PGM',
    PROC: 'PROC',
    PROGRAM: 'PROGRAM',
    RDB_DATABASE: 'RDB_DATABASE',
    SCHEMA: 'SCHEMA',
    SCRIPT: 'SCRIPT',
    SQLMOD: 'SQLMOD',
    SQLMOD_PROCEDURE: 'SQLMOD_PROCEDURE',
    STORED_PROCEDURE: 'STORED_PROCEDURE',
    SUBPROGRAM: 'SUBPROGRAM',
    SUBROUTINE: 'SUBROUTINE',
    SYNONYM: 'SYNONYM',
    TABLE: 'TABLE',
    TDFXTRCT: 'TDFXTRCT',
    TDQ: 'TDQ',
    TEXT: 'TEXT',
    TRANSACTION: 'TRANSACTION',
    TRIGGER: 'TRIGGER',
    TSQ: 'TSQ',
    UNKNOWN: 'UNKNOWN',
    GDG_FILE: 'GDG_FILE',
    UTILITY: 'UTILITY',
    VAX_MACRO: 'VAX_MACRO',
    VAX_MACRO_ENTRY: 'VAX_MACRO_ENTRY',
    VIEW: 'VIEW',
    VSAM_FILE: 'VSAM_FILE',
    COMPILATION_UNIT: 'COMPILATION_UNIT',
    PACKAGE: 'PACKAGE',
    INTERFACE: 'INTERFACE',
    TYPE: 'TYPE',
    ENUM: 'ENUM',
    ANNOTATION: 'ANNOTATION',
    JSF: 'JSF',
    JSP: 'JSP',
    METHOD: 'METHOD',
    ECL_JOB: 'ECL_JOB',
    EXPORT: 'EXPORT',
    APPLICATION: 'APPLICATION',
    MID: 'MID',
    MOD: 'MOD',
    XHTML: 'XHTML',
    MODULE: 'MODULE',
    FORM: 'FORM',
    USER_CONTROL: 'USER_CONTROL',
    PROJECT: 'PROJECT',
    WORKSPACE: 'WORKSPACE',
    ACTIVEX_DOCUMENT: 'ACTIVEX_DOCUMENT',
    DESIGNER_FILE: 'DESIGNER_FILE',
    DLL: 'DLL',
    OCX: 'OCX',
    LIB: 'LIB',
    RECORD: 'RECORD',
    EVENT: 'EVENT',
    PROCESS: 'PROCESS',
    SERVICE_REQUEST_ID: 'SERVICE_REQUEST_ID',
    RAP_CONTROLCARD: 'RAP_CONTROLCARD'
} as const;

export type TechnologyTypeTypeEnum = typeof TechnologyTypeTypeEnum[keyof typeof TechnologyTypeTypeEnum];

/**
 * 
 * @export
 * @interface Trigger
 */
export interface Trigger {
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'tableName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'statement'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'eventTiming'?: string;
    /**
     * 
     * @type {string}
     * @memberof Trigger
     */
    'eventName'?: string;
}
/**
 * 
 * @export
 * @interface UniversalSearchLink
 */
export interface UniversalSearchLink {
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchLink
     */
    'type'?: UniversalSearchLinkTypeEnum;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof UniversalSearchLink
     */
    'properties'?: { [key: string]: string; };
}

export const UniversalSearchLinkTypeEnum = {
    MODULE_DETAILS: 'MODULE_DETAILS',
    CODE_VIEWER: 'CODE_VIEWER',
    DATA_DICTIONARY_TABLE: 'DATA_DICTIONARY_TABLE'
} as const;

export type UniversalSearchLinkTypeEnum = typeof UniversalSearchLinkTypeEnum[keyof typeof UniversalSearchLinkTypeEnum];

/**
 * 
 * @export
 * @interface UniversalSearchResult
 */
export interface UniversalSearchResult {
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchResult
     */
    'providedBy'?: string;
    /**
     * 
     * @type {number}
     * @memberof UniversalSearchResult
     */
    'rank'?: number;
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchResult
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchResult
     */
    'subTitle'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchResult
     */
    'context'?: string;
    /**
     * 
     * @type {string}
     * @memberof UniversalSearchResult
     */
    'type'?: string;
    /**
     * 
     * @type {Array<UniversalSearchLink>}
     * @memberof UniversalSearchResult
     */
    'links'?: Array<UniversalSearchLink>;
}
/**
 * 
 * @export
 * @interface UploadDescription
 */
export interface UploadDescription {
    /**
     * 
     * @type {string}
     * @memberof UploadDescription
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UploadDescription
     */
    'description'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadDescription
     */
    'required'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UploadDescription
     */
    'accept'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UploadDescription
     */
    'supported'?: boolean;
}
/**
 * 
 * @export
 * @interface UsagesModel
 */
export interface UsagesModel {
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'usages'?: UsagesModelUsagesEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'searchFilterAttributes'?: UsagesModelSearchFilterAttributesEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'sortByAttributes'?: UsagesModelSortByAttributesEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'viewModeAttributes'?: UsagesModelViewModeAttributesEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'tableAttributes'?: UsagesModelTableAttributesEnum;
    /**
     * 
     * @type {string}
     * @memberof UsagesModel
     */
    'editModeAttributes'?: UsagesModelEditModeAttributesEnum;
}

export const UsagesModelUsagesEnum = {
    graphql_query: 'graphql.query.',
    graphql_query_modules: 'graphql.query.modules',
    graphql_query_annotations: 'graphql.query.annotations',
    graphql_query_dataDictionaries: 'graphql.query.dataDictionaries',
    graphql_query_dnaModulesInCluster: 'graphql.query.dnaModulesInCluster',
    graphql_query_moduleDependencies: 'graphql.query.moduleDependencies',
    general_viewMode: 'general.viewMode',
    general_editMode: 'general.editMode',
    general_searchFilter: 'general.searchFilter',
    general_exportFormat_csv: 'general.exportFormat.csv',
    general_sortBy: 'general.sortBy',
    miningUi_moduleDetails: 'miningUi.moduleDetails',
    miningUi_modulesInDnaCluster: 'miningUi.modulesInDnaCluster',
    miningUi_modulesTable: 'miningUi.modulesTable',
    miningUi_annotationsTable: 'miningUi.annotationsTable',
    miningUi_reachabilityTable: 'miningUi.reachabilityTable',
    miningUi_graphMlExport: 'miningUi.graphMlExport',
    miningUi_dataDictionaryTable: 'miningUi.dataDictionaryTable',
    miningUi_customPropertiesTable: 'miningUi.customPropertiesTable',
    miningUi_tableColumnsTable: 'miningUi.tableColumnsTable',
    savedSearch_allTaxonomies: 'savedSearch.allTaxonomies',
    miningUi_dependenciesTable: 'miningUi.dependenciesTable',
    miningUi_chartDetailsModule: 'miningUi.chartDetailsModule',
    miningUi_chartDetailsSql: 'miningUi.chartDetailsSql',
    export_taxonomyAssignments: 'export.taxonomyAssignments'
} as const;

export type UsagesModelUsagesEnum = typeof UsagesModelUsagesEnum[keyof typeof UsagesModelUsagesEnum];
export const UsagesModelSearchFilterAttributesEnum = {
    filterMode: 'filterMode',
    text: 'text',
    number: 'number',
    multiSelect: 'multiSelect',
    customPropertyTag: 'customPropertyTag',
    rsqlFragment: 'rsqlFragment',
    sqlFragmentEq: 'sqlFragmentEq',
    sqlFragmentFalse: 'sqlFragmentFalse',
    sqlFragmentTrue: 'sqlFragmentTrue',
    sqlFragmentGte: 'sqlFragmentGte',
    sqlFragmentGt: 'sqlFragmentGt',
    sqlFragmentNone: 'sqlFragmentNone',
    sqlFragmentLte: 'sqlFragmentLte',
    sqlFragmentLt: 'sqlFragmentLt',
    sqlFragmentIn: 'sqlFragmentIn',
    Flags: 'Flags',
    toLowercase: 'toLowercase',
    beginsWith: 'beginsWith',
    endsWith: 'endsWith',
    escapeLucene: 'escapeLucene',
    multiSelectValueRetrievalMode: 'multiSelectValueRetrievalMode',
    annotationControllerAggregatedValues: 'annotationControllerAggregatedValues',
    moduleControllerAggregatedValues: 'moduleControllerAggregatedValues',
    moduleControllerDistinctFieldValues: 'moduleControllerDistinctFieldValues',
    taxonomyControllerAggregatedValues: 'taxonomyControllerAggregatedValues',
    multiSelectValueRetrievalFieldName: 'multiSelectValueRetrievalFieldName',
    multiSelectValueRetrievalKeyField: 'multiSelectValueRetrievalKeyField',
    multiSelectValueRetrievalFilter: 'multiSelectValueRetrievalFilter',
    dataDictionaryControllerAggregatedValues: 'dataDictionaryControllerAggregatedValues',
    showNoneOption: 'showNoneOption',
    referenceControllerAggregatedValues: 'referenceControllerAggregatedValues',
    fixedValues: 'fixedValues'
} as const;

export type UsagesModelSearchFilterAttributesEnum = typeof UsagesModelSearchFilterAttributesEnum[keyof typeof UsagesModelSearchFilterAttributesEnum];
export const UsagesModelSortByAttributesEnum = {
    sqlFragmentOrderBy: 'sqlFragmentOrderBy'
} as const;

export type UsagesModelSortByAttributesEnum = typeof UsagesModelSortByAttributesEnum[keyof typeof UsagesModelSortByAttributesEnum];
export const UsagesModelViewModeAttributesEnum = {
    displayAs: 'displayAs',
    HTML: 'HTML',
    link: 'link',
    date: 'date',
    tag: 'tag',
    linkOpenModal: 'linkOpenModal',
    linkTemplate: 'linkTemplate',
    togetherWith: 'togetherWith',
    labelMapping: 'labelMapping'
} as const;

export type UsagesModelViewModeAttributesEnum = typeof UsagesModelViewModeAttributesEnum[keyof typeof UsagesModelViewModeAttributesEnum];
export const UsagesModelTableAttributesEnum = {
    category: 'category',
    defaultColumnIndex: 'defaultColumnIndex',
    hiddenByDefault: 'hiddenByDefault'
} as const;

export type UsagesModelTableAttributesEnum = typeof UsagesModelTableAttributesEnum[keyof typeof UsagesModelTableAttributesEnum];
export const UsagesModelEditModeAttributesEnum = {
    editAs: 'editAs',
    text: 'text',
    textArea: 'textArea',
    editEndpoint: 'editEndpoint',
    editEndpointFieldName: 'editEndpointFieldName',
    togetherWith: 'togetherWith'
} as const;

export type UsagesModelEditModeAttributesEnum = typeof UsagesModelEditModeAttributesEnum[keyof typeof UsagesModelEditModeAttributesEnum];

/**
 * 
 * @export
 * @interface View
 */
export interface View {
    /**
     * 
     * @type {string}
     * @memberof View
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ViewColumn>}
     * @memberof View
     */
    'viewColumns'?: Array<ViewColumn>;
}
/**
 * 
 * @export
 * @interface ViewColumn
 */
export interface ViewColumn {
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ViewColumn
     */
    'targetColumn'?: string;
}
/**
 * 
 * @export
 * @interface WebUiExtensionDescription
 */
export interface WebUiExtensionDescription {
    /**
     * 
     * @type {string}
     * @memberof WebUiExtensionDescription
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebUiExtensionDescription
     */
    'pageIdentifier'?: string;
    /**
     * 
     * @type {string}
     * @memberof WebUiExtensionDescription
     */
    'kind'?: WebUiExtensionDescriptionKindEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebUiExtensionDescription
     */
    'hostElementStyleNames'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebUiExtensionDescription
     */
    'styleSheets'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof WebUiExtensionDescription
     */
    'scripts'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof WebUiExtensionDescription
     */
    'properties'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof WebUiExtensionDescription
     */
    'inlineStyles'?: string;
}

export const WebUiExtensionDescriptionKindEnum = {
    IFRAME: 'IFRAME'
} as const;

export type WebUiExtensionDescriptionKindEnum = typeof WebUiExtensionDescriptionKindEnum[keyof typeof WebUiExtensionDescriptionKindEnum];


/**
 * AnnotationCategoryControllerApi - axios parameter creator
 * @export
 */
export const AnnotationCategoryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new annotation category
         * @summary Create a new annotation category
         * @param {EntityId} projectId the project ID
         * @param {AnnotationCategory} annotationCategory The new annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationCategory: async (projectId: EntityId, annotationCategory: AnnotationCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createAnnotationCategory', 'projectId', projectId)
            // verify required parameter 'annotationCategory' is not null or undefined
            assertParamExists('createAnnotationCategory', 'annotationCategory', annotationCategory)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-categories`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  delete an annotation category
         * @summary delete an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationCategory: async (projectId: EntityId, annotationCategoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAnnotationCategory', 'projectId', projectId)
            // verify required parameter 'annotationCategoryId' is not null or undefined
            assertParamExists('deleteAnnotationCategory', 'annotationCategoryId', annotationCategoryId)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-categories/{annotationCategoryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationCategoryId"}}`, encodeURIComponent(String(annotationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all available annotation categories
         * @summary List all available annotation categories
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAnnotationCategories: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllAnnotationCategories', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-categories`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get an annotation category by id
         * @summary Get an annotation category by id
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationCategoryById: async (projectId: EntityId, annotationCategoryId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationCategoryById', 'projectId', projectId)
            // verify required parameter 'annotationCategoryId' is not null or undefined
            assertParamExists('findAnnotationCategoryById', 'annotationCategoryId', annotationCategoryId)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-categories/{annotationCategoryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationCategoryId"}}`, encodeURIComponent(String(annotationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update an annotation category
         * @summary Update an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to update
         * @param {AnnotationCategory} annotationCategory The updated annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationCategory: async (projectId: EntityId, annotationCategoryId: number, annotationCategory: AnnotationCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateAnnotationCategory', 'projectId', projectId)
            // verify required parameter 'annotationCategoryId' is not null or undefined
            assertParamExists('updateAnnotationCategory', 'annotationCategoryId', annotationCategoryId)
            // verify required parameter 'annotationCategory' is not null or undefined
            assertParamExists('updateAnnotationCategory', 'annotationCategory', annotationCategory)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-categories/{annotationCategoryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationCategoryId"}}`, encodeURIComponent(String(annotationCategoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationCategoryControllerApi - functional programming interface
 * @export
 */
export const AnnotationCategoryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationCategoryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new annotation category
         * @summary Create a new annotation category
         * @param {EntityId} projectId the project ID
         * @param {AnnotationCategory} annotationCategory The new annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnotationCategory(projectId: EntityId, annotationCategory: AnnotationCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnotationCategory(projectId, annotationCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  delete an annotation category
         * @summary delete an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotationCategory(projectId: EntityId, annotationCategoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnotationCategory(projectId, annotationCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all available annotation categories
         * @summary List all available annotation categories
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllAnnotationCategories(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationCategory>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllAnnotationCategories(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get an annotation category by id
         * @summary Get an annotation category by id
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationCategoryById(projectId: EntityId, annotationCategoryId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationCategoryById(projectId, annotationCategoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update an annotation category
         * @summary Update an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to update
         * @param {AnnotationCategory} annotationCategory The updated annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnotationCategory(projectId: EntityId, annotationCategoryId: number, annotationCategory: AnnotationCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationCategory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnotationCategory(projectId, annotationCategoryId, annotationCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationCategoryControllerApi - factory interface
 * @export
 */
export const AnnotationCategoryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationCategoryControllerApiFp(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new annotation category
         * @summary Create a new annotation category
         * @param {EntityId} projectId the project ID
         * @param {AnnotationCategory} annotationCategory The new annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotationCategory(projectId: EntityId, annotationCategory: AnnotationCategory, options?: any): AxiosPromise<AnnotationCategory> {
            return localVarFp.createAnnotationCategory(projectId, annotationCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  delete an annotation category
         * @summary delete an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotationCategory(projectId: EntityId, annotationCategoryId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAnnotationCategory(projectId, annotationCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all available annotation categories
         * @summary List all available annotation categories
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAnnotationCategories(projectId: EntityId, options?: any): AxiosPromise<Array<AnnotationCategory>> {
            return localVarFp.findAllAnnotationCategories(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get an annotation category by id
         * @summary Get an annotation category by id
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationCategoryById(projectId: EntityId, annotationCategoryId: number, options?: any): AxiosPromise<AnnotationCategory> {
            return localVarFp.findAnnotationCategoryById(projectId, annotationCategoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update an annotation category
         * @summary Update an annotation category
         * @param {EntityId} projectId the project ID
         * @param {number} annotationCategoryId the annotation category ID to update
         * @param {AnnotationCategory} annotationCategory The updated annotation category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationCategory(projectId: EntityId, annotationCategoryId: number, annotationCategory: AnnotationCategory, options?: any): AxiosPromise<AnnotationCategory> {
            return localVarFp.updateAnnotationCategory(projectId, annotationCategoryId, annotationCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationCategoryControllerApi - object-oriented interface
 * @export
 * @class AnnotationCategoryControllerApi
 * @extends {BaseAPI}
 */
export class AnnotationCategoryControllerApi extends BaseAPI {
    /**
     * User Role(s): manager | Project Nature(s): mining  Create a new annotation category
     * @summary Create a new annotation category
     * @param {EntityId} projectId the project ID
     * @param {AnnotationCategory} annotationCategory The new annotation category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationCategoryControllerApi
     */
    public createAnnotationCategory(projectId: EntityId, annotationCategory: AnnotationCategory, options?: AxiosRequestConfig) {
        return AnnotationCategoryControllerApiFp(this.configuration).createAnnotationCategory(projectId, annotationCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  delete an annotation category
     * @summary delete an annotation category
     * @param {EntityId} projectId the project ID
     * @param {number} annotationCategoryId the annotation category ID to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationCategoryControllerApi
     */
    public deleteAnnotationCategory(projectId: EntityId, annotationCategoryId: number, options?: AxiosRequestConfig) {
        return AnnotationCategoryControllerApiFp(this.configuration).deleteAnnotationCategory(projectId, annotationCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all available annotation categories
     * @summary List all available annotation categories
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationCategoryControllerApi
     */
    public findAllAnnotationCategories(projectId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationCategoryControllerApiFp(this.configuration).findAllAnnotationCategories(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get an annotation category by id
     * @summary Get an annotation category by id
     * @param {EntityId} projectId the project ID
     * @param {number} annotationCategoryId the annotation category ID to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationCategoryControllerApi
     */
    public findAnnotationCategoryById(projectId: EntityId, annotationCategoryId: number, options?: AxiosRequestConfig) {
        return AnnotationCategoryControllerApiFp(this.configuration).findAnnotationCategoryById(projectId, annotationCategoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Update an annotation category
     * @summary Update an annotation category
     * @param {EntityId} projectId the project ID
     * @param {number} annotationCategoryId the annotation category ID to update
     * @param {AnnotationCategory} annotationCategory The updated annotation category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationCategoryControllerApi
     */
    public updateAnnotationCategory(projectId: EntityId, annotationCategoryId: number, annotationCategory: AnnotationCategory, options?: AxiosRequestConfig) {
        return AnnotationCategoryControllerApiFp(this.configuration).updateAnnotationCategory(projectId, annotationCategoryId, annotationCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnotationControllerApi - axios parameter creator
 * @export
 */
export const AnnotationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Submits a job for bulk deletion of annotations or data dictionaries
         * @summary Submits a job for bulk deletion of annotations or data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {string} entityType The entity type to be deleted
         * @param {Array<EntityId>} entityId the ids to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeletion: async (projectId: EntityId, entityType: string, entityId: Array<EntityId>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('bulkDeletion', 'projectId', projectId)
            // verify required parameter 'entityType' is not null or undefined
            assertParamExists('bulkDeletion', 'entityType', entityType)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('bulkDeletion', 'entityId', entityId)
            const localVarPath = `/api/v1/projects/{projectId}/bulk-delete/{entityType}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"entityType"}}`, encodeURIComponent(String(entityType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new annotation
         * @summary Create a new annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The annotation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotation: async (projectId: EntityId, moduleId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createAnnotation', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('createAnnotation', 'moduleId', moduleId)
            // verify required parameter 'annotationPojoPrototype' is not null or undefined
            assertParamExists('createAnnotation', 'annotationPojoPrototype', annotationPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/annotations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete an annotation
         * @summary Delete an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the ID of the annotation to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation: async (projectId: EntityId, annotationId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAnnotation', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('deleteAnnotation', 'annotationId', annotationId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/{annotationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations
         * @summary Get all available annotations
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAnnotations: async (projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllAnnotations', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (modulename !== undefined) {
                localVarQueryParameter['modulename'] = modulename;
            }

            if (modulepath !== undefined) {
                localVarQueryParameter['modulepath'] = modulepath;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all distinct annotation types for a specific project
         * @summary List all distinct annotation types for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDistinctAnnotationTypes: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllDistinctAnnotationTypes', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of Annotation for a given module Based on Offset
         * @summary List of Annotation for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationBasedOnOffset: async (projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationBasedOnOffset', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAnnotationBasedOnOffset', 'moduleId', moduleId)
            // verify required parameter 'startOffset' is not null or undefined
            assertParamExists('findAnnotationBasedOnOffset', 'startOffset', startOffset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/annotations/byOffset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (startOffset !== undefined) {
                localVarQueryParameter['startOffset'] = startOffset;
            }

            if (endOffset !== undefined) {
                localVarQueryParameter['endOffset'] = endOffset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find an annotation by id
         * @summary Find an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationById: async (projectId: EntityId, annotationId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationById', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('findAnnotationById', 'annotationId', annotationId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/{annotationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find annotations by name
         * @summary Find annotations by name
         * @param {EntityId} projectId the project ID
         * @param {string} name the name to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsByName: async (projectId: EntityId, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationsByName', 'projectId', projectId)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('findAnnotationsByName', 'name', name)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  find annotations with given custom property assigned for a specific project
         * @summary find annotations with given custom property assigned for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {string} propertyName the name of the custom property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsWithCustomProperty: async (projectId: EntityId, propertyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationsWithCustomProperty', 'projectId', projectId)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('findAnnotationsWithCustomProperty', 'propertyName', propertyName)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-customProperty`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (propertyName !== undefined) {
                localVarQueryParameter['propertyName'] = propertyName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables of an annotation by id
         * @summary Find linked Business Variables of an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedBusinessVariablesById: async (projectId: EntityId, annotationId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findLinkedBusinessVariablesById', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('findLinkedBusinessVariablesById', 'annotationId', annotationId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/{annotationId}/linked-business-variables`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by an annotation id
         * @summary Find a module by an annotation id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleOfAnnotation: async (projectId: EntityId, annotationId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findModuleOfAnnotation', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('findModuleOfAnnotation', 'annotationId', annotationId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/{annotationId}/modules`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate meta description for a group of Annotations
         * @summary Generate meta description for a group of Annotations
         * @param {EntityId} projectId the ID of the project
         * @param {Array<EntityId>} annotationIds the IDs of the annotations
         * @param {boolean} [generateDescriptions] whether descriptions of annotations should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateGroupDescription: async (projectId: EntityId, annotationIds: Array<EntityId>, generateDescriptions?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('generateGroupDescription', 'projectId', projectId)
            // verify required parameter 'annotationIds' is not null or undefined
            assertParamExists('generateGroupDescription', 'annotationIds', annotationIds)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-groups/translate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (annotationIds) {
                localVarQueryParameter['annotationIds'] = annotationIds;
            }

            if (generateDescriptions !== undefined) {
                localVarQueryParameter['generateDescriptions'] = generateDescriptions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of annotations
         * @summary Get aggregated values over a number of annotations
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestAnnotationFieldName} aggregationRequestAnnotationFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues4: async (projectId: EntityId, aggregationRequestAnnotationFieldName: AggregationRequestAnnotationFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedValues4', 'projectId', projectId)
            // verify required parameter 'aggregationRequestAnnotationFieldName' is not null or undefined
            assertParamExists('getAggregatedValues4', 'aggregationRequestAnnotationFieldName', aggregationRequestAnnotationFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestAnnotationFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Get AI translated English meaning of the Annotation Source Code
         * @summary Get AI translated English meaning of the Annotation Source Code
         * @param {EntityId} projectId The ID of the project
         * @param {EntityId} moduleId The ID of the module
         * @param {GenAiAnnotationRequest} genAiAnnotationRequest The annotation information to translate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGptTranslation: async (projectId: EntityId, moduleId: EntityId, genAiAnnotationRequest: GenAiAnnotationRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getGptTranslation', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getGptTranslation', 'moduleId', moduleId)
            // verify required parameter 'genAiAnnotationRequest' is not null or undefined
            assertParamExists('getGptTranslation', 'genAiAnnotationRequest', genAiAnnotationRequest)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/annotations/translate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(genAiAnnotationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import annotations from a CSV file
         * @summary Import annotations from a CSV file
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAnnotations: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importAnnotations', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importAnnotations', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/import`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an annotation
         * @summary Update an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The updated annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotation: async (projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateAnnotation', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('updateAnnotation', 'annotationId', annotationId)
            // verify required parameter 'annotationPojoPrototype' is not null or undefined
            assertParamExists('updateAnnotation', 'annotationPojoPrototype', annotationPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/annotations/{annotationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {Array<AnnotationPojo>} annotationPojo The annotations to be updated
         * @param {string} [updateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryAndMetadataOfAnnotation: async (projectId: EntityId, annotationPojo: Array<AnnotationPojo>, updateType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateCategoryAndMetadataOfAnnotation', 'projectId', projectId)
            // verify required parameter 'annotationPojo' is not null or undefined
            assertParamExists('updateCategoryAndMetadataOfAnnotation', 'annotationPojo', annotationPojo)
            const localVarPath = `/api/v1/projects/{projectId}/annotations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (updateType !== undefined) {
                localVarQueryParameter['updateType'] = updateType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationPojo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationControllerApi - functional programming interface
 * @export
 */
export const AnnotationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Submits a job for bulk deletion of annotations or data dictionaries
         * @summary Submits a job for bulk deletion of annotations or data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {string} entityType The entity type to be deleted
         * @param {Array<EntityId>} entityId the ids to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkDeletion(projectId: EntityId, entityType: string, entityId: Array<EntityId>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkDeletion(projectId, entityType, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new annotation
         * @summary Create a new annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The annotation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnnotation(projectId: EntityId, moduleId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnnotation(projectId, moduleId, annotationPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete an annotation
         * @summary Delete an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the ID of the annotation to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAnnotation(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAnnotation(projectId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations
         * @summary Get all available annotations
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllAnnotations(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllAnnotations(projectId, states, categoryIds, modulename, modulepath, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all distinct annotation types for a specific project
         * @summary List all distinct annotation types for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDistinctAnnotationTypes(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDistinctAnnotationTypes(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of Annotation for a given module Based on Offset
         * @summary List of Annotation for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationBasedOnOffset(projectId, moduleId, startOffset, endOffset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find an annotation by id
         * @summary Find an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationById(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationById(projectId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find annotations by name
         * @summary Find annotations by name
         * @param {EntityId} projectId the project ID
         * @param {string} name the name to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationsByName(projectId: EntityId, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationsByName(projectId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  find annotations with given custom property assigned for a specific project
         * @summary find annotations with given custom property assigned for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {string} propertyName the name of the custom property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationsWithCustomProperty(projectId: EntityId, propertyName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationsWithCustomProperty(projectId, propertyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables of an annotation by id
         * @summary Find linked Business Variables of an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLinkedBusinessVariablesById(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLinkedBusinessVariablesById(projectId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by an annotation id
         * @summary Find a module by an annotation id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findModuleOfAnnotation(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findModuleOfAnnotation(projectId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate meta description for a group of Annotations
         * @summary Generate meta description for a group of Annotations
         * @param {EntityId} projectId the ID of the project
         * @param {Array<EntityId>} annotationIds the IDs of the annotations
         * @param {boolean} [generateDescriptions] whether descriptions of annotations should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateGroupDescription(projectId: EntityId, annotationIds: Array<EntityId>, generateDescriptions?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateGroupDescription(projectId, annotationIds, generateDescriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of annotations
         * @summary Get aggregated values over a number of annotations
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestAnnotationFieldName} aggregationRequestAnnotationFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedValues4(projectId: EntityId, aggregationRequestAnnotationFieldName: AggregationRequestAnnotationFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultAnnotationFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedValues4(projectId, aggregationRequestAnnotationFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Get AI translated English meaning of the Annotation Source Code
         * @summary Get AI translated English meaning of the Annotation Source Code
         * @param {EntityId} projectId The ID of the project
         * @param {EntityId} moduleId The ID of the module
         * @param {GenAiAnnotationRequest} genAiAnnotationRequest The annotation information to translate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGptTranslation(projectId: EntityId, moduleId: EntityId, genAiAnnotationRequest: GenAiAnnotationRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGptTranslation(projectId, moduleId, genAiAnnotationRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import annotations from a CSV file
         * @summary Import annotations from a CSV file
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importAnnotations(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAnnotations(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an annotation
         * @summary Update an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The updated annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnotation(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnotation(projectId, annotationId, annotationPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {Array<AnnotationPojo>} annotationPojo The annotations to be updated
         * @param {string} [updateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCategoryAndMetadataOfAnnotation(projectId: EntityId, annotationPojo: Array<AnnotationPojo>, updateType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCategoryAndMetadataOfAnnotation(projectId, annotationPojo, updateType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationControllerApi - factory interface
 * @export
 */
export const AnnotationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Submits a job for bulk deletion of annotations or data dictionaries
         * @summary Submits a job for bulk deletion of annotations or data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {string} entityType The entity type to be deleted
         * @param {Array<EntityId>} entityId the ids to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkDeletion(projectId: EntityId, entityType: string, entityId: Array<EntityId>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.bulkDeletion(projectId, entityType, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new annotation
         * @summary Create a new annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The annotation to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnnotation(projectId: EntityId, moduleId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: any): AxiosPromise<AnnotationPojo> {
            return localVarFp.createAnnotation(projectId, moduleId, annotationPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete an annotation
         * @summary Delete an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the ID of the annotation to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAnnotation(projectId: EntityId, annotationId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAnnotation(projectId, annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations
         * @summary Get all available annotations
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllAnnotations(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, options?: any): AxiosPromise<Array<AnnotationPojo>> {
            return localVarFp.findAllAnnotations(projectId, states, categoryIds, modulename, modulepath, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all distinct annotation types for a specific project
         * @summary List all distinct annotation types for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDistinctAnnotationTypes(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findAllDistinctAnnotationTypes(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of Annotation for a given module Based on Offset
         * @summary List of Annotation for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: any): AxiosPromise<Array<AnnotationPojo>> {
            return localVarFp.findAnnotationBasedOnOffset(projectId, moduleId, startOffset, endOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find an annotation by id
         * @summary Find an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationById(projectId: EntityId, annotationId: EntityId, options?: any): AxiosPromise<AnnotationPojo> {
            return localVarFp.findAnnotationById(projectId, annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find annotations by name
         * @summary Find annotations by name
         * @param {EntityId} projectId the project ID
         * @param {string} name the name to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsByName(projectId: EntityId, name: string, options?: any): AxiosPromise<Array<AnnotationPojo>> {
            return localVarFp.findAnnotationsByName(projectId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  find annotations with given custom property assigned for a specific project
         * @summary find annotations with given custom property assigned for a specific project
         * @param {EntityId} projectId the ID of the project
         * @param {string} propertyName the name of the custom property
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsWithCustomProperty(projectId: EntityId, propertyName: string, options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.findAnnotationsWithCustomProperty(projectId, propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables of an annotation by id
         * @summary Find linked Business Variables of an annotation by id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedBusinessVariablesById(projectId: EntityId, annotationId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.findLinkedBusinessVariablesById(projectId, annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by an annotation id
         * @summary Find a module by an annotation id
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleOfAnnotation(projectId: EntityId, annotationId: EntityId, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.findModuleOfAnnotation(projectId, annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate meta description for a group of Annotations
         * @summary Generate meta description for a group of Annotations
         * @param {EntityId} projectId the ID of the project
         * @param {Array<EntityId>} annotationIds the IDs of the annotations
         * @param {boolean} [generateDescriptions] whether descriptions of annotations should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateGroupDescription(projectId: EntityId, annotationIds: Array<EntityId>, generateDescriptions?: boolean, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.generateGroupDescription(projectId, annotationIds, generateDescriptions, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of annotations
         * @summary Get aggregated values over a number of annotations
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestAnnotationFieldName} aggregationRequestAnnotationFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues4(projectId: EntityId, aggregationRequestAnnotationFieldName: AggregationRequestAnnotationFieldName, options?: any): AxiosPromise<Array<AggregationResultAnnotationFieldName>> {
            return localVarFp.getAggregatedValues4(projectId, aggregationRequestAnnotationFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Get AI translated English meaning of the Annotation Source Code
         * @summary Get AI translated English meaning of the Annotation Source Code
         * @param {EntityId} projectId The ID of the project
         * @param {EntityId} moduleId The ID of the module
         * @param {GenAiAnnotationRequest} genAiAnnotationRequest The annotation information to translate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGptTranslation(projectId: EntityId, moduleId: EntityId, genAiAnnotationRequest: GenAiAnnotationRequest, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getGptTranslation(projectId, moduleId, genAiAnnotationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import annotations from a CSV file
         * @summary Import annotations from a CSV file
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAnnotations(projectId: EntityId, file: File, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.importAnnotations(projectId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an annotation
         * @summary Update an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype The updated annotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotation(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: any): AxiosPromise<AnnotationPojo> {
            return localVarFp.updateAnnotation(projectId, annotationId, annotationPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {Array<AnnotationPojo>} annotationPojo The annotations to be updated
         * @param {string} [updateType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategoryAndMetadataOfAnnotation(projectId: EntityId, annotationPojo: Array<AnnotationPojo>, updateType?: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.updateCategoryAndMetadataOfAnnotation(projectId, annotationPojo, updateType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationControllerApi - object-oriented interface
 * @export
 * @class AnnotationControllerApi
 * @extends {BaseAPI}
 */
export class AnnotationControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Submits a job for bulk deletion of annotations or data dictionaries
     * @summary Submits a job for bulk deletion of annotations or data dictionaries
     * @param {EntityId} projectId the ID of the project
     * @param {string} entityType The entity type to be deleted
     * @param {Array<EntityId>} entityId the ids to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public bulkDeletion(projectId: EntityId, entityType: string, entityId: Array<EntityId>, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).bulkDeletion(projectId, entityType, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Create a new annotation
     * @summary Create a new annotation
     * @param {EntityId} projectId the project ID
     * @param {EntityId} moduleId the module ID
     * @param {AnnotationPojoPrototype} annotationPojoPrototype The annotation to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public createAnnotation(projectId: EntityId, moduleId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).createAnnotation(projectId, moduleId, annotationPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Delete an annotation
     * @summary Delete an annotation
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the ID of the annotation to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public deleteAnnotation(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).deleteAnnotation(projectId, annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all available annotations
     * @summary Get all available annotations
     * @param {EntityId} projectId the project ID
     * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
     * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
     * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
     * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAllAnnotations(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAllAnnotations(projectId, states, categoryIds, modulename, modulepath, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all distinct annotation types for a specific project
     * @summary List all distinct annotation types for a specific project
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAllDistinctAnnotationTypes(projectId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAllDistinctAnnotationTypes(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List of Annotation for a given module Based on Offset
     * @summary List of Annotation for a given module Based on Offset
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} startOffset the Start Offset of Module
     * @param {number} [endOffset] the End Offset of Module (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAnnotationBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAnnotationBasedOnOffset(projectId, moduleId, startOffset, endOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find an annotation by id
     * @summary Find an annotation by id
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the annotation ID to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAnnotationById(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAnnotationById(projectId, annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find annotations by name
     * @summary Find annotations by name
     * @param {EntityId} projectId the project ID
     * @param {string} name the name to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAnnotationsByName(projectId: EntityId, name: string, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAnnotationsByName(projectId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  find annotations with given custom property assigned for a specific project
     * @summary find annotations with given custom property assigned for a specific project
     * @param {EntityId} projectId the ID of the project
     * @param {string} propertyName the name of the custom property
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findAnnotationsWithCustomProperty(projectId: EntityId, propertyName: string, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findAnnotationsWithCustomProperty(projectId, propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables of an annotation by id
     * @summary Find linked Business Variables of an annotation by id
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the annotation ID to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findLinkedBusinessVariablesById(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findLinkedBusinessVariablesById(projectId, annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find a module by an annotation id
     * @summary Find a module by an annotation id
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the annotation ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public findModuleOfAnnotation(projectId: EntityId, annotationId: EntityId, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).findModuleOfAnnotation(projectId, annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Generate meta description for a group of Annotations
     * @summary Generate meta description for a group of Annotations
     * @param {EntityId} projectId the ID of the project
     * @param {Array<EntityId>} annotationIds the IDs of the annotations
     * @param {boolean} [generateDescriptions] whether descriptions of annotations should be generated automatically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public generateGroupDescription(projectId: EntityId, annotationIds: Array<EntityId>, generateDescriptions?: boolean, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).generateGroupDescription(projectId, annotationIds, generateDescriptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of annotations
     * @summary Get aggregated values over a number of annotations
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestAnnotationFieldName} aggregationRequestAnnotationFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public getAggregatedValues4(projectId: EntityId, aggregationRequestAnnotationFieldName: AggregationRequestAnnotationFieldName, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).getAggregatedValues4(projectId, aggregationRequestAnnotationFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Get AI translated English meaning of the Annotation Source Code
     * @summary Get AI translated English meaning of the Annotation Source Code
     * @param {EntityId} projectId The ID of the project
     * @param {EntityId} moduleId The ID of the module
     * @param {GenAiAnnotationRequest} genAiAnnotationRequest The annotation information to translate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public getGptTranslation(projectId: EntityId, moduleId: EntityId, genAiAnnotationRequest: GenAiAnnotationRequest, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).getGptTranslation(projectId, moduleId, genAiAnnotationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Import annotations from a CSV file
     * @summary Import annotations from a CSV file
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public importAnnotations(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).importAnnotations(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update an annotation
     * @summary Update an annotation
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the annotation ID of the annotation to update
     * @param {AnnotationPojoPrototype} annotationPojoPrototype The updated annotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public updateAnnotation(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).updateAnnotation(projectId, annotationId, annotationPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
     * @summary Starts a job that updates Annotation categories, metadata and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
     * @param {EntityId} projectId the project ID
     * @param {Array<AnnotationPojo>} annotationPojo The annotations to be updated
     * @param {string} [updateType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationControllerApi
     */
    public updateCategoryAndMetadataOfAnnotation(projectId: EntityId, annotationPojo: Array<AnnotationPojo>, updateType?: string, options?: AxiosRequestConfig) {
        return AnnotationControllerApiFp(this.configuration).updateCategoryAndMetadataOfAnnotation(projectId, annotationPojo, updateType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnotationReportingControllerApi - axios parameter creator
 * @export
 */
export const AnnotationReportingControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations for given search criteria
         * @summary Get all available annotations for given search criteria
         * @param {EntityId} projectId the ID of the project to search
         * @param {AnnotationReportSearchParameter} annotationReportSearchParameter search conditions for annotation reporting
         * @param {boolean} [hasLimit] has limit for resultset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationReport: async (projectId: EntityId, annotationReportSearchParameter: AnnotationReportSearchParameter, hasLimit?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAnnotationReport', 'projectId', projectId)
            // verify required parameter 'annotationReportSearchParameter' is not null or undefined
            assertParamExists('getAnnotationReport', 'annotationReportSearchParameter', annotationReportSearchParameter)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-reporting`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (hasLimit !== undefined) {
                localVarQueryParameter['hasLimit'] = hasLimit;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationReportSearchParameter, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationReportingControllerApi - functional programming interface
 * @export
 */
export const AnnotationReportingControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationReportingControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations for given search criteria
         * @summary Get all available annotations for given search criteria
         * @param {EntityId} projectId the ID of the project to search
         * @param {AnnotationReportSearchParameter} annotationReportSearchParameter search conditions for annotation reporting
         * @param {boolean} [hasLimit] has limit for resultset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAnnotationReport(projectId: EntityId, annotationReportSearchParameter: AnnotationReportSearchParameter, hasLimit?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationReportResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAnnotationReport(projectId, annotationReportSearchParameter, hasLimit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationReportingControllerApi - factory interface
 * @export
 */
export const AnnotationReportingControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationReportingControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all available annotations for given search criteria
         * @summary Get all available annotations for given search criteria
         * @param {EntityId} projectId the ID of the project to search
         * @param {AnnotationReportSearchParameter} annotationReportSearchParameter search conditions for annotation reporting
         * @param {boolean} [hasLimit] has limit for resultset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAnnotationReport(projectId: EntityId, annotationReportSearchParameter: AnnotationReportSearchParameter, hasLimit?: boolean, options?: any): AxiosPromise<AnnotationReportResponse> {
            return localVarFp.getAnnotationReport(projectId, annotationReportSearchParameter, hasLimit, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationReportingControllerApi - object-oriented interface
 * @export
 * @class AnnotationReportingControllerApi
 * @extends {BaseAPI}
 */
export class AnnotationReportingControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all available annotations for given search criteria
     * @summary Get all available annotations for given search criteria
     * @param {EntityId} projectId the ID of the project to search
     * @param {AnnotationReportSearchParameter} annotationReportSearchParameter search conditions for annotation reporting
     * @param {boolean} [hasLimit] has limit for resultset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationReportingControllerApi
     */
    public getAnnotationReport(projectId: EntityId, annotationReportSearchParameter: AnnotationReportSearchParameter, hasLimit?: boolean, options?: AxiosRequestConfig) {
        return AnnotationReportingControllerApiFp(this.configuration).getAnnotationReport(projectId, annotationReportSearchParameter, hasLimit, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnotationSearchControllerApi - axios parameter creator
 * @export
 */
export const AnnotationSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all Annotations for the Annotation Search View
         * @summary Find all Annotations for the Annotation Search View
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {number} [size] the size of the resulting list, if not specified the result size is unbounded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllForAnnotationSearchView: async (projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllForAnnotationSearchView', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (states !== undefined) {
                localVarQueryParameter['states'] = states;
            }

            if (categoryIds !== undefined) {
                localVarQueryParameter['categoryIds'] = categoryIds;
            }

            if (modulename !== undefined) {
                localVarQueryParameter['modulename'] = modulename;
            }

            if (modulepath !== undefined) {
                localVarQueryParameter['modulepath'] = modulepath;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the state of an annotation
         * @summary Update the state of an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype the annotation for which the state will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationState: async (projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateAnnotationState', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('updateAnnotationState', 'annotationId', annotationId)
            // verify required parameter 'annotationPojoPrototype' is not null or undefined
            assertParamExists('updateAnnotationState', 'annotationPojoPrototype', annotationPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/annotation-search/{annotationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(annotationPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationSearchControllerApi - functional programming interface
 * @export
 */
export const AnnotationSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all Annotations for the Annotation Search View
         * @summary Find all Annotations for the Annotation Search View
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {number} [size] the size of the resulting list, if not specified the result size is unbounded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllForAnnotationSearchView(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AnnotationSearch>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllForAnnotationSearchView(projectId, states, categoryIds, modulename, modulepath, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the state of an annotation
         * @summary Update the state of an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype the annotation for which the state will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAnnotationState(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAnnotationState(projectId, annotationId, annotationPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationSearchControllerApi - factory interface
 * @export
 */
export const AnnotationSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationSearchControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all Annotations for the Annotation Search View
         * @summary Find all Annotations for the Annotation Search View
         * @param {EntityId} projectId the project ID
         * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
         * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
         * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
         * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
         * @param {number} [size] the size of the resulting list, if not specified the result size is unbounded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllForAnnotationSearchView(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, size?: number, options?: any): AxiosPromise<AnnotationSearch> {
            return localVarFp.findAllForAnnotationSearchView(projectId, states, categoryIds, modulename, modulepath, size, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the state of an annotation
         * @summary Update the state of an annotation
         * @param {EntityId} projectId the project ID
         * @param {EntityId} annotationId the annotation ID of the annotation to update
         * @param {AnnotationPojoPrototype} annotationPojoPrototype the annotation for which the state will be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAnnotationState(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: any): AxiosPromise<void> {
            return localVarFp.updateAnnotationState(projectId, annotationId, annotationPojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationSearchControllerApi - object-oriented interface
 * @export
 * @class AnnotationSearchControllerApi
 * @extends {BaseAPI}
 */
export class AnnotationSearchControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Find all Annotations for the Annotation Search View
     * @summary Find all Annotations for the Annotation Search View
     * @param {EntityId} projectId the project ID
     * @param {string} [states] JSON representation of the states for the returned annotations, omitting returns annotations for all states, e.g. [CANDIDATE, IN_ANALYSIS, APPROVED]
     * @param {string} [categoryIds] JSON representation of the category IDs for the returned annotations, omitting returns annotations for all categories e.g. [1, 5, 30]
     * @param {string} [modulename] restrict returned annotations to those having modules, where the module name matches this wildcard pattern, omitting returns annotations for all modules, e.g. mod?ule*01
     * @param {string} [modulepath] restrict returned annotations to those having modules, where the module path equals the given path
     * @param {number} [size] the size of the resulting list, if not specified the result size is unbounded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationSearchControllerApi
     */
    public findAllForAnnotationSearchView(projectId: EntityId, states?: string, categoryIds?: string, modulename?: string, modulepath?: string, size?: number, options?: AxiosRequestConfig) {
        return AnnotationSearchControllerApiFp(this.configuration).findAllForAnnotationSearchView(projectId, states, categoryIds, modulename, modulepath, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update the state of an annotation
     * @summary Update the state of an annotation
     * @param {EntityId} projectId the project ID
     * @param {EntityId} annotationId the annotation ID of the annotation to update
     * @param {AnnotationPojoPrototype} annotationPojoPrototype the annotation for which the state will be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationSearchControllerApi
     */
    public updateAnnotationState(projectId: EntityId, annotationId: EntityId, annotationPojoPrototype: AnnotationPojoPrototype, options?: AxiosRequestConfig) {
        return AnnotationSearchControllerApiFp(this.configuration).updateAnnotationState(projectId, annotationId, annotationPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AnnotationToFunctionalBlockControllerApi - axios parameter creator
 * @export
 */
export const AnnotationToFunctionalBlockControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the Functional Block Names By Annotation Id
         * @summary Returns the Functional Block Names By Annotation Id
         * @param {number} projectId the project ID
         * @param {number} annotationId the annotation ID to fetch the functional blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockNamesByAnnotationId: async (projectId: number, annotationId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFunctionalBlockNamesByAnnotationId', 'projectId', projectId)
            // verify required parameter 'annotationId' is not null or undefined
            assertParamExists('getFunctionalBlockNamesByAnnotationId', 'annotationId', annotationId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations-to-functional-blocks/{annotationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"annotationId"}}`, encodeURIComponent(String(annotationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the functional groups which contain the given Annotations
         * @summary Returns the functional groups which contain the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalGroupsForAnnotations: async (projectId: EntityId, entityId: Array<EntityId>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFunctionalGroupsForAnnotations', 'projectId', projectId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getFunctionalGroupsForAnnotations', 'entityId', entityId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations-to-functional-blocks/functional-groups`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get the functional units which represent the given Annotations
         * @summary Get the functional units which represent the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalUnitsForAnnotations: async (projectId: EntityId, entityId: Array<EntityId>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFunctionalUnitsForAnnotations', 'projectId', projectId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('getFunctionalUnitsForAnnotations', 'entityId', entityId)
            const localVarPath = `/api/v1/projects/{projectId}/annotations-to-functional-blocks/functional-units`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnnotationToFunctionalBlockControllerApi - functional programming interface
 * @export
 */
export const AnnotationToFunctionalBlockControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnnotationToFunctionalBlockControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the Functional Block Names By Annotation Id
         * @summary Returns the Functional Block Names By Annotation Id
         * @param {number} projectId the project ID
         * @param {number} annotationId the annotation ID to fetch the functional blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionalBlockNamesByAnnotationId(projectId: number, annotationId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionalBlockNamesByAnnotationId(projectId, annotationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the functional groups which contain the given Annotations
         * @summary Returns the functional groups which contain the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionalGroupsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionalGroupsForAnnotations(projectId, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get the functional units which represent the given Annotations
         * @summary Get the functional units which represent the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionalUnitsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionalUnitsForAnnotations(projectId, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnnotationToFunctionalBlockControllerApi - factory interface
 * @export
 */
export const AnnotationToFunctionalBlockControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnnotationToFunctionalBlockControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the Functional Block Names By Annotation Id
         * @summary Returns the Functional Block Names By Annotation Id
         * @param {number} projectId the project ID
         * @param {number} annotationId the annotation ID to fetch the functional blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockNamesByAnnotationId(projectId: number, annotationId: number, options?: any): AxiosPromise<Set<string>> {
            return localVarFp.getFunctionalBlockNamesByAnnotationId(projectId, annotationId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the functional groups which contain the given Annotations
         * @summary Returns the functional groups which contain the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalGroupsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: any): AxiosPromise<void> {
            return localVarFp.getFunctionalGroupsForAnnotations(projectId, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get the functional units which represent the given Annotations
         * @summary Get the functional units which represent the given Annotations
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId List of annotations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalUnitsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: any): AxiosPromise<void> {
            return localVarFp.getFunctionalUnitsForAnnotations(projectId, entityId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnnotationToFunctionalBlockControllerApi - object-oriented interface
 * @export
 * @class AnnotationToFunctionalBlockControllerApi
 * @extends {BaseAPI}
 */
export class AnnotationToFunctionalBlockControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Returns the Functional Block Names By Annotation Id
     * @summary Returns the Functional Block Names By Annotation Id
     * @param {number} projectId the project ID
     * @param {number} annotationId the annotation ID to fetch the functional blocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationToFunctionalBlockControllerApi
     */
    public getFunctionalBlockNamesByAnnotationId(projectId: number, annotationId: number, options?: AxiosRequestConfig) {
        return AnnotationToFunctionalBlockControllerApiFp(this.configuration).getFunctionalBlockNamesByAnnotationId(projectId, annotationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Returns the functional groups which contain the given Annotations
     * @summary Returns the functional groups which contain the given Annotations
     * @param {EntityId} projectId the project ID
     * @param {Array<EntityId>} entityId List of annotations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationToFunctionalBlockControllerApi
     */
    public getFunctionalGroupsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig) {
        return AnnotationToFunctionalBlockControllerApiFp(this.configuration).getFunctionalGroupsForAnnotations(projectId, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get the functional units which represent the given Annotations
     * @summary Get the functional units which represent the given Annotations
     * @param {EntityId} projectId the project ID
     * @param {Array<EntityId>} entityId List of annotations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnnotationToFunctionalBlockControllerApi
     */
    public getFunctionalUnitsForAnnotations(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig) {
        return AnnotationToFunctionalBlockControllerApiFp(this.configuration).getFunctionalUnitsForAnnotations(projectId, entityId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthControllerApi - axios parameter creator
 * @export
 */
export const AuthControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete a certain stored token of the current user by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteToken', 'id', id)
            const localVarPath = `/api/v1/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve a certain stored token by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getToken', 'id', id)
            const localVarPath = `/api/v1/auth/token/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Retrieve all tokens stored for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Initiate a new OAuth offline token request
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initOffline: async (requestBody: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('initOffline', 'requestBody', requestBody)
            const localVarPath = `/api/v1/auth/offline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get information about the current session, start a new one if not authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Test if an access token can be obtained using a stored refresh token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        probeToken: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('probeToken', 'id', id)
            const localVarPath = `/api/v1/auth/token/{id}/probe`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Perform the redirect cycle for obtaining an OAuth offline refresh token
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOffline: async (state: string, code: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'state' is not null or undefined
            assertParamExists('redirectOffline', 'state', state)
            // verify required parameter 'code' is not null or undefined
            assertParamExists('redirectOffline', 'code', code)
            const localVarPath = `/api/v1/auth/offline`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Ensure session is authorized (possibly redirecting to Keycloak) and then redirect to to the UI.
         * @param {string} [context] Fragment to append to the redirection URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectUI: async (context?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/auth/ui`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (context !== undefined) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Invalidate session and redirect to root (for Keycloak JS adapter compatibility)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ssoLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sso/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a certain stored token of the current user
         * @param {OfflineTokenInfo} offlineTokenInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken: async (offlineTokenInfo: OfflineTokenInfo, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'offlineTokenInfo' is not null or undefined
            assertParamExists('updateToken', 'offlineTokenInfo', offlineTokenInfo)
            const localVarPath = `/api/v1/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(offlineTokenInfo, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthControllerApi - functional programming interface
 * @export
 */
export const AuthControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete a certain stored token of the current user by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve a certain stored token by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OfflineTokenInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Retrieve all tokens stored for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokens(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OfflineTokenInfo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokens(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Initiate a new OAuth offline token request
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async initOffline(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.initOffline(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get information about the current session, start a new one if not authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async login(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.login(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidate the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Test if an access token can be obtained using a stored refresh token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async probeToken(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.probeToken(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Perform the redirect cycle for obtaining an OAuth offline refresh token
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectOffline(state: string, code: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectOffline(state, code, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Ensure session is authorized (possibly redirecting to Keycloak) and then redirect to to the UI.
         * @param {string} [context] Fragment to append to the redirection URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectUI(context?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectUI(context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Invalidate session and redirect to root (for Keycloak JS adapter compatibility)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async ssoLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RedirectView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ssoLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a certain stored token of the current user
         * @param {OfflineTokenInfo} offlineTokenInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateToken(offlineTokenInfo: OfflineTokenInfo, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateToken(offlineTokenInfo, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthControllerApi - factory interface
 * @export
 */
export const AuthControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete a certain stored token of the current user by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToken(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve a certain stored token by its ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getToken(id: string, options?: any): AxiosPromise<OfflineTokenInfo> {
            return localVarFp.getToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Retrieve all tokens stored for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokens(options?: any): AxiosPromise<Array<OfflineTokenInfo>> {
            return localVarFp.getTokens(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Initiate a new OAuth offline token request
         * @param {{ [key: string]: string; }} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        initOffline(requestBody: { [key: string]: string; }, options?: any): AxiosPromise<string> {
            return localVarFp.initOffline(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get information about the current session, start a new one if not authenticated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        login(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.login(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidate the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Test if an access token can be obtained using a stored refresh token
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        probeToken(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.probeToken(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Perform the redirect cycle for obtaining an OAuth offline refresh token
         * @param {string} state 
         * @param {string} code 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectOffline(state: string, code: string, options?: any): AxiosPromise<RedirectView> {
            return localVarFp.redirectOffline(state, code, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Ensure session is authorized (possibly redirecting to Keycloak) and then redirect to to the UI.
         * @param {string} [context] Fragment to append to the redirection URI.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectUI(context?: string, options?: any): AxiosPromise<RedirectView> {
            return localVarFp.redirectUI(context, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Invalidate session and redirect to root (for Keycloak JS adapter compatibility)
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        ssoLogout(options?: any): AxiosPromise<RedirectView> {
            return localVarFp.ssoLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a certain stored token of the current user
         * @param {OfflineTokenInfo} offlineTokenInfo 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateToken(offlineTokenInfo: OfflineTokenInfo, options?: any): AxiosPromise<void> {
            return localVarFp.updateToken(offlineTokenInfo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthControllerApi - object-oriented interface
 * @export
 * @class AuthControllerApi
 * @extends {BaseAPI}
 */
export class AuthControllerApi extends BaseAPI {
    /**
     * 
     * @summary Delete a certain stored token of the current user by its ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public deleteToken(id: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).deleteToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve a certain stored token by its ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public getToken(id: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).getToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Retrieve all tokens stored for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public getTokens(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).getTokens(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Initiate a new OAuth offline token request
     * @param {{ [key: string]: string; }} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public initOffline(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).initOffline(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get information about the current session, start a new one if not authenticated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public login(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).login(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidate the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Test if an access token can be obtained using a stored refresh token
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public probeToken(id: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).probeToken(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Perform the redirect cycle for obtaining an OAuth offline refresh token
     * @param {string} state 
     * @param {string} code 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public redirectOffline(state: string, code: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).redirectOffline(state, code, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Ensure session is authorized (possibly redirecting to Keycloak) and then redirect to to the UI.
     * @param {string} [context] Fragment to append to the redirection URI.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public redirectUI(context?: string, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).redirectUI(context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Invalidate session and redirect to root (for Keycloak JS adapter compatibility)
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public ssoLogout(options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).ssoLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a certain stored token of the current user
     * @param {OfflineTokenInfo} offlineTokenInfo 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthControllerApi
     */
    public updateToken(offlineTokenInfo: OfflineTokenInfo, options?: AxiosRequestConfig) {
        return AuthControllerApiFp(this.configuration).updateToken(offlineTokenInfo, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CandidateIdentificationControllerApi - axios parameter creator
 * @export
 */
export const CandidateIdentificationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyAllCandidates: async (projectId: EntityId, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('identifyAllCandidates', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('identifyAllCandidates', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/identify-candidates`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {number} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyDeadCode: async (projectId: number, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('identifyDeadCode', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('identifyDeadCode', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/identify-dead-codes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CandidateIdentificationControllerApi - functional programming interface
 * @export
 */
export const CandidateIdentificationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CandidateIdentificationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifyAllCandidates(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifyAllCandidates(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {number} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifyDeadCode(projectId: number, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifyDeadCode(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CandidateIdentificationControllerApi - factory interface
 * @export
 */
export const CandidateIdentificationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CandidateIdentificationControllerApiFp(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyAllCandidates(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.identifyAllCandidates(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {number} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyDeadCode(projectId: number, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.identifyDeadCode(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CandidateIdentificationControllerApi - object-oriented interface
 * @export
 * @class CandidateIdentificationControllerApi
 * @extends {BaseAPI}
 */
export class CandidateIdentificationControllerApi extends BaseAPI {
    /**
     * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that identifies all candidates (Annotations and Data Dictionary Entries) for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CandidateIdentificationControllerApi
     */
    public identifyAllCandidates(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return CandidateIdentificationControllerApiFp(this.configuration).identifyAllCandidates(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that identifies all dead code for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {number} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CandidateIdentificationControllerApi
     */
    public identifyDeadCode(projectId: number, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return CandidateIdentificationControllerApiFp(this.configuration).identifyDeadCode(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientControllerApi - axios parameter creator
 * @export
 */
export const ClientControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client
         * @summary Create a new client
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient: async (clientPojoPrototype: ClientPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientPojoPrototype' is not null or undefined
            assertParamExists('createClient', 'clientPojoPrototype', clientPojoPrototype)
            const localVarPath = `/api/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all available clients.
         * @summary List all available clients.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClients: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Finds a client by its ID.
         * @summary Finds a client by its ID.
         * @param {EntityId} clientId the ID of the client to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClientById: async (clientId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findClientById', 'clientId', clientId)
            const localVarPath = `/api/v1/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update an existing client
         * @summary Update an existing client
         * @param {EntityId} clientId the ID of the client to update
         * @param {ClientPojoPrototype} clientPojoPrototype The client with the updated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClient: async (clientId: EntityId, clientPojoPrototype: ClientPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateClient', 'clientId', clientId)
            // verify required parameter 'clientPojoPrototype' is not null or undefined
            assertParamExists('updateClient', 'clientPojoPrototype', clientPojoPrototype)
            const localVarPath = `/api/v1/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientControllerApi - functional programming interface
 * @export
 */
export const ClientControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client
         * @summary Create a new client
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClient(clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClient(clientPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all available clients.
         * @summary List all available clients.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllClients(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ClientPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllClients(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Finds a client by its ID.
         * @summary Finds a client by its ID.
         * @param {EntityId} clientId the ID of the client to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClientById(clientId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClientById(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update an existing client
         * @summary Update an existing client
         * @param {EntityId} clientId the ID of the client to update
         * @param {ClientPojoPrototype} clientPojoPrototype The client with the updated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateClient(clientId: EntityId, clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateClient(clientId, clientPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientControllerApi - factory interface
 * @export
 */
export const ClientControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientControllerApiFp(configuration)
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client
         * @summary Create a new client
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClient(clientPojoPrototype: ClientPojoPrototype, options?: any): AxiosPromise<ClientPojo> {
            return localVarFp.createClient(clientPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all available clients.
         * @summary List all available clients.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllClients(options?: any): AxiosPromise<Array<ClientPojo>> {
            return localVarFp.findAllClients(options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Finds a client by its ID.
         * @summary Finds a client by its ID.
         * @param {EntityId} clientId the ID of the client to find
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClientById(clientId: EntityId, options?: any): AxiosPromise<ClientPojo> {
            return localVarFp.findClientById(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update an existing client
         * @summary Update an existing client
         * @param {EntityId} clientId the ID of the client to update
         * @param {ClientPojoPrototype} clientPojoPrototype The client with the updated values
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateClient(clientId: EntityId, clientPojoPrototype: ClientPojoPrototype, options?: any): AxiosPromise<ClientPojo> {
            return localVarFp.updateClient(clientId, clientPojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientControllerApi - object-oriented interface
 * @export
 * @class ClientControllerApi
 * @extends {BaseAPI}
 */
export class ClientControllerApi extends BaseAPI {
    /**
     * User Role(s): admin | Project Nature(s): mining  Create a new client
     * @summary Create a new client
     * @param {ClientPojoPrototype} clientPojoPrototype The client to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerApi
     */
    public createClient(clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig) {
        return ClientControllerApiFp(this.configuration).createClient(clientPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all available clients.
     * @summary List all available clients.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerApi
     */
    public findAllClients(options?: AxiosRequestConfig) {
        return ClientControllerApiFp(this.configuration).findAllClients(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Finds a client by its ID.
     * @summary Finds a client by its ID.
     * @param {EntityId} clientId the ID of the client to find
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerApi
     */
    public findClientById(clientId: EntityId, options?: AxiosRequestConfig) {
        return ClientControllerApiFp(this.configuration).findClientById(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Update an existing client
     * @summary Update an existing client
     * @param {EntityId} clientId the ID of the client to update
     * @param {ClientPojoPrototype} clientPojoPrototype The client with the updated values
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerApi
     */
    public updateClient(clientId: EntityId, clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig) {
        return ClientControllerApiFp(this.configuration).updateClient(clientId, clientPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ClientControllerV2Api - axios parameter creator
 * @export
 */
export const ClientControllerV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client and it\'s associated Keycloak roles
         * @summary Create a new client and it\'s associated Keycloak roles
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClientV2: async (clientPojoPrototype: ClientPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientPojoPrototype' is not null or undefined
            assertParamExists('createClientV2', 'clientPojoPrototype', clientPojoPrototype)
            const localVarPath = `/api/v2/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(clientPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Create Client Logo
         * @summary Create Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogo: async (clientId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('createLogo', 'clientId', clientId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('createLogo', 'file', file)
            const localVarPath = `/api/v2/clients/{clientId}/logo`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete specified Client in full cascading manner
         * @summary Delete specified Client in full cascading manner
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient: async (clientId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteClient', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete Client Logo
         * @summary Delete Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogo: async (clientId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteLogo', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/logo`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all clients
         * @summary List all clients
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array. example &#x3D; new String[] {\&quot;id;ASC\&quot;, \&quot;name;ASC\&quot;}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllClients: async (page?: number, size?: number, sortBy?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v2/clients`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Get Client Logo
         * @summary Get Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo: async (clientId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getLogo', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/logo`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update Client Logo
         * @summary Update Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogo: async (clientId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('updateLogo', 'clientId', clientId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('updateLogo', 'file', file)
            const localVarPath = `/api/v2/clients/{clientId}/logo`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ClientControllerV2Api - functional programming interface
 * @export
 */
export const ClientControllerV2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ClientControllerV2ApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client and it\'s associated Keycloak roles
         * @summary Create a new client and it\'s associated Keycloak roles
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createClientV2(clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClientPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createClientV2(clientPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Create Client Logo
         * @summary Create Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createLogo(clientId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createLogo(clientId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete specified Client in full cascading manner
         * @summary Delete specified Client in full cascading manner
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteClient(clientId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete Client Logo
         * @summary Delete Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteLogo(clientId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteLogo(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all clients
         * @summary List all clients
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array. example &#x3D; new String[] {\&quot;id;ASC\&quot;, \&quot;name;ASC\&quot;}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllClients(page?: number, size?: number, sortBy?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedClientPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllClients(page, size, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Get Client Logo
         * @summary Get Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogo(clientId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogo(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update Client Logo
         * @summary Update Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateLogo(clientId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateLogo(clientId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ClientControllerV2Api - factory interface
 * @export
 */
export const ClientControllerV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ClientControllerV2ApiFp(configuration)
    return {
        /**
         * User Role(s): admin | Project Nature(s): mining  Create a new client and it\'s associated Keycloak roles
         * @summary Create a new client and it\'s associated Keycloak roles
         * @param {ClientPojoPrototype} clientPojoPrototype The client to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createClientV2(clientPojoPrototype: ClientPojoPrototype, options?: any): AxiosPromise<ClientPojo> {
            return localVarFp.createClientV2(clientPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Create Client Logo
         * @summary Create Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createLogo(clientId: EntityId, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.createLogo(clientId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete specified Client in full cascading manner
         * @summary Delete specified Client in full cascading manner
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteClient(clientId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Delete Client Logo
         * @summary Delete Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLogo(clientId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteLogo(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all clients
         * @summary List all clients
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array. example &#x3D; new String[] {\&quot;id;ASC\&quot;, \&quot;name;ASC\&quot;}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllClients(page?: number, size?: number, sortBy?: Array<string>, options?: any): AxiosPromise<PagedClientPojo> {
            return localVarFp.getAllClients(page, size, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Get Client Logo
         * @summary Get Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogo(clientId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getLogo(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Update Client Logo
         * @summary Update Client Logo
         * @param {EntityId} clientId the ID of the client to search
         * @param {File} file The logo file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLogo(clientId: EntityId, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.updateLogo(clientId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ClientControllerV2Api - object-oriented interface
 * @export
 * @class ClientControllerV2Api
 * @extends {BaseAPI}
 */
export class ClientControllerV2Api extends BaseAPI {
    /**
     * User Role(s): admin | Project Nature(s): mining  Create a new client and it\'s associated Keycloak roles
     * @summary Create a new client and it\'s associated Keycloak roles
     * @param {ClientPojoPrototype} clientPojoPrototype The client to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public createClientV2(clientPojoPrototype: ClientPojoPrototype, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).createClientV2(clientPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Create Client Logo
     * @summary Create Client Logo
     * @param {EntityId} clientId the ID of the client to search
     * @param {File} file The logo file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public createLogo(clientId: EntityId, file: File, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).createLogo(clientId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Delete specified Client in full cascading manner
     * @summary Delete specified Client in full cascading manner
     * @param {EntityId} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public deleteClient(clientId: EntityId, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).deleteClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Delete Client Logo
     * @summary Delete Client Logo
     * @param {EntityId} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public deleteLogo(clientId: EntityId, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).deleteLogo(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all clients
     * @summary List all clients
     * @param {number} [page] the page number to be fetched
     * @param {number} [size] the size of each page
     * @param {Array<string>} [sortBy] the sort conditions as string array. example &#x3D; new String[] {\&quot;id;ASC\&quot;, \&quot;name;ASC\&quot;}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public getAllClients(page?: number, size?: number, sortBy?: Array<string>, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).getAllClients(page, size, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Get Client Logo
     * @summary Get Client Logo
     * @param {EntityId} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public getLogo(clientId: EntityId, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).getLogo(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Update Client Logo
     * @summary Update Client Logo
     * @param {EntityId} clientId the ID of the client to search
     * @param {File} file The logo file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ClientControllerV2Api
     */
    public updateLogo(clientId: EntityId, file: File, options?: AxiosRequestConfig) {
        return ClientControllerV2ApiFp(this.configuration).updateLogo(clientId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ControlFlowControllerApi - axios parameter creator
 * @export
 */
export const ControlFlowControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [recalculateAst] whether to force re-calculation of the AST before computing CFG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateControlFlowForModule: async (projectId: EntityId, moduleId: EntityId, recalculateAst?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('calculateControlFlowForModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('calculateControlFlowForModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/control-flow/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (recalculateAst !== undefined) {
                localVarQueryParameter['recalculateAst'] = recalculateAst;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules relative to the project example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateControlFlowGraphs: async (projectId: EntityId, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('calculateControlFlowGraphs', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('calculateControlFlowGraphs', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/control-flow`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the control flow for a module ID
         * @summary Gets the control flow for a module ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {number} [characterLimit] the character Limit
         * @param {boolean} [checkCalculated] only check if a graph is present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlFlow: async (projectId: EntityId, moduleId: EntityId, characterLimit?: number, checkCalculated?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getControlFlow', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getControlFlow', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/control-flow/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (characterLimit !== undefined) {
                localVarQueryParameter['characterLimit'] = characterLimit;
            }

            if (checkCalculated !== undefined) {
                localVarQueryParameter['checkCalculated'] = checkCalculated;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets the module types supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedModuleTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/control-flow-support`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the module types theoretically supported by the control flow graph
         * @summary Gets the module types theoretically supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheoreticallySupportedModuleTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/control-flow-support-theoretical`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControlFlowControllerApi - functional programming interface
 * @export
 */
export const ControlFlowControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControlFlowControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [recalculateAst] whether to force re-calculation of the AST before computing CFG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateControlFlowForModule(projectId: EntityId, moduleId: EntityId, recalculateAst?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateControlFlowForModule(projectId, moduleId, recalculateAst, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules relative to the project example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async calculateControlFlowGraphs(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.calculateControlFlowGraphs(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the control flow for a module ID
         * @summary Gets the control flow for a module ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {number} [characterLimit] the character Limit
         * @param {boolean} [checkCalculated] only check if a graph is present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlFlow(projectId: EntityId, moduleId: EntityId, characterLimit?: number, checkCalculated?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlFlowGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlFlow(projectId, moduleId, characterLimit, checkCalculated, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets the module types supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSupportedModuleTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSupportedModuleTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the module types theoretically supported by the control flow graph
         * @summary Gets the module types theoretically supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTheoreticallySupportedModuleTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTheoreticallySupportedModuleTypes(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ControlFlowControllerApi - factory interface
 * @export
 */
export const ControlFlowControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControlFlowControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [recalculateAst] whether to force re-calculation of the AST before computing CFG
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateControlFlowForModule(projectId: EntityId, moduleId: EntityId, recalculateAst?: boolean, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.calculateControlFlowForModule(projectId, moduleId, recalculateAst, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules relative to the project example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        calculateControlFlowGraphs(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.calculateControlFlowGraphs(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the control flow for a module ID
         * @summary Gets the control flow for a module ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} moduleId the module ID
         * @param {number} [characterLimit] the character Limit
         * @param {boolean} [checkCalculated] only check if a graph is present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlFlow(projectId: EntityId, moduleId: EntityId, characterLimit?: number, checkCalculated?: boolean, options?: any): AxiosPromise<ControlFlowGraph> {
            return localVarFp.getControlFlow(projectId, moduleId, characterLimit, checkCalculated, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets the module types supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSupportedModuleTypes(options?: any): AxiosPromise<Set<object>> {
            return localVarFp.getSupportedModuleTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets the module types theoretically supported by the control flow graph
         * @summary Gets the module types theoretically supported by the control flow graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTheoreticallySupportedModuleTypes(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getTheoreticallySupportedModuleTypes(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControlFlowControllerApi - object-oriented interface
 * @export
 * @class ControlFlowControllerApi
 * @extends {BaseAPI}
 */
export class ControlFlowControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that calculates CFG for the given module Id and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {boolean} [recalculateAst] whether to force re-calculation of the AST before computing CFG
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlFlowControllerApi
     */
    public calculateControlFlowForModule(projectId: EntityId, moduleId: EntityId, recalculateAst?: boolean, options?: AxiosRequestConfig) {
        return ControlFlowControllerApiFp(this.configuration).calculateControlFlowForModule(projectId, moduleId, recalculateAst, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that calculates CFG for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher list of id\&#39;s and/or the file paths of the modules relative to the project example &#x3D; \&quot;{1}, {src/file.cbl}\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlFlowControllerApi
     */
    public calculateControlFlowGraphs(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return ControlFlowControllerApiFp(this.configuration).calculateControlFlowGraphs(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Gets the control flow for a module ID
     * @summary Gets the control flow for a module ID
     * @param {EntityId} projectId the project ID
     * @param {EntityId} moduleId the module ID
     * @param {number} [characterLimit] the character Limit
     * @param {boolean} [checkCalculated] only check if a graph is present
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlFlowControllerApi
     */
    public getControlFlow(projectId: EntityId, moduleId: EntityId, characterLimit?: number, checkCalculated?: boolean, options?: AxiosRequestConfig) {
        return ControlFlowControllerApiFp(this.configuration).getControlFlow(projectId, moduleId, characterLimit, checkCalculated, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets the module types supported by the control flow graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlFlowControllerApi
     */
    public getSupportedModuleTypes(options?: AxiosRequestConfig) {
        return ControlFlowControllerApiFp(this.configuration).getSupportedModuleTypes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Gets the module types theoretically supported by the control flow graph
     * @summary Gets the module types theoretically supported by the control flow graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControlFlowControllerApi
     */
    public getTheoreticallySupportedModuleTypes(options?: AxiosRequestConfig) {
        return ControlFlowControllerApiFp(this.configuration).getTheoreticallySupportedModuleTypes(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataDictionaryControllerApi - axios parameter creator
 * @export
 */
export const DataDictionaryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all data dictionary entries from a given module
         * @summary Count all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countAllDataDictionaryEntries: async (projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('countAllDataDictionaryEntries', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('countAllDataDictionaryEntries', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/count`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (includeCopyBooks !== undefined) {
                localVarQueryParameter['includeCopyBooks'] = includeCopyBooks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new data dictionary entry
         * @summary Create a new data dictionary entry
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The data dictionary entry to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataDictionaryEntry: async (projectId: EntityId, moduleId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createDataDictionaryEntry', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('createDataDictionaryEntry', 'moduleId', moduleId)
            // verify required parameter 'dataDictionaryPojoPrototype' is not null or undefined
            assertParamExists('createDataDictionaryEntry', 'dataDictionaryPojoPrototype', dataDictionaryPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataDictionaryPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a data dictionary entry
         * @summary Delete a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataDictionaryEntry: async (projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteDataDictionaryEntry', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('deleteDataDictionaryEntry', 'moduleId', moduleId)
            // verify required parameter 'ddeId' is not null or undefined
            assertParamExists('deleteDataDictionaryEntry', 'ddeId', ddeId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/{ddeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"ddeId"}}`, encodeURIComponent(String(ddeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all data dictionary entries from a given module
         * @summary List all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDataDictionaryEntries: async (projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllDataDictionaryEntries', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAllDataDictionaryEntries', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (includeCopyBooks !== undefined) {
                localVarQueryParameter['includeCopyBooks'] = includeCopyBooks;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all other scopes
         * @summary List all other scopes
         * @param {EntityId} projectId the ID of the project to list available scopes from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOtherScopes: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllOtherScopes', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/data-dictionary/other-scopes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of DataDictionary for a given module Based on Offset
         * @summary List of DataDictionary for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDataDictionaryBasedOnOffset: async (projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findDataDictionaryBasedOnOffset', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findDataDictionaryBasedOnOffset', 'moduleId', moduleId)
            // verify required parameter 'startOffset' is not null or undefined
            assertParamExists('findDataDictionaryBasedOnOffset', 'startOffset', startOffset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/byOffset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (startOffset !== undefined) {
                localVarQueryParameter['startOffset'] = startOffset;
            }

            if (endOffset !== undefined) {
                localVarQueryParameter['endOffset'] = endOffset;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Lists a data dictionary entry from a given record ID
         * @summary Lists a data dictionary entry from a given record ID
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDataDictionaryEntryByRecordId: async (projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findDataDictionaryEntryByRecordId', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findDataDictionaryEntryByRecordId', 'moduleId', moduleId)
            // verify required parameter 'ddeId' is not null or undefined
            assertParamExists('findDataDictionaryEntryByRecordId', 'ddeId', ddeId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/{ddeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"ddeId"}}`, encodeURIComponent(String(ddeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables for a Business Rule
         * @summary Find linked Business Variables for a Business Rule
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedBusinessVariables: async (projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findLinkedBusinessVariables', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findLinkedBusinessVariables', 'moduleId', moduleId)
            // verify required parameter 'ddeId' is not null or undefined
            assertParamExists('findLinkedBusinessVariables', 'ddeId', ddeId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/{ddeId}/linked-annotations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"ddeId"}}`, encodeURIComponent(String(ddeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of data dictionaries
         * @summary Get aggregated values over a number of data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestDataDictionaryFieldName} aggregationRequestDataDictionaryFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues3: async (projectId: EntityId, aggregationRequestDataDictionaryFieldName: AggregationRequestDataDictionaryFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedValues3', 'projectId', projectId)
            // verify required parameter 'aggregationRequestDataDictionaryFieldName' is not null or undefined
            assertParamExists('getAggregatedValues3', 'aggregationRequestDataDictionaryFieldName', aggregationRequestDataDictionaryFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/data-dictionary/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestDataDictionaryFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  validate text selection and return format
         * @summary validate text selection and return format
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the text that has been selected and needs to be validated
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormatIfSelectionIsValid: async (projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFormatIfSelectionIsValid', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getFormatIfSelectionIsValid', 'moduleId', moduleId)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getFormatIfSelectionIsValid', 'offset', offset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/offset/{offset}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (assembled !== undefined) {
                localVarQueryParameter['assembled'] = assembled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search data dictionary entries from a given project
         * @summary Search data dictionary entries from a given project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} [description] a description to search for, either this or a dataElementName must be provided
         * @param {string} [dataElementName] a data element name to search for, either this or a description must be provided
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDataDictionary: async (projectId: EntityId, description?: string, dataElementName?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('searchDataDictionary', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/data-dictionary/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (dataElementName !== undefined) {
                localVarQueryParameter['dataElementName'] = dataElementName;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a data dictionary entry
         * @summary Update a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be updated
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The updated data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataDictionaryEntry: async (projectId: EntityId, moduleId: EntityId, ddeId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDataDictionaryEntry', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('updateDataDictionaryEntry', 'moduleId', moduleId)
            // verify required parameter 'ddeId' is not null or undefined
            assertParamExists('updateDataDictionaryEntry', 'ddeId', ddeId)
            // verify required parameter 'dataDictionaryPojoPrototype' is not null or undefined
            assertParamExists('updateDataDictionaryEntry', 'dataDictionaryPojoPrototype', dataDictionaryPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/data-dictionary/{ddeId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"ddeId"}}`, encodeURIComponent(String(ddeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dataDictionaryPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataDictionaryControllerApi - functional programming interface
 * @export
 */
export const DataDictionaryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataDictionaryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all data dictionary entries from a given module
         * @summary Count all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new data dictionary entry
         * @summary Create a new data dictionary entry
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The data dictionary entry to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDictionaryPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createDataDictionaryEntry(projectId, moduleId, dataDictionaryPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a data dictionary entry
         * @summary Delete a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDataDictionaryEntry(projectId, moduleId, ddeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all data dictionary entries from a given module
         * @summary List all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataDictionaryPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all other scopes
         * @summary List all other scopes
         * @param {EntityId} projectId the ID of the project to list available scopes from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllOtherScopes(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllOtherScopes(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of DataDictionary for a given module Based on Offset
         * @summary List of DataDictionary for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDataDictionaryBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataDictionaryPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDataDictionaryBasedOnOffset(projectId, moduleId, startOffset, endOffset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Lists a data dictionary entry from a given record ID
         * @summary Lists a data dictionary entry from a given record ID
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findDataDictionaryEntryByRecordId(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDictionaryPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findDataDictionaryEntryByRecordId(projectId, moduleId, ddeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables for a Business Rule
         * @summary Find linked Business Variables for a Business Rule
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLinkedBusinessVariables(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLinkedBusinessVariables(projectId, moduleId, ddeId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of data dictionaries
         * @summary Get aggregated values over a number of data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestDataDictionaryFieldName} aggregationRequestDataDictionaryFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedValues3(projectId: EntityId, aggregationRequestDataDictionaryFieldName: AggregationRequestDataDictionaryFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultDataDictionaryFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedValues3(projectId, aggregationRequestDataDictionaryFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  validate text selection and return format
         * @summary validate text selection and return format
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the text that has been selected and needs to be validated
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormatIfSelectionIsValid(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataFieldFormat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormatIfSelectionIsValid(projectId, moduleId, offset, assembled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search data dictionary entries from a given project
         * @summary Search data dictionary entries from a given project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} [description] a description to search for, either this or a dataElementName must be provided
         * @param {string} [dataElementName] a data element name to search for, either this or a description must be provided
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchDataDictionary(projectId: EntityId, description?: string, dataElementName?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DataDictionaryPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchDataDictionary(projectId, description, dataElementName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a data dictionary entry
         * @summary Update a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be updated
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The updated data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataDictionaryPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDataDictionaryEntry(projectId, moduleId, ddeId, dataDictionaryPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataDictionaryControllerApi - factory interface
 * @export
 */
export const DataDictionaryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataDictionaryControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all data dictionary entries from a given module
         * @summary Count all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: any): AxiosPromise<number> {
            return localVarFp.countAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new data dictionary entry
         * @summary Create a new data dictionary entry
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The data dictionary entry to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: any): AxiosPromise<DataDictionaryPojo> {
            return localVarFp.createDataDictionaryEntry(projectId, moduleId, dataDictionaryPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a data dictionary entry
         * @summary Delete a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteDataDictionaryEntry(projectId, moduleId, ddeId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all data dictionary entries from a given module
         * @summary List all data dictionary entries from a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [includeCopyBooks] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: any): AxiosPromise<Array<DataDictionaryPojo>> {
            return localVarFp.findAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all other scopes
         * @summary List all other scopes
         * @param {EntityId} projectId the ID of the project to list available scopes from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllOtherScopes(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findAllOtherScopes(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of DataDictionary for a given module Based on Offset
         * @summary List of DataDictionary for a given module Based on Offset
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} startOffset the Start Offset of Module
         * @param {number} [endOffset] the End Offset of Module (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDataDictionaryBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: any): AxiosPromise<Array<DataDictionaryPojo>> {
            return localVarFp.findDataDictionaryBasedOnOffset(projectId, moduleId, startOffset, endOffset, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Lists a data dictionary entry from a given record ID
         * @summary Lists a data dictionary entry from a given record ID
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findDataDictionaryEntryByRecordId(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: any): AxiosPromise<DataDictionaryPojo> {
            return localVarFp.findDataDictionaryEntryByRecordId(projectId, moduleId, ddeId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables for a Business Rule
         * @summary Find linked Business Variables for a Business Rule
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedBusinessVariables(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.findLinkedBusinessVariables(projectId, moduleId, ddeId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of data dictionaries
         * @summary Get aggregated values over a number of data dictionaries
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestDataDictionaryFieldName} aggregationRequestDataDictionaryFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues3(projectId: EntityId, aggregationRequestDataDictionaryFieldName: AggregationRequestDataDictionaryFieldName, options?: any): AxiosPromise<Array<AggregationResultDataDictionaryFieldName>> {
            return localVarFp.getAggregatedValues3(projectId, aggregationRequestDataDictionaryFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  validate text selection and return format
         * @summary validate text selection and return format
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the text that has been selected and needs to be validated
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormatIfSelectionIsValid(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: any): AxiosPromise<DataFieldFormat> {
            return localVarFp.getFormatIfSelectionIsValid(projectId, moduleId, offset, assembled, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search data dictionary entries from a given project
         * @summary Search data dictionary entries from a given project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} [description] a description to search for, either this or a dataElementName must be provided
         * @param {string} [dataElementName] a data element name to search for, either this or a description must be provided
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchDataDictionary(projectId: EntityId, description?: string, dataElementName?: string, options?: any): AxiosPromise<Array<DataDictionaryPojo>> {
            return localVarFp.searchDataDictionary(projectId, description, dataElementName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a data dictionary entry
         * @summary Update a data dictionary entry
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module
         * @param {EntityId} ddeId the ID of the data dictionary entry to be updated
         * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The updated data dictionary entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: any): AxiosPromise<DataDictionaryPojo> {
            return localVarFp.updateDataDictionaryEntry(projectId, moduleId, ddeId, dataDictionaryPojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataDictionaryControllerApi - object-oriented interface
 * @export
 * @class DataDictionaryControllerApi
 * @extends {BaseAPI}
 */
export class DataDictionaryControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Count all data dictionary entries from a given module
     * @summary Count all data dictionary entries from a given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {boolean} [includeCopyBooks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public countAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).countAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Create a new data dictionary entry
     * @summary Create a new data dictionary entry
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The data dictionary entry to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public createDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).createDataDictionaryEntry(projectId, moduleId, dataDictionaryPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Delete a data dictionary entry
     * @summary Delete a data dictionary entry
     * @param {EntityId} projectId the ID of the project to search
     * @param {EntityId} moduleId the ID of the module
     * @param {EntityId} ddeId the ID of the data dictionary entry to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public deleteDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).deleteDataDictionaryEntry(projectId, moduleId, ddeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all data dictionary entries from a given module
     * @summary List all data dictionary entries from a given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {boolean} [includeCopyBooks] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public findAllDataDictionaryEntries(projectId: EntityId, moduleId: EntityId, includeCopyBooks?: boolean, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).findAllDataDictionaryEntries(projectId, moduleId, includeCopyBooks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all other scopes
     * @summary List all other scopes
     * @param {EntityId} projectId the ID of the project to list available scopes from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public findAllOtherScopes(projectId: EntityId, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).findAllOtherScopes(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List of DataDictionary for a given module Based on Offset
     * @summary List of DataDictionary for a given module Based on Offset
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} startOffset the Start Offset of Module
     * @param {number} [endOffset] the End Offset of Module (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public findDataDictionaryBasedOnOffset(projectId: EntityId, moduleId: EntityId, startOffset: number, endOffset?: number, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).findDataDictionaryBasedOnOffset(projectId, moduleId, startOffset, endOffset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Lists a data dictionary entry from a given record ID
     * @summary Lists a data dictionary entry from a given record ID
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {EntityId} ddeId the ID of the data dictionary entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public findDataDictionaryEntryByRecordId(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).findDataDictionaryEntryByRecordId(projectId, moduleId, ddeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find linked Business Variables for a Business Rule
     * @summary Find linked Business Variables for a Business Rule
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {EntityId} ddeId the ID of the data dictionary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public findLinkedBusinessVariables(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).findLinkedBusinessVariables(projectId, moduleId, ddeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of data dictionaries
     * @summary Get aggregated values over a number of data dictionaries
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestDataDictionaryFieldName} aggregationRequestDataDictionaryFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public getAggregatedValues3(projectId: EntityId, aggregationRequestDataDictionaryFieldName: AggregationRequestDataDictionaryFieldName, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).getAggregatedValues3(projectId, aggregationRequestDataDictionaryFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  validate text selection and return format
     * @summary validate text selection and return format
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} offset the offset of the text that has been selected and needs to be validated
     * @param {boolean} [assembled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public getFormatIfSelectionIsValid(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).getFormatIfSelectionIsValid(projectId, moduleId, offset, assembled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Search data dictionary entries from a given project
     * @summary Search data dictionary entries from a given project
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} [description] a description to search for, either this or a dataElementName must be provided
     * @param {string} [dataElementName] a data element name to search for, either this or a description must be provided
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public searchDataDictionary(projectId: EntityId, description?: string, dataElementName?: string, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).searchDataDictionary(projectId, description, dataElementName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update a data dictionary entry
     * @summary Update a data dictionary entry
     * @param {EntityId} projectId the ID of the project to search
     * @param {EntityId} moduleId the ID of the module
     * @param {EntityId} ddeId the ID of the data dictionary entry to be updated
     * @param {DataDictionaryPojoPrototype} dataDictionaryPojoPrototype The updated data dictionary entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataDictionaryControllerApi
     */
    public updateDataDictionaryEntry(projectId: EntityId, moduleId: EntityId, ddeId: EntityId, dataDictionaryPojoPrototype: DataDictionaryPojoPrototype, options?: AxiosRequestConfig) {
        return DataDictionaryControllerApiFp(this.configuration).updateDataDictionaryEntry(projectId, moduleId, ddeId, dataDictionaryPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataPointControllerApi - axios parameter creator
 * @export
 */
export const DataPointControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @summary This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @param {EntityId} projectId the id of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPointUsages: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataPointUsages', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/datapoints/usages`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data points for a project. Can optionally be filtered by usage.
         * @summary List all known data points for a project. Can optionally be filtered by usage.
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given (if not specified, all usages are returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPoints: async (projectId: EntityId, usages?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataPoints', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/datapoints`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (usages) {
                localVarQueryParameter['usages'] = usages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  null
         * @param {EntityId} projectId the id of the project for which the data points should be listed
         * @param {string} typeName the name of the type for which the data points should be listed
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given  (all usages are returned, if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPointsForType: async (projectId: EntityId, typeName: string, usages?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataPointsForType', 'projectId', projectId)
            // verify required parameter 'typeName' is not null or undefined
            assertParamExists('getDataPointsForType', 'typeName', typeName)
            const localVarPath = `/api/v2/projects/{projectId}/datapoints/for-type/{typeName}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"typeName"}}`, encodeURIComponent(String(typeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (usages) {
                localVarQueryParameter['usages'] = usages;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data types containing data points for a project
         * @summary List all known data types containing data points for a project
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataTypes', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/datapoints/types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataPointControllerApi - functional programming interface
 * @export
 */
export const DataPointControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataPointControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @summary This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @param {EntityId} projectId the id of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataPointUsages(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsagesModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataPointUsages(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data points for a project. Can optionally be filtered by usage.
         * @summary List all known data points for a project. Can optionally be filtered by usage.
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given (if not specified, all usages are returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataPoints(projectId: EntityId, usages?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: MiningDataPointDefinition; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataPoints(projectId, usages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  null
         * @param {EntityId} projectId the id of the project for which the data points should be listed
         * @param {string} typeName the name of the type for which the data points should be listed
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given  (all usages are returned, if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataPointsForType(projectId: EntityId, typeName: string, usages?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MiningDataPointDefinitionWithPath>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataPointsForType(projectId, typeName, usages, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data types containing data points for a project
         * @summary List all known data types containing data points for a project
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataTypes(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataTypes(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataPointControllerApi - factory interface
 * @export
 */
export const DataPointControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataPointControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @summary This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
         * @param {EntityId} projectId the id of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPointUsages(projectId: EntityId, options?: any): AxiosPromise<UsagesModel> {
            return localVarFp.getDataPointUsages(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data points for a project. Can optionally be filtered by usage.
         * @summary List all known data points for a project. Can optionally be filtered by usage.
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given (if not specified, all usages are returned)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPoints(projectId: EntityId, usages?: Array<string>, options?: any): AxiosPromise<{ [key: string]: { [key: string]: MiningDataPointDefinition; }; }> {
            return localVarFp.getDataPoints(projectId, usages, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  null
         * @param {EntityId} projectId the id of the project for which the data points should be listed
         * @param {string} typeName the name of the type for which the data points should be listed
         * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given  (all usages are returned, if not specified)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataPointsForType(projectId: EntityId, typeName: string, usages?: Array<string>, options?: any): AxiosPromise<Array<MiningDataPointDefinitionWithPath>> {
            return localVarFp.getDataPointsForType(projectId, typeName, usages, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data types containing data points for a project
         * @summary List all known data types containing data points for a project
         * @param {EntityId} projectId the id of the project for which data types should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataTypes(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getDataTypes(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataPointControllerApi - object-oriented interface
 * @export
 * @class DataPointControllerApi
 * @extends {BaseAPI}
 */
export class DataPointControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
     * @summary This endpoint exists only to generate type definitions via swagger-codegen and can not actually be called
     * @param {EntityId} projectId the id of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPointControllerApi
     */
    public getDataPointUsages(projectId: EntityId, options?: AxiosRequestConfig) {
        return DataPointControllerApiFp(this.configuration).getDataPointUsages(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data points for a project. Can optionally be filtered by usage.
     * @summary List all known data points for a project. Can optionally be filtered by usage.
     * @param {EntityId} projectId the id of the project for which data types should be returned
     * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given (if not specified, all usages are returned)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPointControllerApi
     */
    public getDataPoints(projectId: EntityId, usages?: Array<string>, options?: AxiosRequestConfig) {
        return DataPointControllerApiFp(this.configuration).getDataPoints(projectId, usages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  null
     * @param {EntityId} projectId the id of the project for which the data points should be listed
     * @param {string} typeName the name of the type for which the data points should be listed
     * @param {Array<string>} [usages] the data point usages that should be included, multiple usages can be given  (all usages are returned, if not specified)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPointControllerApi
     */
    public getDataPointsForType(projectId: EntityId, typeName: string, usages?: Array<string>, options?: AxiosRequestConfig) {
        return DataPointControllerApiFp(this.configuration).getDataPointsForType(projectId, typeName, usages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all known data types containing data points for a project
     * @summary List all known data types containing data points for a project
     * @param {EntityId} projectId the id of the project for which data types should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataPointControllerApi
     */
    public getDataTypes(projectId: EntityId, options?: AxiosRequestConfig) {
        return DataPointControllerApiFp(this.configuration).getDataTypes(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DataSchemaControllerApi - axios parameter creator
 * @export
 */
export const DataSchemaControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFieldInfos: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findFieldInfos', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findFieldInfos', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/fields`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSchemas: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findSchemas', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/schema`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import database schema definitions
         * @summary Import database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {LegacyDatabase} legacyDatabase The schema data to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSchemas: async (projectId: EntityId, legacyDatabase: LegacyDatabase, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importSchemas', 'projectId', projectId)
            // verify required parameter 'legacyDatabase' is not null or undefined
            assertParamExists('importSchemas', 'legacyDatabase', legacyDatabase)
            const localVarPath = `/api/v1/projects/{projectId}/schema/import`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(legacyDatabase, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the comment for FieldInfo based on moduleId and ordinal
         * @summary Update the comment for FieldInfo based on moduleId and ordinal
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} ordinal the index of the data field or table column
         * @param {{ [key: string]: object; }} requestBody The map containing the properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFieldInfoComment: async (projectId: EntityId, moduleId: EntityId, ordinal: number, requestBody: { [key: string]: object; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateFieldInfoComment', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('updateFieldInfoComment', 'moduleId', moduleId)
            // verify required parameter 'ordinal' is not null or undefined
            assertParamExists('updateFieldInfoComment', 'ordinal', ordinal)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateFieldInfoComment', 'requestBody', requestBody)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/fields/{ordinal}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"ordinal"}}`, encodeURIComponent(String(ordinal)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSchemaControllerApi - functional programming interface
 * @export
 */
export const DataSchemaControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DataSchemaControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFieldInfos(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FieldInfoPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFieldInfos(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findSchemas(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SchemaInfoPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findSchemas(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import database schema definitions
         * @summary Import database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {LegacyDatabase} legacyDatabase The schema data to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSchemas(projectId: EntityId, legacyDatabase: LegacyDatabase, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSchemas(projectId, legacyDatabase, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the comment for FieldInfo based on moduleId and ordinal
         * @summary Update the comment for FieldInfo based on moduleId and ordinal
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} ordinal the index of the data field or table column
         * @param {{ [key: string]: object; }} requestBody The map containing the properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFieldInfoComment(projectId: EntityId, moduleId: EntityId, ordinal: number, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFieldInfoComment(projectId, moduleId, ordinal, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DataSchemaControllerApi - factory interface
 * @export
 */
export const DataSchemaControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DataSchemaControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFieldInfos(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<Array<FieldInfoPojo>> {
            return localVarFp.findFieldInfos(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Find database schema definitions
         * @summary Find database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findSchemas(projectId: EntityId, options?: any): AxiosPromise<Array<SchemaInfoPojo>> {
            return localVarFp.findSchemas(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Import database schema definitions
         * @summary Import database schema definitions
         * @param {EntityId} projectId the ID of the project
         * @param {LegacyDatabase} legacyDatabase The schema data to import
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSchemas(projectId: EntityId, legacyDatabase: LegacyDatabase, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.importSchemas(projectId, legacyDatabase, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update the comment for FieldInfo based on moduleId and ordinal
         * @summary Update the comment for FieldInfo based on moduleId and ordinal
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} ordinal the index of the data field or table column
         * @param {{ [key: string]: object; }} requestBody The map containing the properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFieldInfoComment(projectId: EntityId, moduleId: EntityId, ordinal: number, requestBody: { [key: string]: object; }, options?: any): AxiosPromise<void> {
            return localVarFp.updateFieldInfoComment(projectId, moduleId, ordinal, requestBody, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSchemaControllerApi - object-oriented interface
 * @export
 * @class DataSchemaControllerApi
 * @extends {BaseAPI}
 */
export class DataSchemaControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Find database schema definitions
     * @summary Find database schema definitions
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSchemaControllerApi
     */
    public findFieldInfos(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return DataSchemaControllerApiFp(this.configuration).findFieldInfos(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Find database schema definitions
     * @summary Find database schema definitions
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSchemaControllerApi
     */
    public findSchemas(projectId: EntityId, options?: AxiosRequestConfig) {
        return DataSchemaControllerApiFp(this.configuration).findSchemas(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Import database schema definitions
     * @summary Import database schema definitions
     * @param {EntityId} projectId the ID of the project
     * @param {LegacyDatabase} legacyDatabase The schema data to import
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSchemaControllerApi
     */
    public importSchemas(projectId: EntityId, legacyDatabase: LegacyDatabase, options?: AxiosRequestConfig) {
        return DataSchemaControllerApiFp(this.configuration).importSchemas(projectId, legacyDatabase, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update the comment for FieldInfo based on moduleId and ordinal
     * @summary Update the comment for FieldInfo based on moduleId and ordinal
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} ordinal the index of the data field or table column
     * @param {{ [key: string]: object; }} requestBody The map containing the properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSchemaControllerApi
     */
    public updateFieldInfoComment(projectId: EntityId, moduleId: EntityId, ordinal: number, requestBody: { [key: string]: object; }, options?: AxiosRequestConfig) {
        return DataSchemaControllerApiFp(this.configuration).updateFieldInfoComment(projectId, moduleId, ordinal, requestBody, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DiscoveryControllerApi - axios parameter creator
 * @export
 */
export const DiscoveryControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Returns the list of clusters for the given module
         * @summary Returns the list of clusters for the given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        belongsToCluster: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('belongsToCluster', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('belongsToCluster', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/dna-clusters/modules/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Code job for the given project ID.
         * @summary Executes a Discovery Code job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverCode: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('discoverCode', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/discover-code`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery DNA job for the given project ID.
         * @summary Executes a Discovery DNA job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverDNA: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('discoverDNA', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/find-communities`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Metrics job for the given project ID.
         * @summary Executes a Discovery Metrics job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} [incremental] whether to do an incremental or full discover metrics scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverMetrics: async (projectId: EntityId, incremental?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('discoverMetrics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/discover-metrics`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (incremental !== undefined) {
                localVarQueryParameter['incremental'] = incremental;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Discovery configuration.
         * @summary Downloads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDiscoveryConfiguration: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('downloadDiscoveryConfiguration', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/config`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Lists the timestamps of the Discovery DNA snapshots
         * @summary Lists the timestamps of the Discovery DNA snapshots
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTheTimestampsOfDNASnapshots: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('listTheTimestampsOfDNASnapshots', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/dna-snapshots`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA for latest discovery DNA snapshot
         * @summary Fetch Model DNA for latest discovery DNA snapshot
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelDNAForLatestTimestamp: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('modelDNAForLatestTimestamp', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/dna-snapshots/latest`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @summary Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @param {EntityId} projectId the ID of the project
         * @param {string} timestamp the timestamp of a DNA snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelDNAForSelectedTimestamp: async (projectId: EntityId, timestamp: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('modelDNAForSelectedTimestamp', 'projectId', projectId)
            // verify required parameter 'timestamp' is not null or undefined
            assertParamExists('modelDNAForSelectedTimestamp', 'timestamp', timestamp)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/dna-snapshots/{timestamp}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"timestamp"}}`, encodeURIComponent(String(timestamp)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Sync CF Repo with PD Repo
         * @summary Sync CF Repo with PD Repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingUtilities: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects/discovery/sync-utilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): discovery,mining  Update the Title and Description for DnaCommunity based on UUID
         * @summary Update the Title and Description for DnaCommunity based on UUID
         * @param {EntityId} projectId the ID of the project
         * @param {string} uuid the UUID of Dna Community
         * @param {string} title the title of Dna Community
         * @param {string} [description] the description of Dna Community
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDnaCommunity: async (projectId: EntityId, uuid: string, title: string, description?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateDnaCommunity', 'projectId', projectId)
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('updateDnaCommunity', 'uuid', uuid)
            // verify required parameter 'title' is not null or undefined
            assertParamExists('updateDnaCommunity', 'title', title)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/dna-community/{uuid}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (title !== undefined) {
                localVarQueryParameter['title'] = title;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Uploads Discovery configuration.
         * @summary Uploads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDiscoveryConfiguration: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('uploadDiscoveryConfiguration', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('uploadDiscoveryConfiguration', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/discovery/config`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscoveryControllerApi - functional programming interface
 * @export
 */
export const DiscoveryControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DiscoveryControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Returns the list of clusters for the given module
         * @summary Returns the list of clusters for the given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async belongsToCluster(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelBelongsToClusters>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.belongsToCluster(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Code job for the given project ID.
         * @summary Executes a Discovery Code job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverCode(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverCode(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery DNA job for the given project ID.
         * @summary Executes a Discovery DNA job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverDNA(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverDNA(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Metrics job for the given project ID.
         * @summary Executes a Discovery Metrics job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} [incremental] whether to do an incremental or full discover metrics scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async discoverMetrics(projectId: EntityId, incremental?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.discoverMetrics(projectId, incremental, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Discovery configuration.
         * @summary Downloads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadDiscoveryConfiguration(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadDiscoveryConfiguration(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Lists the timestamps of the Discovery DNA snapshots
         * @summary Lists the timestamps of the Discovery DNA snapshots
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listTheTimestampsOfDNASnapshots(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listTheTimestampsOfDNASnapshots(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA for latest discovery DNA snapshot
         * @summary Fetch Model DNA for latest discovery DNA snapshot
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelDNAForLatestTimestamp(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelDna>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelDNAForLatestTimestamp(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @summary Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @param {EntityId} projectId the ID of the project
         * @param {string} timestamp the timestamp of a DNA snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modelDNAForSelectedTimestamp(projectId: EntityId, timestamp: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModelDna>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modelDNAForSelectedTimestamp(projectId, timestamp, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Sync CF Repo with PD Repo
         * @summary Sync CF Repo with PD Repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async syncingUtilities(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.syncingUtilities(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): discovery,mining  Update the Title and Description for DnaCommunity based on UUID
         * @summary Update the Title and Description for DnaCommunity based on UUID
         * @param {EntityId} projectId the ID of the project
         * @param {string} uuid the UUID of Dna Community
         * @param {string} title the title of Dna Community
         * @param {string} [description] the description of Dna Community
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDnaCommunity(projectId: EntityId, uuid: string, title: string, description?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDnaCommunity(projectId, uuid, title, description, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Uploads Discovery configuration.
         * @summary Uploads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadDiscoveryConfiguration(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadDiscoveryConfiguration(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DiscoveryControllerApi - factory interface
 * @export
 */
export const DiscoveryControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DiscoveryControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Returns the list of clusters for the given module
         * @summary Returns the list of clusters for the given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        belongsToCluster(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<ModelBelongsToClusters> {
            return localVarFp.belongsToCluster(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Code job for the given project ID.
         * @summary Executes a Discovery Code job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverCode(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.discoverCode(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery DNA job for the given project ID.
         * @summary Executes a Discovery DNA job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverDNA(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.discoverDNA(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Metrics job for the given project ID.
         * @summary Executes a Discovery Metrics job for the given project ID.
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} [incremental] whether to do an incremental or full discover metrics scan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discoverMetrics(projectId: EntityId, incremental?: boolean, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.discoverMetrics(projectId, incremental, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Discovery configuration.
         * @summary Downloads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDiscoveryConfiguration(projectId: EntityId, options?: any): AxiosPromise<File> {
            return localVarFp.downloadDiscoveryConfiguration(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Lists the timestamps of the Discovery DNA snapshots
         * @summary Lists the timestamps of the Discovery DNA snapshots
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listTheTimestampsOfDNASnapshots(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.listTheTimestampsOfDNASnapshots(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA for latest discovery DNA snapshot
         * @summary Fetch Model DNA for latest discovery DNA snapshot
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelDNAForLatestTimestamp(projectId: EntityId, options?: any): AxiosPromise<ModelDna> {
            return localVarFp.modelDNAForLatestTimestamp(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @summary Fetch Model DNA For a selected DNA snapshot\'s timestamp.
         * @param {EntityId} projectId the ID of the project
         * @param {string} timestamp the timestamp of a DNA snapshot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modelDNAForSelectedTimestamp(projectId: EntityId, timestamp: string, options?: any): AxiosPromise<ModelDna> {
            return localVarFp.modelDNAForSelectedTimestamp(projectId, timestamp, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): discovery  Sync CF Repo with PD Repo
         * @summary Sync CF Repo with PD Repo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        syncingUtilities(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.syncingUtilities(options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): discovery,mining  Update the Title and Description for DnaCommunity based on UUID
         * @summary Update the Title and Description for DnaCommunity based on UUID
         * @param {EntityId} projectId the ID of the project
         * @param {string} uuid the UUID of Dna Community
         * @param {string} title the title of Dna Community
         * @param {string} [description] the description of Dna Community
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDnaCommunity(projectId: EntityId, uuid: string, title: string, description?: string, options?: any): AxiosPromise<string> {
            return localVarFp.updateDnaCommunity(projectId, uuid, title, description, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Uploads Discovery configuration.
         * @summary Uploads Discovery configuration.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadDiscoveryConfiguration(projectId: EntityId, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.uploadDiscoveryConfiguration(projectId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DiscoveryControllerApi - object-oriented interface
 * @export
 * @class DiscoveryControllerApi
 * @extends {BaseAPI}
 */
export class DiscoveryControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): discovery  Returns the list of clusters for the given module
     * @summary Returns the list of clusters for the given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public belongsToCluster(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).belongsToCluster(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Code job for the given project ID.
     * @summary Executes a Discovery Code job for the given project ID.
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public discoverCode(projectId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).discoverCode(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery DNA job for the given project ID.
     * @summary Executes a Discovery DNA job for the given project ID.
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public discoverDNA(projectId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).discoverDNA(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Executes a Discovery Metrics job for the given project ID.
     * @summary Executes a Discovery Metrics job for the given project ID.
     * @param {EntityId} projectId the ID of the project
     * @param {boolean} [incremental] whether to do an incremental or full discover metrics scan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public discoverMetrics(projectId: EntityId, incremental?: boolean, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).discoverMetrics(projectId, incremental, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Discovery configuration.
     * @summary Downloads Discovery configuration.
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public downloadDiscoveryConfiguration(projectId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).downloadDiscoveryConfiguration(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): discovery  Lists the timestamps of the Discovery DNA snapshots
     * @summary Lists the timestamps of the Discovery DNA snapshots
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public listTheTimestampsOfDNASnapshots(projectId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).listTheTimestampsOfDNASnapshots(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA for latest discovery DNA snapshot
     * @summary Fetch Model DNA for latest discovery DNA snapshot
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public modelDNAForLatestTimestamp(projectId: EntityId, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).modelDNAForLatestTimestamp(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): discovery  Fetch Model DNA For a selected DNA snapshot\'s timestamp.
     * @summary Fetch Model DNA For a selected DNA snapshot\'s timestamp.
     * @param {EntityId} projectId the ID of the project
     * @param {string} timestamp the timestamp of a DNA snapshot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public modelDNAForSelectedTimestamp(projectId: EntityId, timestamp: string, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).modelDNAForSelectedTimestamp(projectId, timestamp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): discovery  Sync CF Repo with PD Repo
     * @summary Sync CF Repo with PD Repo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public syncingUtilities(options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).syncingUtilities(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): discovery,mining  Update the Title and Description for DnaCommunity based on UUID
     * @summary Update the Title and Description for DnaCommunity based on UUID
     * @param {EntityId} projectId the ID of the project
     * @param {string} uuid the UUID of Dna Community
     * @param {string} title the title of Dna Community
     * @param {string} [description] the description of Dna Community
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public updateDnaCommunity(projectId: EntityId, uuid: string, title: string, description?: string, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).updateDnaCommunity(projectId, uuid, title, description, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Uploads Discovery configuration.
     * @summary Uploads Discovery configuration.
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscoveryControllerApi
     */
    public uploadDiscoveryConfiguration(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return DiscoveryControllerApiFp(this.configuration).uploadDiscoveryConfiguration(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeatureControllerApi - axios parameter creator
 * @export
 */
export const FeatureControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeatureById: async (featureId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('findFeatureById', 'featureId', featureId)
            const localVarPath = `/api/v1/features/{featureId}`
                .replace(`{${"featureId"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {boolean} state the new state of the feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature: async (featureId: string, state: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'featureId' is not null or undefined
            assertParamExists('toggleFeature', 'featureId', featureId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('toggleFeature', 'state', state)
            const localVarPath = `/api/v1/features/{featureId}/toggle`
                .replace(`{${"featureId"}}`, encodeURIComponent(String(featureId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeatureControllerApi - functional programming interface
 * @export
 */
export const FeatureControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeatureControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findFeatureById(featureId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Feature>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findFeatureById(featureId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {boolean} state the new state of the feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async toggleFeature(featureId: string, state: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.toggleFeature(featureId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeatureControllerApi - factory interface
 * @export
 */
export const FeatureControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeatureControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findFeatureById(featureId: string, options?: any): AxiosPromise<Feature> {
            return localVarFp.findFeatureById(featureId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining  Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @summary Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
         * @param {string} featureId the ID of the feature to search
         * @param {boolean} state the new state of the feature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        toggleFeature(featureId: string, state: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.toggleFeature(featureId, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeatureControllerApi - object-oriented interface
 * @export
 * @class FeatureControllerApi
 * @extends {BaseAPI}
 */
export class FeatureControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
     * @summary Find a feature by its ID. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
     * @param {string} featureId the ID of the feature to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureControllerApi
     */
    public findFeatureById(featureId: string, options?: AxiosRequestConfig) {
        return FeatureControllerApiFp(this.configuration).findFeatureById(featureId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining  Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
     * @summary Enables or disables a feature. Features can be maintained with FF4J feature UI {@code <api-server-url>/feature-console/}.
     * @param {string} featureId the ID of the feature to search
     * @param {boolean} state the new state of the feature
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeatureControllerApi
     */
    public toggleFeature(featureId: string, state: boolean, options?: AxiosRequestConfig) {
        return FeatureControllerApiFp(this.configuration).toggleFeature(featureId, state, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FunctionalBlockControllerApi - axios parameter creator
 * @export
 */
export const FunctionalBlockControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Computes functional blocks
         * @summary Computes functional blocks
         * @param {EntityId} projectId the project ID
         * @param {Set<string>} requestBody The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeFunctionalBlock: async (projectId: EntityId, requestBody: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('computeFunctionalBlock', 'requestBody', requestBody)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/compute`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a functional block
         * @summary Create a functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFunctionalBlock: async (projectId: EntityId, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'functionalBlockPojoPrototype' is not null or undefined
            assertParamExists('createFunctionalBlock', 'functionalBlockPojoPrototype', functionalBlockPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionalBlockPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutomatedFunctionalBlock: async (projectId: EntityId, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAutomatedFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteAutomatedFunctionalBlock', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/auto-generated-functional-blocks/{uid}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a functional block
         * @summary Delete a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunctionalBlock: async (projectId: EntityId, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('deleteFunctionalBlock', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  execute reachability Analysis on Blocks
         * @summary execute reachability Analysis on Blocks
         * @param {EntityId} projectId the project ID
         * @param {ReachabilityAnalysisRequest} reachabilityAnalysisRequest ReachabilityBlockComputationRequest to compute reachability blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeReachabilityAnalysis: async (projectId: EntityId, reachabilityAnalysisRequest: ReachabilityAnalysisRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('executeReachabilityAnalysis', 'projectId', projectId)
            // verify required parameter 'reachabilityAnalysisRequest' is not null or undefined
            assertParamExists('executeReachabilityAnalysis', 'reachabilityAnalysisRequest', reachabilityAnalysisRequest)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/generate/reachability-blocks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reachabilityAnalysisRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s of the module to generate functional blocksfor example &#x3D; \&quot;{1}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionalBlockGeneration: async (projectId: EntityId, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('functionalBlockGeneration', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('functionalBlockGeneration', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/generate/module-blocks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates functional blocks for business variables using data lineage
         * @summary Generates functional blocks for business variables using data lineage
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId The module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFunctionalBlocksUsingDataLineage: async (projectId: EntityId, entityId: Array<EntityId>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('generateFunctionalBlocksUsingDataLineage', 'projectId', projectId)
            // verify required parameter 'entityId' is not null or undefined
            assertParamExists('generateFunctionalBlocksUsingDataLineage', 'entityId', entityId)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/generate/data-lineage-functional-blocks`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(entityId, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates description a for reachability block using generative AI.
         * @summary Generates description a for reachability block using generative AI.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the UID of the functional block
         * @param {boolean} [generateModuleDescriptions] whether descriptions of modules in the functional block should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReachabilityBlockDescription: async (projectId: EntityId, uid: string, generateModuleDescriptions?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('generateReachabilityBlockDescription', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('generateReachabilityBlockDescription', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/generate-reachability-description/{uid}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (generateModuleDescriptions !== undefined) {
                localVarQueryParameter['generateModuleDescriptions'] = generateModuleDescriptions;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  creates a control flow graph using the functional units contained in the given block
         * @summary creates a control flow graph using the functional units contained in the given block
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlFlowGraphForFunctionalUnits: async (projectId: EntityId, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getControlFlowGraphForFunctionalUnits', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getControlFlowGraphForFunctionalUnits', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}/functional-unit-control-flow-graph`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a control flow graph.
         * @summary convert the given functional block (given by uid parameter) into a control flow graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockAsControlFlowGraph: async (projectId: EntityId, uid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFunctionalBlockAsControlFlowGraph', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getFunctionalBlockAsControlFlowGraph', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}/control-flow-graph`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a dependency graph.
         * @summary convert the given functional block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityBlockGraphFilterRequest} [reachabilityBlockGraphFilterRequest] DependencyGraphFilterRequest to filter the dependency graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockAsDependencyGraph: async (projectId: EntityId, uid: string, reachabilityBlockGraphFilterRequest?: ReachabilityBlockGraphFilterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getFunctionalBlockAsDependencyGraph', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getFunctionalBlockAsDependencyGraph', 'uid', uid)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}/block-graph`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reachabilityBlockGraphFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @summary convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityNetworkGraphFilterRequest} reachabilityNetworkGraphFilterRequest Filter Object to filter the network graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReachabilityNetworkGraph: async (projectId: EntityId, uid: string, reachabilityNetworkGraphFilterRequest: ReachabilityNetworkGraphFilterRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getReachabilityNetworkGraph', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('getReachabilityNetworkGraph', 'uid', uid)
            // verify required parameter 'reachabilityNetworkGraphFilterRequest' is not null or undefined
            assertParamExists('getReachabilityNetworkGraph', 'reachabilityNetworkGraphFilterRequest', reachabilityNetworkGraphFilterRequest)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}/network-graph`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reachabilityNetworkGraphFilterRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  merge functional block
         * @summary merge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Block Pojo for merging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFunctionalBlock: async (projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('mergeFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'functionalBlockMergeRequest' is not null or undefined
            assertParamExists('mergeFunctionalBlock', 'functionalBlockMergeRequest', functionalBlockMergeRequest)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/merge`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionalBlockMergeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Recalculates outdated functional blocks
         * @summary Recalculates outdated functional blocks
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateOutDatedFunctionalBlocks: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recalculateOutDatedFunctionalBlocks', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/recalculate-outdated`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Removes functional blocks Having No UpperBound Module
         * @summary Removes functional blocks Having No UpperBound Module
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFunctionalBlocksWithoutUpperBoundModule: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('removeFunctionalBlocksWithoutUpperBoundModule', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/remove-deleted`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Unmerge functional block
         * @summary Unmerge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Pojo for Unmerging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmergeFunctionalBlock: async (projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('unmergeFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'functionalBlockMergeRequest' is not null or undefined
            assertParamExists('unmergeFunctionalBlock', 'functionalBlockMergeRequest', functionalBlockMergeRequest)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/unmerge`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionalBlockMergeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  change status functional block
         * @summary change status functional block
         * @param {EntityId} projectId the project ID
         * @param {'ACTIVE' | 'INACTIVE'} status the status of the functional block to be updated to
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockStatus: async (projectId: EntityId, status: 'ACTIVE' | 'INACTIVE', requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateBlockStatus', 'projectId', projectId)
            // verify required parameter 'status' is not null or undefined
            assertParamExists('updateBlockStatus', 'status', status)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('updateBlockStatus', 'requestBody', requestBody)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/status/{status}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"status"}}`, encodeURIComponent(String(status)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a functional block
         * @summary Update a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the uid
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to update
         * @param {string} [operationType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunctionalBlock: async (projectId: EntityId, uid: string, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, operationType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateFunctionalBlock', 'projectId', projectId)
            // verify required parameter 'uid' is not null or undefined
            assertParamExists('updateFunctionalBlock', 'uid', uid)
            // verify required parameter 'functionalBlockPojoPrototype' is not null or undefined
            assertParamExists('updateFunctionalBlock', 'functionalBlockPojoPrototype', functionalBlockPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/functional-blocks/{uid}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"uid"}}`, encodeURIComponent(String(uid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (operationType !== undefined) {
                localVarQueryParameter['operationType'] = operationType;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(functionalBlockPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FunctionalBlockControllerApi - functional programming interface
 * @export
 */
export const FunctionalBlockControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FunctionalBlockControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Computes functional blocks
         * @summary Computes functional blocks
         * @param {EntityId} projectId the project ID
         * @param {Set<string>} requestBody The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeFunctionalBlock(projectId: EntityId, requestBody: Set<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeFunctionalBlock(projectId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a functional block
         * @summary Create a functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFunctionalBlock(projectId: EntityId, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionalBlockPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFunctionalBlock(projectId, functionalBlockPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutomatedFunctionalBlock(projectId: EntityId, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutomatedFunctionalBlock(projectId, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a functional block
         * @summary Delete a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFunctionalBlock(projectId: EntityId, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFunctionalBlock(projectId, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  execute reachability Analysis on Blocks
         * @summary execute reachability Analysis on Blocks
         * @param {EntityId} projectId the project ID
         * @param {ReachabilityAnalysisRequest} reachabilityAnalysisRequest ReachabilityBlockComputationRequest to compute reachability blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async executeReachabilityAnalysis(projectId: EntityId, reachabilityAnalysisRequest: ReachabilityAnalysisRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.executeReachabilityAnalysis(projectId, reachabilityAnalysisRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s of the module to generate functional blocksfor example &#x3D; \&quot;{1}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async functionalBlockGeneration(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.functionalBlockGeneration(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates functional blocks for business variables using data lineage
         * @summary Generates functional blocks for business variables using data lineage
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId The module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateFunctionalBlocksUsingDataLineage(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateFunctionalBlocksUsingDataLineage(projectId, entityId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates description a for reachability block using generative AI.
         * @summary Generates description a for reachability block using generative AI.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the UID of the functional block
         * @param {boolean} [generateModuleDescriptions] whether descriptions of modules in the functional block should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateReachabilityBlockDescription(projectId: EntityId, uid: string, generateModuleDescriptions?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateReachabilityBlockDescription(projectId, uid, generateModuleDescriptions, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  creates a control flow graph using the functional units contained in the given block
         * @summary creates a control flow graph using the functional units contained in the given block
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControlFlowGraphForFunctionalUnits(projectId: EntityId, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlFlowGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControlFlowGraphForFunctionalUnits(projectId, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a control flow graph.
         * @summary convert the given functional block (given by uid parameter) into a control flow graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionalBlockAsControlFlowGraph(projectId: EntityId, uid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControlFlowGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionalBlockAsControlFlowGraph(projectId, uid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a dependency graph.
         * @summary convert the given functional block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityBlockGraphFilterRequest} [reachabilityBlockGraphFilterRequest] DependencyGraphFilterRequest to filter the dependency graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFunctionalBlockAsDependencyGraph(projectId: EntityId, uid: string, reachabilityBlockGraphFilterRequest?: ReachabilityBlockGraphFilterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependencyGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFunctionalBlockAsDependencyGraph(projectId, uid, reachabilityBlockGraphFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @summary convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityNetworkGraphFilterRequest} reachabilityNetworkGraphFilterRequest Filter Object to filter the network graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getReachabilityNetworkGraph(projectId: EntityId, uid: string, reachabilityNetworkGraphFilterRequest: ReachabilityNetworkGraphFilterRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependencyGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getReachabilityNetworkGraph(projectId, uid, reachabilityNetworkGraphFilterRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  merge functional block
         * @summary merge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Block Pojo for merging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.mergeFunctionalBlock(projectId, functionalBlockMergeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Recalculates outdated functional blocks
         * @summary Recalculates outdated functional blocks
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recalculateOutDatedFunctionalBlocks(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recalculateOutDatedFunctionalBlocks(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Removes functional blocks Having No UpperBound Module
         * @summary Removes functional blocks Having No UpperBound Module
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeFunctionalBlocksWithoutUpperBoundModule(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeFunctionalBlocksWithoutUpperBoundModule(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Unmerge functional block
         * @summary Unmerge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Pojo for Unmerging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unmergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unmergeFunctionalBlock(projectId, functionalBlockMergeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  change status functional block
         * @summary change status functional block
         * @param {EntityId} projectId the project ID
         * @param {'ACTIVE' | 'INACTIVE'} status the status of the functional block to be updated to
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateBlockStatus(projectId: EntityId, status: 'ACTIVE' | 'INACTIVE', requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateBlockStatus(projectId, status, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a functional block
         * @summary Update a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the uid
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to update
         * @param {string} [operationType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFunctionalBlock(projectId: EntityId, uid: string, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, operationType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FunctionalBlockPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFunctionalBlock(projectId, uid, functionalBlockPojoPrototype, operationType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FunctionalBlockControllerApi - factory interface
 * @export
 */
export const FunctionalBlockControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FunctionalBlockControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Computes functional blocks
         * @summary Computes functional blocks
         * @param {EntityId} projectId the project ID
         * @param {Set<string>} requestBody The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeFunctionalBlock(projectId: EntityId, requestBody: Set<string>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.computeFunctionalBlock(projectId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a functional block
         * @summary Create a functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFunctionalBlock(projectId: EntityId, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, options?: any): AxiosPromise<FunctionalBlockPojo> {
            return localVarFp.createFunctionalBlock(projectId, functionalBlockPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutomatedFunctionalBlock(projectId: EntityId, uid: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.deleteAutomatedFunctionalBlock(projectId, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a functional block
         * @summary Delete a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the ID of the functional block to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFunctionalBlock(projectId: EntityId, uid: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteFunctionalBlock(projectId, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  execute reachability Analysis on Blocks
         * @summary execute reachability Analysis on Blocks
         * @param {EntityId} projectId the project ID
         * @param {ReachabilityAnalysisRequest} reachabilityAnalysisRequest ReachabilityBlockComputationRequest to compute reachability blocks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        executeReachabilityAnalysis(projectId: EntityId, reachabilityAnalysisRequest: ReachabilityAnalysisRequest, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.executeReachabilityAnalysis(projectId, reachabilityAnalysisRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher list of id\&#39;s of the module to generate functional blocksfor example &#x3D; \&quot;{1}\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        functionalBlockGeneration(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.functionalBlockGeneration(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates functional blocks for business variables using data lineage
         * @summary Generates functional blocks for business variables using data lineage
         * @param {EntityId} projectId the project ID
         * @param {Array<EntityId>} entityId The module id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateFunctionalBlocksUsingDataLineage(projectId: EntityId, entityId: Array<EntityId>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.generateFunctionalBlocksUsingDataLineage(projectId, entityId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generates description a for reachability block using generative AI.
         * @summary Generates description a for reachability block using generative AI.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the UID of the functional block
         * @param {boolean} [generateModuleDescriptions] whether descriptions of modules in the functional block should be generated automatically
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateReachabilityBlockDescription(projectId: EntityId, uid: string, generateModuleDescriptions?: boolean, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.generateReachabilityBlockDescription(projectId, uid, generateModuleDescriptions, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  creates a control flow graph using the functional units contained in the given block
         * @summary creates a control flow graph using the functional units contained in the given block
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControlFlowGraphForFunctionalUnits(projectId: EntityId, uid: string, options?: any): AxiosPromise<ControlFlowGraph> {
            return localVarFp.getControlFlowGraphForFunctionalUnits(projectId, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a control flow graph.
         * @summary convert the given functional block (given by uid parameter) into a control flow graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockAsControlFlowGraph(projectId: EntityId, uid: string, options?: any): AxiosPromise<ControlFlowGraph> {
            return localVarFp.getFunctionalBlockAsControlFlowGraph(projectId, uid, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a dependency graph.
         * @summary convert the given functional block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityBlockGraphFilterRequest} [reachabilityBlockGraphFilterRequest] DependencyGraphFilterRequest to filter the dependency graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFunctionalBlockAsDependencyGraph(projectId: EntityId, uid: string, reachabilityBlockGraphFilterRequest?: ReachabilityBlockGraphFilterRequest, options?: any): AxiosPromise<DependencyGraph> {
            return localVarFp.getFunctionalBlockAsDependencyGraph(projectId, uid, reachabilityBlockGraphFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @summary convert the given reachability network block (given by uid parameter) into a dependency graph.
         * @param {EntityId} projectId the ID of the project
         * @param {string} uid the uid of the block
         * @param {ReachabilityNetworkGraphFilterRequest} reachabilityNetworkGraphFilterRequest Filter Object to filter the network graph
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getReachabilityNetworkGraph(projectId: EntityId, uid: string, reachabilityNetworkGraphFilterRequest: ReachabilityNetworkGraphFilterRequest, options?: any): AxiosPromise<DependencyGraph> {
            return localVarFp.getReachabilityNetworkGraph(projectId, uid, reachabilityNetworkGraphFilterRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  merge functional block
         * @summary merge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Block Pojo for merging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.mergeFunctionalBlock(projectId, functionalBlockMergeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Recalculates outdated functional blocks
         * @summary Recalculates outdated functional blocks
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recalculateOutDatedFunctionalBlocks(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.recalculateOutDatedFunctionalBlocks(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Removes functional blocks Having No UpperBound Module
         * @summary Removes functional blocks Having No UpperBound Module
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeFunctionalBlocksWithoutUpperBoundModule(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.removeFunctionalBlocksWithoutUpperBoundModule(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Unmerge functional block
         * @summary Unmerge functional block
         * @param {EntityId} projectId the project ID
         * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Pojo for Unmerging
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unmergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.unmergeFunctionalBlock(projectId, functionalBlockMergeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  change status functional block
         * @summary change status functional block
         * @param {EntityId} projectId the project ID
         * @param {'ACTIVE' | 'INACTIVE'} status the status of the functional block to be updated to
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateBlockStatus(projectId: EntityId, status: 'ACTIVE' | 'INACTIVE', requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.updateBlockStatus(projectId, status, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a functional block
         * @summary Update a functional block
         * @param {EntityId} projectId the project ID
         * @param {string} uid the uid
         * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to update
         * @param {string} [operationType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFunctionalBlock(projectId: EntityId, uid: string, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, operationType?: string, options?: any): AxiosPromise<FunctionalBlockPojo> {
            return localVarFp.updateFunctionalBlock(projectId, uid, functionalBlockPojoPrototype, operationType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FunctionalBlockControllerApi - object-oriented interface
 * @export
 * @class FunctionalBlockControllerApi
 * @extends {BaseAPI}
 */
export class FunctionalBlockControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Computes functional blocks
     * @summary Computes functional blocks
     * @param {EntityId} projectId the project ID
     * @param {Set<string>} requestBody The functional block to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public computeFunctionalBlock(projectId: EntityId, requestBody: Set<string>, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).computeFunctionalBlock(projectId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Create a functional block
     * @summary Create a functional block
     * @param {EntityId} projectId the project ID
     * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public createFunctionalBlock(projectId: EntityId, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).createFunctionalBlock(projectId, functionalBlockPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
     * @summary Starts a job that deletes the functional block and and its children of type Functional_Condition and Functional Units of type Functional that are not children of any other Functional Block and returns the job Id See the job status at \'/v1/jobs/{jobId}/info
     * @param {EntityId} projectId the project ID
     * @param {string} uid the ID of the functional block to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public deleteAutomatedFunctionalBlock(projectId: EntityId, uid: string, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).deleteAutomatedFunctionalBlock(projectId, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Delete a functional block
     * @summary Delete a functional block
     * @param {EntityId} projectId the project ID
     * @param {string} uid the ID of the functional block to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public deleteFunctionalBlock(projectId: EntityId, uid: string, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).deleteFunctionalBlock(projectId, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  execute reachability Analysis on Blocks
     * @summary execute reachability Analysis on Blocks
     * @param {EntityId} projectId the project ID
     * @param {ReachabilityAnalysisRequest} reachabilityAnalysisRequest ReachabilityBlockComputationRequest to compute reachability blocks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public executeReachabilityAnalysis(projectId: EntityId, reachabilityAnalysisRequest: ReachabilityAnalysisRequest, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).executeReachabilityAnalysis(projectId, reachabilityAnalysisRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that generates functional block for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher list of id\&#39;s of the module to generate functional blocksfor example &#x3D; \&quot;{1}\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public functionalBlockGeneration(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).functionalBlockGeneration(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Generates functional blocks for business variables using data lineage
     * @summary Generates functional blocks for business variables using data lineage
     * @param {EntityId} projectId the project ID
     * @param {Array<EntityId>} entityId The module id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public generateFunctionalBlocksUsingDataLineage(projectId: EntityId, entityId: Array<EntityId>, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).generateFunctionalBlocksUsingDataLineage(projectId, entityId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Generates description a for reachability block using generative AI.
     * @summary Generates description a for reachability block using generative AI.
     * @param {EntityId} projectId the ID of the project
     * @param {string} uid the UID of the functional block
     * @param {boolean} [generateModuleDescriptions] whether descriptions of modules in the functional block should be generated automatically
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public generateReachabilityBlockDescription(projectId: EntityId, uid: string, generateModuleDescriptions?: boolean, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).generateReachabilityBlockDescription(projectId, uid, generateModuleDescriptions, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  creates a control flow graph using the functional units contained in the given block
     * @summary creates a control flow graph using the functional units contained in the given block
     * @param {EntityId} projectId the ID of the project
     * @param {string} uid the uid of the block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public getControlFlowGraphForFunctionalUnits(projectId: EntityId, uid: string, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).getControlFlowGraphForFunctionalUnits(projectId, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a control flow graph.
     * @summary convert the given functional block (given by uid parameter) into a control flow graph.
     * @param {EntityId} projectId the ID of the project
     * @param {string} uid the uid of the block
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public getFunctionalBlockAsControlFlowGraph(projectId: EntityId, uid: string, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).getFunctionalBlockAsControlFlowGraph(projectId, uid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  convert the given functional block (given by uid parameter) into a dependency graph.
     * @summary convert the given functional block (given by uid parameter) into a dependency graph.
     * @param {EntityId} projectId the ID of the project
     * @param {string} uid the uid of the block
     * @param {ReachabilityBlockGraphFilterRequest} [reachabilityBlockGraphFilterRequest] DependencyGraphFilterRequest to filter the dependency graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public getFunctionalBlockAsDependencyGraph(projectId: EntityId, uid: string, reachabilityBlockGraphFilterRequest?: ReachabilityBlockGraphFilterRequest, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).getFunctionalBlockAsDependencyGraph(projectId, uid, reachabilityBlockGraphFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  convert the given reachability network block (given by uid parameter) into a dependency graph.
     * @summary convert the given reachability network block (given by uid parameter) into a dependency graph.
     * @param {EntityId} projectId the ID of the project
     * @param {string} uid the uid of the block
     * @param {ReachabilityNetworkGraphFilterRequest} reachabilityNetworkGraphFilterRequest Filter Object to filter the network graph
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public getReachabilityNetworkGraph(projectId: EntityId, uid: string, reachabilityNetworkGraphFilterRequest: ReachabilityNetworkGraphFilterRequest, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).getReachabilityNetworkGraph(projectId, uid, reachabilityNetworkGraphFilterRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  merge functional block
     * @summary merge functional block
     * @param {EntityId} projectId the project ID
     * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Block Pojo for merging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public mergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).mergeFunctionalBlock(projectId, functionalBlockMergeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Recalculates outdated functional blocks
     * @summary Recalculates outdated functional blocks
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public recalculateOutDatedFunctionalBlocks(projectId: EntityId, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).recalculateOutDatedFunctionalBlocks(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Removes functional blocks Having No UpperBound Module
     * @summary Removes functional blocks Having No UpperBound Module
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public removeFunctionalBlocksWithoutUpperBoundModule(projectId: EntityId, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).removeFunctionalBlocksWithoutUpperBoundModule(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Unmerge functional block
     * @summary Unmerge functional block
     * @param {EntityId} projectId the project ID
     * @param {FunctionalBlockMergeRequest} functionalBlockMergeRequest FunctionalBlockMergeRequest Pojo for Unmerging
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public unmergeFunctionalBlock(projectId: EntityId, functionalBlockMergeRequest: FunctionalBlockMergeRequest, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).unmergeFunctionalBlock(projectId, functionalBlockMergeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  change status functional block
     * @summary change status functional block
     * @param {EntityId} projectId the project ID
     * @param {'ACTIVE' | 'INACTIVE'} status the status of the functional block to be updated to
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public updateBlockStatus(projectId: EntityId, status: 'ACTIVE' | 'INACTIVE', requestBody: Array<string>, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).updateBlockStatus(projectId, status, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update a functional block
     * @summary Update a functional block
     * @param {EntityId} projectId the project ID
     * @param {string} uid the uid
     * @param {FunctionalBlockPojoPrototype} functionalBlockPojoPrototype The functional block to update
     * @param {string} [operationType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FunctionalBlockControllerApi
     */
    public updateFunctionalBlock(projectId: EntityId, uid: string, functionalBlockPojoPrototype: FunctionalBlockPojoPrototype, operationType?: string, options?: AxiosRequestConfig) {
        return FunctionalBlockControllerApiFp(this.configuration).updateFunctionalBlock(projectId, uid, functionalBlockPojoPrototype, operationType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * HotSpotControllerApi - axios parameter creator
 * @export
 */
export const HotSpotControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {number} limit the number of hotspots to be returned default being 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotspots: async (projectId: EntityId, hotspotType: string, limit: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getHotspots', 'projectId', projectId)
            // verify required parameter 'hotspotType' is not null or undefined
            assertParamExists('getHotspots', 'hotspotType', hotspotType)
            // verify required parameter 'limit' is not null or undefined
            assertParamExists('getHotspots', 'limit', limit)
            const localVarPath = `/api/v1/projects/{projectId}/hotspots/{hotspotType}/{limit}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"hotspotType"}}`, encodeURIComponent(String(hotspotType)))
                .replace(`{${"limit"}}`, encodeURIComponent(String(limit)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotspots1: async (projectId: EntityId, hotspotType: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getHotspots1', 'projectId', projectId)
            // verify required parameter 'hotspotType' is not null or undefined
            assertParamExists('getHotspots1', 'hotspotType', hotspotType)
            const localVarPath = `/api/v1/projects/{projectId}/hotspots/{hotspotType}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"hotspotType"}}`, encodeURIComponent(String(hotspotType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HotSpotControllerApi - functional programming interface
 * @export
 */
export const HotSpotControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = HotSpotControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {number} limit the number of hotspots to be returned default being 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHotspots(projectId: EntityId, hotspotType: string, limit: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HotSpot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHotspots(projectId, hotspotType, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHotspots1(projectId: EntityId, hotspotType: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HotSpot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHotspots1(projectId, hotspotType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * HotSpotControllerApi - factory interface
 * @export
 */
export const HotSpotControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = HotSpotControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {number} limit the number of hotspots to be returned default being 10
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotspots(projectId: EntityId, hotspotType: string, limit: number, options?: any): AxiosPromise<Array<HotSpot>> {
            return localVarFp.getHotspots(projectId, hotspotType, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
         * @summary List all Hotspots for the given projectid and hotspot type
         * @param {EntityId} projectId the ID of the project to list hotspots from
         * @param {string} hotspotType type of hotspot
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHotspots1(projectId: EntityId, hotspotType: string, options?: any): AxiosPromise<Array<HotSpot>> {
            return localVarFp.getHotspots1(projectId, hotspotType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * HotSpotControllerApi - object-oriented interface
 * @export
 * @class HotSpotControllerApi
 * @extends {BaseAPI}
 */
export class HotSpotControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
     * @summary List all Hotspots for the given projectid and hotspot type
     * @param {EntityId} projectId the ID of the project to list hotspots from
     * @param {string} hotspotType type of hotspot
     * @param {number} limit the number of hotspots to be returned default being 10
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotSpotControllerApi
     */
    public getHotspots(projectId: EntityId, hotspotType: string, limit: number, options?: AxiosRequestConfig) {
        return HotSpotControllerApiFp(this.configuration).getHotspots(projectId, hotspotType, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all Hotspots for the given projectid and hotspot type
     * @summary List all Hotspots for the given projectid and hotspot type
     * @param {EntityId} projectId the ID of the project to list hotspots from
     * @param {string} hotspotType type of hotspot
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HotSpotControllerApi
     */
    public getHotspots1(projectId: EntityId, hotspotType: string, options?: AxiosRequestConfig) {
        return HotSpotControllerApiFp(this.configuration).getHotspots1(projectId, hotspotType, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InfoControllerApi - axios parameter creator
 * @export
 */
export const InfoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,discovery-light,mining  Common mining-api information
         * @summary Common mining-api information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InfoControllerApi - functional programming interface
 * @export
 */
export const InfoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InfoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,discovery-light,mining  Common mining-api information
         * @summary Common mining-api information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InfoControllerApi - factory interface
 * @export
 */
export const InfoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InfoControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,discovery-light,mining  Common mining-api information
         * @summary Common mining-api information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInfo(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InfoControllerApi - object-oriented interface
 * @export
 * @class InfoControllerApi
 * @extends {BaseAPI}
 */
export class InfoControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): discovery,discovery-light,mining  Common mining-api information
     * @summary Common mining-api information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InfoControllerApi
     */
    public getInfo(options?: AxiosRequestConfig) {
        return InfoControllerApiFp(this.configuration).getInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IoControllerApi - axios parameter creator
 * @export
 */
export const IoControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Source Objects
         * @summary Downloads Source Objects
         * @param {EntityId} projectId the ID of the project
         * @param {number} [baseRevision] Base revision (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceObject: async (projectId: EntityId, baseRevision?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('downloadSourceObject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/source-objects`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (baseRevision !== undefined) {
                localVarQueryParameter['baseRevision'] = baseRevision;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports a CSV file from a Mining project
         * @summary Exports a CSV file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCsv: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportCsv', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/csv`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Effort Summary Excel file from a Mining project
         * @summary Exports an Effort Summary Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEffortSummaryExcel: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportEffortSummaryExcel', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/effort-summary-excel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Excel file from a Mining project
         * @summary Exports an Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportExcel: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportExcel', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/excel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Export Mining data to specific format
         * @summary Export Mining data to specific format
         * @param {EntityId} projectId the ID of the project
         * @param {string} exportFormat the export format
         * @param {object} queryParams parameters for the export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportToFormat: async (projectId: EntityId, exportFormat: string, queryParams: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('exportToFormat', 'projectId', projectId)
            // verify required parameter 'exportFormat' is not null or undefined
            assertParamExists('exportToFormat', 'exportFormat', exportFormat)
            // verify required parameter 'queryParams' is not null or undefined
            assertParamExists('exportToFormat', 'queryParams', queryParams)
            const localVarPath = `/api/v1/projects/{projectId}/export/{exportFormat}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"exportFormat"}}`, encodeURIComponent(String(exportFormat)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (queryParams !== undefined) {
                localVarQueryParameter['queryParams'] = queryParams;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Gets a list of supported export formats
         * @summary Gets a list of supported export formats
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportFormats: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getExportFormats', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/export-formats`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports a CSV file into a Mining project
         * @summary Imports a CSV file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCSV: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importCSV', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importCSV', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/csv`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports an Excel file into a Mining project
         * @summary Imports an Excel file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importExcel: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importExcel', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importExcel', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/excel`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Imports source objects from the entries of a Zip file into a Mining project
         * @summary Imports source objects from the entries of a Zip file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSourceObjects: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importSourceObjects', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importSourceObjects', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/source-objects`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IoControllerApi - functional programming interface
 * @export
 */
export const IoControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IoControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Source Objects
         * @summary Downloads Source Objects
         * @param {EntityId} projectId the ID of the project
         * @param {number} [baseRevision] Base revision (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadSourceObject(projectId: EntityId, baseRevision?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadSourceObject(projectId, baseRevision, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports a CSV file from a Mining project
         * @summary Exports a CSV file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportCsv(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportCsv(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Effort Summary Excel file from a Mining project
         * @summary Exports an Effort Summary Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportEffortSummaryExcel(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportEffortSummaryExcel(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Excel file from a Mining project
         * @summary Exports an Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportExcel(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportExcel(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Export Mining data to specific format
         * @summary Export Mining data to specific format
         * @param {EntityId} projectId the ID of the project
         * @param {string} exportFormat the export format
         * @param {object} queryParams parameters for the export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exportToFormat(projectId: EntityId, exportFormat: string, queryParams: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exportToFormat(projectId, exportFormat, queryParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Gets a list of supported export formats
         * @summary Gets a list of supported export formats
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExportFormats(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ExportFormatDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExportFormats(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports a CSV file into a Mining project
         * @summary Imports a CSV file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importCSV(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importCSV(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports an Excel file into a Mining project
         * @summary Imports an Excel file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importExcel(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importExcel(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Imports source objects from the entries of a Zip file into a Mining project
         * @summary Imports source objects from the entries of a Zip file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importSourceObjects(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importSourceObjects(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IoControllerApi - factory interface
 * @export
 */
export const IoControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IoControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Source Objects
         * @summary Downloads Source Objects
         * @param {EntityId} projectId the ID of the project
         * @param {number} [baseRevision] Base revision (Optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadSourceObject(projectId: EntityId, baseRevision?: number, options?: any): AxiosPromise<void> {
            return localVarFp.downloadSourceObject(projectId, baseRevision, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports a CSV file from a Mining project
         * @summary Exports a CSV file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportCsv(projectId: EntityId, options?: any): AxiosPromise<File> {
            return localVarFp.exportCsv(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Effort Summary Excel file from a Mining project
         * @summary Exports an Effort Summary Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportEffortSummaryExcel(projectId: EntityId, options?: any): AxiosPromise<File> {
            return localVarFp.exportEffortSummaryExcel(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Excel file from a Mining project
         * @summary Exports an Excel file from a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportExcel(projectId: EntityId, options?: any): AxiosPromise<File> {
            return localVarFp.exportExcel(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Export Mining data to specific format
         * @summary Export Mining data to specific format
         * @param {EntityId} projectId the ID of the project
         * @param {string} exportFormat the export format
         * @param {object} queryParams parameters for the export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportToFormat(projectId: EntityId, exportFormat: string, queryParams: object, options?: any): AxiosPromise<File> {
            return localVarFp.exportToFormat(projectId, exportFormat, queryParams, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Gets a list of supported export formats
         * @summary Gets a list of supported export formats
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExportFormats(projectId: EntityId, options?: any): AxiosPromise<Array<ExportFormatDescription>> {
            return localVarFp.getExportFormats(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports a CSV file into a Mining project
         * @summary Imports a CSV file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importCSV(projectId: EntityId, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.importCSV(projectId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Imports an Excel file into a Mining project
         * @summary Imports an Excel file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importExcel(projectId: EntityId, file: File, options?: any): AxiosPromise<void> {
            return localVarFp.importExcel(projectId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): discovery,mining  Imports source objects from the entries of a Zip file into a Mining project
         * @summary Imports source objects from the entries of a Zip file into a Mining project
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importSourceObjects(projectId: EntityId, file: File, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.importSourceObjects(projectId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IoControllerApi - object-oriented interface
 * @export
 * @class IoControllerApi
 * @extends {BaseAPI}
 */
export class IoControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): discovery,mining  Downloads Source Objects
     * @summary Downloads Source Objects
     * @param {EntityId} projectId the ID of the project
     * @param {number} [baseRevision] Base revision (Optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public downloadSourceObject(projectId: EntityId, baseRevision?: number, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).downloadSourceObject(projectId, baseRevision, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Exports a CSV file from a Mining project
     * @summary Exports a CSV file from a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public exportCsv(projectId: EntityId, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).exportCsv(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Effort Summary Excel file from a Mining project
     * @summary Exports an Effort Summary Excel file from a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public exportEffortSummaryExcel(projectId: EntityId, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).exportEffortSummaryExcel(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Exports an Excel file from a Mining project
     * @summary Exports an Excel file from a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public exportExcel(projectId: EntityId, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).exportExcel(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Export Mining data to specific format
     * @summary Export Mining data to specific format
     * @param {EntityId} projectId the ID of the project
     * @param {string} exportFormat the export format
     * @param {object} queryParams parameters for the export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public exportToFormat(projectId: EntityId, exportFormat: string, queryParams: object, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).exportToFormat(projectId, exportFormat, queryParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Gets a list of supported export formats
     * @summary Gets a list of supported export formats
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public getExportFormats(projectId: EntityId, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).getExportFormats(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Imports a CSV file into a Mining project
     * @summary Imports a CSV file into a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public importCSV(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).importCSV(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Imports an Excel file into a Mining project
     * @summary Imports an Excel file into a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public importExcel(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).importExcel(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): discovery,mining  Imports source objects from the entries of a Zip file into a Mining project
     * @summary Imports source objects from the entries of a Zip file into a Mining project
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IoControllerApi
     */
    public importSourceObjects(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return IoControllerApiFp(this.configuration).importSourceObjects(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * JobControllerApi - axios parameter creator
 * @export
 */
export const JobControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job to cancel
         * @summary Requests the job to cancel
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('cancelJob', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{jobId}/cancel`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @summary Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Deletes the job based on id
         * @summary Deletes the job based on id
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob1: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('deleteJob1', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{jobId}`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the info of the job
         * @summary Requests the info of the job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInformation: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobInformation', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{jobId}/info`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the information of all jobs if the user is authorized to access the jobs
         * @summary Requests the information of all jobs if the user is authorized to access the jobs
         * @param {number} size the size of each page
         * @param {string} [query] The filter query in RSQL syntax. Possible filter properties are \&#39;jobId\&#39;, \&#39;userName\&#39;, \&#39;status\&#39;, \&#39;submitTime\&#39;, \&#39;scheduledStartTime\&#39;, \&#39;startTime\&#39; and \&#39;finishTime\&#39;. Time values have to be in ISO-8601 format.
         * @param {number} [page] the page number to be fetched
         * @param {string} [sortBy] the sort conditions as array of sortString
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInformations: async (size: number, query?: string, page?: number, sortBy?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'size' is not null or undefined
            assertParamExists('getJobInformations', 'size', size)
            const localVarPath = `/api/v1/jobs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log
         * @summary Requests the job log
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLog: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobLog', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{jobId}/log`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log streamed
         * @summary Requests the job log streamed
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLogStreamed: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobLogStreamed', 'jobId', jobId)
            const localVarPath = `/api/v2/jobs/{jobId}/log`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Gets the result of a job
         * @summary Gets the result of a job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult: async (jobId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobId' is not null or undefined
            assertParamExists('getJobResult', 'jobId', jobId)
            const localVarPath = `/api/v1/jobs/{jobId}/result`
                .replace(`{${"jobId"}}`, encodeURIComponent(String(jobId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId The job extension id
         * @param {{ [key: string]: Array<string>; }} requestBody The parameters of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJobExtension: async (projectId: EntityId, extensionId: string, requestBody: { [key: string]: Array<string>; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('submitJobExtension', 'projectId', projectId)
            // verify required parameter 'extensionId' is not null or undefined
            assertParamExists('submitJobExtension', 'extensionId', extensionId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('submitJobExtension', 'requestBody', requestBody)
            const localVarPath = `/api/v1/projects/{projectId}/job-extensions/{extensionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"extensionId"}}`, encodeURIComponent(String(extensionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId the job extension id
         * @param {object} parameters parameters for the job
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJobExtensionV2: async (projectId: EntityId, extensionId: string, parameters: object, file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('submitJobExtensionV2', 'projectId', projectId)
            // verify required parameter 'extensionId' is not null or undefined
            assertParamExists('submitJobExtensionV2', 'extensionId', extensionId)
            // verify required parameter 'parameters' is not null or undefined
            assertParamExists('submitJobExtensionV2', 'parameters', parameters)
            const localVarPath = `/api/v2/projects/{projectId}/job-extensions/{extensionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"extensionId"}}`, encodeURIComponent(String(extensionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (parameters !== undefined) {
                localVarQueryParameter['parameters'] = parameters;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job for Taxonomy Propagation
         * @summary Submits a job for Taxonomy Propagation
         * @param {EntityId} projectId the ID of the project
         * @param {Array<PropagationData>} propagationData the propagationData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTaxonomyPropagation: async (projectId: EntityId, propagationData: Array<PropagationData>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('submitTaxonomyPropagation', 'projectId', projectId)
            // verify required parameter 'propagationData' is not null or undefined
            assertParamExists('submitTaxonomyPropagation', 'propagationData', propagationData)
            const localVarPath = `/api/v1/projects/{projectId}/job-extensions/taxonomyPropagation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(propagationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * JobControllerApi - functional programming interface
 * @export
 */
export const JobControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = JobControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job to cancel
         * @summary Requests the job to cancel
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelJob(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelJob(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @summary Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Deletes the job based on id
         * @summary Deletes the job based on id
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteJob1(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteJob1(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the info of the job
         * @summary Requests the info of the job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobInformation(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JobInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobInformation(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the information of all jobs if the user is authorized to access the jobs
         * @summary Requests the information of all jobs if the user is authorized to access the jobs
         * @param {number} size the size of each page
         * @param {string} [query] The filter query in RSQL syntax. Possible filter properties are \&#39;jobId\&#39;, \&#39;userName\&#39;, \&#39;status\&#39;, \&#39;submitTime\&#39;, \&#39;scheduledStartTime\&#39;, \&#39;startTime\&#39; and \&#39;finishTime\&#39;. Time values have to be in ISO-8601 format.
         * @param {number} [page] the page number to be fetched
         * @param {string} [sortBy] the sort conditions as array of sortString
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobInformations(size: number, query?: string, page?: number, sortBy?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedJobInformation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobInformations(size, query, page, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log
         * @summary Requests the job log
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobLog(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLog(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log streamed
         * @summary Requests the job log streamed
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobLogStreamed(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobLogStreamed(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Gets the result of a job
         * @summary Gets the result of a job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getJobResult(jobId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getJobResult(jobId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId The job extension id
         * @param {{ [key: string]: Array<string>; }} requestBody The parameters of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitJobExtension(projectId: EntityId, extensionId: string, requestBody: { [key: string]: Array<string>; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitJobExtension(projectId, extensionId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId the job extension id
         * @param {object} parameters parameters for the job
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitJobExtensionV2(projectId: EntityId, extensionId: string, parameters: object, file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitJobExtensionV2(projectId, extensionId, parameters, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job for Taxonomy Propagation
         * @summary Submits a job for Taxonomy Propagation
         * @param {EntityId} projectId the ID of the project
         * @param {Array<PropagationData>} propagationData the propagationData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitTaxonomyPropagation(projectId: EntityId, propagationData: Array<PropagationData>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitTaxonomyPropagation(projectId, propagationData, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * JobControllerApi - factory interface
 * @export
 */
export const JobControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = JobControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job to cancel
         * @summary Requests the job to cancel
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelJob(jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.cancelJob(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @summary Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob(options?: any): AxiosPromise<number> {
            return localVarFp.deleteJob(options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Deletes the job based on id
         * @summary Deletes the job based on id
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteJob1(jobId: string, options?: any): AxiosPromise<number> {
            return localVarFp.deleteJob1(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the info of the job
         * @summary Requests the info of the job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInformation(jobId: string, options?: any): AxiosPromise<JobInformation> {
            return localVarFp.getJobInformation(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the information of all jobs if the user is authorized to access the jobs
         * @summary Requests the information of all jobs if the user is authorized to access the jobs
         * @param {number} size the size of each page
         * @param {string} [query] The filter query in RSQL syntax. Possible filter properties are \&#39;jobId\&#39;, \&#39;userName\&#39;, \&#39;status\&#39;, \&#39;submitTime\&#39;, \&#39;scheduledStartTime\&#39;, \&#39;startTime\&#39; and \&#39;finishTime\&#39;. Time values have to be in ISO-8601 format.
         * @param {number} [page] the page number to be fetched
         * @param {string} [sortBy] the sort conditions as array of sortString
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobInformations(size: number, query?: string, page?: number, sortBy?: string, options?: any): AxiosPromise<PagedJobInformation> {
            return localVarFp.getJobInformations(size, query, page, sortBy, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log
         * @summary Requests the job log
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLog(jobId: string, options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getJobLog(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log streamed
         * @summary Requests the job log streamed
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobLogStreamed(jobId: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getJobLogStreamed(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Gets the result of a job
         * @summary Gets the result of a job
         * @param {string} jobId the job id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getJobResult(jobId: string, options?: any): AxiosPromise<void> {
            return localVarFp.getJobResult(jobId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId The job extension id
         * @param {{ [key: string]: Array<string>; }} requestBody The parameters of the job
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJobExtension(projectId: EntityId, extensionId: string, requestBody: { [key: string]: Array<string>; }, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.submitJobExtension(projectId, extensionId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
         * @summary Submits a job contributed by a job extension
         * @param {EntityId} projectId the ID of the project
         * @param {string} extensionId the job extension id
         * @param {object} parameters parameters for the job
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitJobExtensionV2(projectId: EntityId, extensionId: string, parameters: object, file?: File, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.submitJobExtensionV2(projectId, extensionId, parameters, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job for Taxonomy Propagation
         * @summary Submits a job for Taxonomy Propagation
         * @param {EntityId} projectId the ID of the project
         * @param {Array<PropagationData>} propagationData the propagationData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitTaxonomyPropagation(projectId: EntityId, propagationData: Array<PropagationData>, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.submitTaxonomyPropagation(projectId, propagationData, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * JobControllerApi - object-oriented interface
 * @export
 * @class JobControllerApi
 * @extends {BaseAPI}
 */
export class JobControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job to cancel
     * @summary Requests the job to cancel
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public cancelJob(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).cancelJob(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
     * @summary Delete all the jobs submitted by the user. In case of an admin user, it deletes all the jobs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public deleteJob(options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).deleteJob(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Deletes the job based on id
     * @summary Deletes the job based on id
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public deleteJob1(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).deleteJob1(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the info of the job
     * @summary Requests the info of the job
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public getJobInformation(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).getJobInformation(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the information of all jobs if the user is authorized to access the jobs
     * @summary Requests the information of all jobs if the user is authorized to access the jobs
     * @param {number} size the size of each page
     * @param {string} [query] The filter query in RSQL syntax. Possible filter properties are \&#39;jobId\&#39;, \&#39;userName\&#39;, \&#39;status\&#39;, \&#39;submitTime\&#39;, \&#39;scheduledStartTime\&#39;, \&#39;startTime\&#39; and \&#39;finishTime\&#39;. Time values have to be in ISO-8601 format.
     * @param {number} [page] the page number to be fetched
     * @param {string} [sortBy] the sort conditions as array of sortString
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public getJobInformations(size: number, query?: string, page?: number, sortBy?: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).getJobInformations(size, query, page, sortBy, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log
     * @summary Requests the job log
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public getJobLog(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).getJobLog(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Requests the job log streamed
     * @summary Requests the job log streamed
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public getJobLogStreamed(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).getJobLogStreamed(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining,discovery,discovery-light  Gets the result of a job
     * @summary Gets the result of a job
     * @param {string} jobId the job id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public getJobResult(jobId: string, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).getJobResult(jobId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
     * @summary Submits a job contributed by a job extension
     * @param {EntityId} projectId the ID of the project
     * @param {string} extensionId The job extension id
     * @param {{ [key: string]: Array<string>; }} requestBody The parameters of the job
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public submitJobExtension(projectId: EntityId, extensionId: string, requestBody: { [key: string]: Array<string>; }, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).submitJobExtension(projectId, extensionId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job contributed by a job extension
     * @summary Submits a job contributed by a job extension
     * @param {EntityId} projectId the ID of the project
     * @param {string} extensionId the job extension id
     * @param {object} parameters parameters for the job
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public submitJobExtensionV2(projectId: EntityId, extensionId: string, parameters: object, file?: File, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).submitJobExtensionV2(projectId, extensionId, parameters, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Submits a job for Taxonomy Propagation
     * @summary Submits a job for Taxonomy Propagation
     * @param {EntityId} projectId the ID of the project
     * @param {Array<PropagationData>} propagationData the propagationData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof JobControllerApi
     */
    public submitTaxonomyPropagation(projectId: EntityId, propagationData: Array<PropagationData>, options?: AxiosRequestConfig) {
        return JobControllerApiFp(this.configuration).submitTaxonomyPropagation(projectId, propagationData, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeycloakConfigurationControllerApi - axios parameter creator
 * @export
 */
export const KeycloakConfigurationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The returned value contains all relevant information for the Eclipse client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the Eclipse client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakEclipseConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keycloak-eclipse.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The returned value contains all relevant information for the web client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the web client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakWebConfiguration: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/keycloak-web.json`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeycloakConfigurationControllerApi - functional programming interface
 * @export
 */
export const KeycloakConfigurationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeycloakConfigurationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * The returned value contains all relevant information for the Eclipse client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the Eclipse client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeycloakEclipseConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeycloakEclipseConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * The returned value contains all relevant information for the web client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the web client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getKeycloakWebConfiguration(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getKeycloakWebConfiguration(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeycloakConfigurationControllerApi - factory interface
 * @export
 */
export const KeycloakConfigurationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeycloakConfigurationControllerApiFp(configuration)
    return {
        /**
         * The returned value contains all relevant information for the Eclipse client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the Eclipse client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakEclipseConfiguration(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getKeycloakEclipseConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         * The returned value contains all relevant information for the web client to connect to the corresponding Keycloak instance.
         * @summary Retrieve the Keycloak configuration file for the web client in order to connect to the corresponding Keycloak instance.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getKeycloakWebConfiguration(options?: any): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getKeycloakWebConfiguration(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeycloakConfigurationControllerApi - object-oriented interface
 * @export
 * @class KeycloakConfigurationControllerApi
 * @extends {BaseAPI}
 */
export class KeycloakConfigurationControllerApi extends BaseAPI {
    /**
     * The returned value contains all relevant information for the Eclipse client to connect to the corresponding Keycloak instance.
     * @summary Retrieve the Keycloak configuration file for the Eclipse client in order to connect to the corresponding Keycloak instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakConfigurationControllerApi
     */
    public getKeycloakEclipseConfiguration(options?: AxiosRequestConfig) {
        return KeycloakConfigurationControllerApiFp(this.configuration).getKeycloakEclipseConfiguration(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The returned value contains all relevant information for the web client to connect to the corresponding Keycloak instance.
     * @summary Retrieve the Keycloak configuration file for the web client in order to connect to the corresponding Keycloak instance.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakConfigurationControllerApi
     */
    public getKeycloakWebConfiguration(options?: AxiosRequestConfig) {
        return KeycloakConfigurationControllerApiFp(this.configuration).getKeycloakWebConfiguration(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * KeycloakMigrationControllerApi - axios parameter creator
 * @export
 */
export const KeycloakMigrationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Migrate to Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateToKeycloak: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/migrateToKeycloak`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KeycloakMigrationControllerApi - functional programming interface
 * @export
 */
export const KeycloakMigrationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KeycloakMigrationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Migrate to Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async migrateToKeycloak(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.migrateToKeycloak(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * KeycloakMigrationControllerApi - factory interface
 * @export
 */
export const KeycloakMigrationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KeycloakMigrationControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Migrate to Keycloak
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        migrateToKeycloak(options?: any): AxiosPromise<string> {
            return localVarFp.migrateToKeycloak(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KeycloakMigrationControllerApi - object-oriented interface
 * @export
 * @class KeycloakMigrationControllerApi
 * @extends {BaseAPI}
 */
export class KeycloakMigrationControllerApi extends BaseAPI {
    /**
     * 
     * @summary Migrate to Keycloak
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KeycloakMigrationControllerApi
     */
    public migrateToKeycloak(options?: AxiosRequestConfig) {
        return KeycloakMigrationControllerApiFp(this.configuration).migrateToKeycloak(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LabelMappingsControllerApi - axios parameter creator
 * @export
 */
export const LabelMappingsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The returned map contains the key \'labelMapping\' and its mapped labels
         * @summary Get label mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelMapping: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/label-mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LabelMappingsControllerApi - functional programming interface
 * @export
 */
export const LabelMappingsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LabelMappingsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * The returned map contains the key \'labelMapping\' and its mapped labels
         * @summary Get label mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLabelMapping(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: { [key: string]: string; }; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLabelMapping(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LabelMappingsControllerApi - factory interface
 * @export
 */
export const LabelMappingsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LabelMappingsControllerApiFp(configuration)
    return {
        /**
         * The returned map contains the key \'labelMapping\' and its mapped labels
         * @summary Get label mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLabelMapping(options?: any): AxiosPromise<{ [key: string]: { [key: string]: string; }; }> {
            return localVarFp.getLabelMapping(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LabelMappingsControllerApi - object-oriented interface
 * @export
 * @class LabelMappingsControllerApi
 * @extends {BaseAPI}
 */
export class LabelMappingsControllerApi extends BaseAPI {
    /**
     * The returned map contains the key \'labelMapping\' and its mapped labels
     * @summary Get label mappings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LabelMappingsControllerApi
     */
    public getLabelMapping(options?: AxiosRequestConfig) {
        return LabelMappingsControllerApiFp(this.configuration).getLabelMapping(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LicenseControllerApi - axios parameter creator
 * @export
 */
export const LicenseControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary license expiry information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseExpireInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/license-expiry-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LicenseControllerApi - functional programming interface
 * @export
 */
export const LicenseControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LicenseControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary license expiry information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLicenseExpireInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LicenseExpirationInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLicenseExpireInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LicenseControllerApi - factory interface
 * @export
 */
export const LicenseControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LicenseControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary license expiry information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLicenseExpireInfo(options?: any): AxiosPromise<LicenseExpirationInfo> {
            return localVarFp.getLicenseExpireInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LicenseControllerApi - object-oriented interface
 * @export
 * @class LicenseControllerApi
 * @extends {BaseAPI}
 */
export class LicenseControllerApi extends BaseAPI {
    /**
     * 
     * @summary license expiry information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LicenseControllerApi
     */
    public getLicenseExpireInfo(options?: AxiosRequestConfig) {
        return LicenseControllerApiFp(this.configuration).getLicenseExpireInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MemberControllerApi - axios parameter creator
 * @export
 */
export const MemberControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the admin for specified Client
         * @summary Adds the admin for specified Client
         * @param {number} clientId the ID of the client to which admin is added
         * @param {Member} member The member to be added as admin to given client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberAsClientAdmin: async (clientId: number, member: Member, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('addMemberAsClientAdmin', 'clientId', clientId)
            // verify required parameter 'member' is not null or undefined
            assertParamExists('addMemberAsClientAdmin', 'member', member)
            const localVarPath = `/api/v2/clients/{clientId}/admins`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(member, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the member to the given project
         * @summary Adds the member to the given project
         * @param {EntityId} projectId the ID of the project
         * @param {Member} member The member to grant the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToProject: async (projectId: EntityId, member: Member, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('addMemberToProject', 'projectId', projectId)
            // verify required parameter 'member' is not null or undefined
            assertParamExists('addMemberToProject', 'member', member)
            const localVarPath = `/api/v2/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(member, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): admin | Project Nature(s): mining,discovery,discovery-light  Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @summary Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {Member} member The member to assign the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignProjectRoleToMember: async (projectId: EntityId, memberId: string, member: Member, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('assignProjectRoleToMember', 'projectId', projectId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('assignProjectRoleToMember', 'memberId', memberId)
            // verify required parameter 'member' is not null or undefined
            assertParamExists('assignProjectRoleToMember', 'member', member)
            const localVarPath = `/api/v2/projects/{projectId}/members/{memberId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(member, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member as the client admin
         * @summary Removes the member as the client admin
         * @param {number} clientId the ID of the client
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberAsClientAdmin: async (clientId: number, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('deleteMemberAsClientAdmin', 'clientId', clientId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteMemberAsClientAdmin', 'memberId', memberId)
            const localVarPath = `/api/v2/clients/{clientId}/admins/{memberId}`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member roles from the project
         * @summary Removes the member roles from the project
         * @param {EntityId} projectId the ID of the project
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberFromProject: async (projectId: EntityId, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteMemberFromProject', 'projectId', projectId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('deleteMemberFromProject', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectId}/members/{memberId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the list of Admins for specified Client
         * @summary Gets the list of Admins for specified Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClientAdmins: async (clientId: number, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findClientAdmins', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/admins`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the member specified by the ID if it has access to given Project
         * @summary Gets the member specified by the ID if it has access to given Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberById: async (projectId: EntityId, memberId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findMemberById', 'projectId', projectId)
            // verify required parameter 'memberId' is not null or undefined
            assertParamExists('findMemberById', 'memberId', memberId)
            const localVarPath = `/api/v2/projects/{projectId}/members/{memberId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"memberId"}}`, encodeURIComponent(String(memberId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Client
         * @summary Gets the count of all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCountForClient: async (clientId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findMemberCountForClient', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/members/count`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Project
         * @summary Gets the count of all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCountForProject: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findMemberCountForProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/members/count`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Client
         * @summary Lists all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersForClient: async (clientId: number, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findMembersForClient', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/members`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Project
         * @summary Lists all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersForProject: async (projectId: EntityId, page?: number, size?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findMembersForProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/members`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MemberControllerApi - functional programming interface
 * @export
 */
export const MemberControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MemberControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the admin for specified Client
         * @summary Adds the admin for specified Client
         * @param {number} clientId the ID of the client to which admin is added
         * @param {Member} member The member to be added as admin to given client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberAsClientAdmin(clientId: number, member: Member, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberAsClientAdmin(clientId, member, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the member to the given project
         * @summary Adds the member to the given project
         * @param {EntityId} projectId the ID of the project
         * @param {Member} member The member to grant the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addMemberToProject(projectId: EntityId, member: Member, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addMemberToProject(projectId, member, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): admin | Project Nature(s): mining,discovery,discovery-light  Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @summary Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {Member} member The member to assign the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignProjectRoleToMember(projectId: EntityId, memberId: string, member: Member, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignProjectRoleToMember(projectId, memberId, member, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member as the client admin
         * @summary Removes the member as the client admin
         * @param {number} clientId the ID of the client
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMemberAsClientAdmin(clientId: number, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMemberAsClientAdmin(clientId, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member roles from the project
         * @summary Removes the member roles from the project
         * @param {EntityId} projectId the ID of the project
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteMemberFromProject(projectId: EntityId, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteMemberFromProject(projectId, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the list of Admins for specified Client
         * @summary Gets the list of Admins for specified Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findClientAdmins(clientId: number, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findClientAdmins(clientId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the member specified by the ID if it has access to given Project
         * @summary Gets the member specified by the ID if it has access to given Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberById(projectId: EntityId, memberId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Member>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberById(projectId, memberId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Client
         * @summary Gets the count of all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberCountForClient(clientId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberCountForClient(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Project
         * @summary Gets the count of all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMemberCountForProject(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMemberCountForProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Client
         * @summary Lists all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMembersForClient(clientId: number, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMembersForClient(clientId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Project
         * @summary Lists all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMembersForProject(projectId: EntityId, page?: number, size?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PageMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMembersForProject(projectId, page, size, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MemberControllerApi - factory interface
 * @export
 */
export const MemberControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MemberControllerApiFp(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the admin for specified Client
         * @summary Adds the admin for specified Client
         * @param {number} clientId the ID of the client to which admin is added
         * @param {Member} member The member to be added as admin to given client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberAsClientAdmin(clientId: number, member: Member, options?: any): AxiosPromise<Member> {
            return localVarFp.addMemberAsClientAdmin(clientId, member, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the member to the given project
         * @summary Adds the member to the given project
         * @param {EntityId} projectId the ID of the project
         * @param {Member} member The member to grant the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMemberToProject(projectId: EntityId, member: Member, options?: any): AxiosPromise<Member> {
            return localVarFp.addMemberToProject(projectId, member, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): admin | Project Nature(s): mining,discovery,discovery-light  Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @summary Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {Member} member The member to assign the project roles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignProjectRoleToMember(projectId: EntityId, memberId: string, member: Member, options?: any): AxiosPromise<Member> {
            return localVarFp.assignProjectRoleToMember(projectId, memberId, member, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member as the client admin
         * @summary Removes the member as the client admin
         * @param {number} clientId the ID of the client
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberAsClientAdmin(clientId: number, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMemberAsClientAdmin(clientId, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member roles from the project
         * @summary Removes the member roles from the project
         * @param {EntityId} projectId the ID of the project
         * @param {string} memberId the ID of the member whose admin access to given client is to be removed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteMemberFromProject(projectId: EntityId, memberId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteMemberFromProject(projectId, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the list of Admins for specified Client
         * @summary Gets the list of Admins for specified Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findClientAdmins(clientId: number, page?: number, size?: number, options?: any): AxiosPromise<PageMember> {
            return localVarFp.findClientAdmins(clientId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the member specified by the ID if it has access to given Project
         * @summary Gets the member specified by the ID if it has access to given Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} memberId the ID of the member to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberById(projectId: EntityId, memberId: string, options?: any): AxiosPromise<Member> {
            return localVarFp.findMemberById(projectId, memberId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Client
         * @summary Gets the count of all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCountForClient(clientId: number, options?: any): AxiosPromise<number> {
            return localVarFp.findMemberCountForClient(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Project
         * @summary Gets the count of all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMemberCountForProject(projectId: EntityId, options?: any): AxiosPromise<number> {
            return localVarFp.findMemberCountForProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Client
         * @summary Lists all members for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersForClient(clientId: number, page?: number, size?: number, options?: any): AxiosPromise<PageMember> {
            return localVarFp.findMembersForClient(clientId, page, size, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Project
         * @summary Lists all members for a Project
         * @param {EntityId} projectId the ID of the project to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMembersForProject(projectId: EntityId, page?: number, size?: number, options?: any): AxiosPromise<PageMember> {
            return localVarFp.findMembersForProject(projectId, page, size, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MemberControllerApi - object-oriented interface
 * @export
 * @class MemberControllerApi
 * @extends {BaseAPI}
 */
export class MemberControllerApi extends BaseAPI {
    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the admin for specified Client
     * @summary Adds the admin for specified Client
     * @param {number} clientId the ID of the client to which admin is added
     * @param {Member} member The member to be added as admin to given client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public addMemberAsClientAdmin(clientId: number, member: Member, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).addMemberAsClientAdmin(clientId, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Adds the member to the given project
     * @summary Adds the member to the given project
     * @param {EntityId} projectId the ID of the project
     * @param {Member} member The member to grant the project roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public addMemberToProject(projectId: EntityId, member: Member, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).addMemberToProject(projectId, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): admin | Project Nature(s): mining,discovery,discovery-light  Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
     * @summary Assigns the specified project role to the user. User role is mandatory and existing user role is overriden whereas project nature may exist and existing project nature is not removed, only new project nature is added.
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} memberId the ID of the member to search
     * @param {Member} member The member to assign the project roles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public assignProjectRoleToMember(projectId: EntityId, memberId: string, member: Member, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).assignProjectRoleToMember(projectId, memberId, member, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member as the client admin
     * @summary Removes the member as the client admin
     * @param {number} clientId the ID of the client
     * @param {string} memberId the ID of the member whose admin access to given client is to be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public deleteMemberAsClientAdmin(clientId: number, memberId: string, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).deleteMemberAsClientAdmin(clientId, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Removes the member roles from the project
     * @summary Removes the member roles from the project
     * @param {EntityId} projectId the ID of the project
     * @param {string} memberId the ID of the member whose admin access to given client is to be removed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public deleteMemberFromProject(projectId: EntityId, memberId: string, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).deleteMemberFromProject(projectId, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the list of Admins for specified Client
     * @summary Gets the list of Admins for specified Client
     * @param {number} clientId the ID of the client to search
     * @param {number} [page] the page number to be fetched
     * @param {number} [size] the size of each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findClientAdmins(clientId: number, page?: number, size?: number, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findClientAdmins(clientId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the member specified by the ID if it has access to given Project
     * @summary Gets the member specified by the ID if it has access to given Project
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} memberId the ID of the member to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findMemberById(projectId: EntityId, memberId: string, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findMemberById(projectId, memberId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Client
     * @summary Gets the count of all members for a Client
     * @param {number} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findMemberCountForClient(clientId: number, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findMemberCountForClient(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Gets the count of all members for a Project
     * @summary Gets the count of all members for a Project
     * @param {EntityId} projectId the ID of the project to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findMemberCountForProject(projectId: EntityId, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findMemberCountForProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Client
     * @summary Lists all members for a Client
     * @param {number} clientId the ID of the client to search
     * @param {number} [page] the page number to be fetched
     * @param {number} [size] the size of each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findMembersForClient(clientId: number, page?: number, size?: number, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findMembersForClient(clientId, page, size, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining,discovery,discovery-light  Lists all members for a Project
     * @summary Lists all members for a Project
     * @param {EntityId} projectId the ID of the project to search
     * @param {number} [page] the page number to be fetched
     * @param {number} [size] the size of each page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MemberControllerApi
     */
    public findMembersForProject(projectId: EntityId, page?: number, size?: number, options?: AxiosRequestConfig) {
        return MemberControllerApiFp(this.configuration).findMembersForProject(projectId, page, size, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MetamodelControllerApi - axios parameter creator
 * @export
 */
export const MetamodelControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Define (create or modify) a custom property on the project specific default class for an entity
         * @summary Define (create or modify) a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined, if the name in the metadata differs it will be renamed
         * @param {CustomPropertyMetadata} customPropertyMetadata CustomPropertyMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineCustomProperty: async (projectId: EntityId, entityName: string, propertyName: string, customPropertyMetadata: CustomPropertyMetadata, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('defineCustomProperty', 'projectId', projectId)
            // verify required parameter 'entityName' is not null or undefined
            assertParamExists('defineCustomProperty', 'entityName', entityName)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('defineCustomProperty', 'propertyName', propertyName)
            // verify required parameter 'customPropertyMetadata' is not null or undefined
            assertParamExists('defineCustomProperty', 'customPropertyMetadata', customPropertyMetadata)
            const localVarPath = `/api/v1/projects/{projectId}/metamodel/{entityName}/{propertyName}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)))
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(customPropertyMetadata, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Delete a custom property on the project specific default class for an entity
         * @summary Delete a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomProperty: async (projectId: EntityId, entityName: string, propertyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteCustomProperty', 'projectId', projectId)
            // verify required parameter 'entityName' is not null or undefined
            assertParamExists('deleteCustomProperty', 'entityName', entityName)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('deleteCustomProperty', 'propertyName', propertyName)
            const localVarPath = `/api/v1/projects/{projectId}/metamodel/{entityName}/{propertyName}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"entityName"}}`, encodeURIComponent(String(entityName)))
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find particular metadata information for a custom property
         * @summary Find particular metadata information for a custom property
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {string} propertyName the name of the custom property for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCustomPropertyMetadataByName: async (metaModelClass: string, propertyName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metaModelClass' is not null or undefined
            assertParamExists('findCustomPropertyMetadataByName', 'metaModelClass', metaModelClass)
            // verify required parameter 'propertyName' is not null or undefined
            assertParamExists('findCustomPropertyMetadataByName', 'propertyName', propertyName)
            const localVarPath = `/api/v1/metamodel/{metaModelClass}/{propertyName}`
                .replace(`{${"metaModelClass"}}`, encodeURIComponent(String(metaModelClass)))
                .replace(`{${"propertyName"}}`, encodeURIComponent(String(propertyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all custom property metadata information for a given entity class
         * @summary List all custom property metadata information for a given entity class
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMetaModel: async (metaModelClass: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'metaModelClass' is not null or undefined
            assertParamExists('findMetaModel', 'metaModelClass', metaModelClass)
            const localVarPath = `/api/v1/metamodel/{metaModelClass}`
                .replace(`{${"metaModelClass"}}`, encodeURIComponent(String(metaModelClass)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Refresh the custom property metadata for a certain project or in general
         * @summary Refresh the custom property metadata for a certain project or in general
         * @param {EntityId} [projectId] the ID of the project to refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCustomPropertyMetadata: async (projectId?: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/refresh/metamodel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (projectId !== undefined) {
                localVarQueryParameter['projectId'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MetamodelControllerApi - functional programming interface
 * @export
 */
export const MetamodelControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MetamodelControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Define (create or modify) a custom property on the project specific default class for an entity
         * @summary Define (create or modify) a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined, if the name in the metadata differs it will be renamed
         * @param {CustomPropertyMetadata} customPropertyMetadata CustomPropertyMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defineCustomProperty(projectId: EntityId, entityName: string, propertyName: string, customPropertyMetadata: CustomPropertyMetadata, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defineCustomProperty(projectId, entityName, propertyName, customPropertyMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Delete a custom property on the project specific default class for an entity
         * @summary Delete a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomProperty(projectId: EntityId, entityName: string, propertyName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomProperty(projectId, entityName, propertyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find particular metadata information for a custom property
         * @summary Find particular metadata information for a custom property
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {string} propertyName the name of the custom property for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findCustomPropertyMetadataByName(metaModelClass: string, propertyName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomPropertyMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findCustomPropertyMetadataByName(metaModelClass, propertyName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all custom property metadata information for a given entity class
         * @summary List all custom property metadata information for a given entity class
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findMetaModel(metaModelClass: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomPropertyMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findMetaModel(metaModelClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Refresh the custom property metadata for a certain project or in general
         * @summary Refresh the custom property metadata for a certain project or in general
         * @param {EntityId} [projectId] the ID of the project to refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshCustomPropertyMetadata(projectId?: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshCustomPropertyMetadata(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MetamodelControllerApi - factory interface
 * @export
 */
export const MetamodelControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MetamodelControllerApiFp(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Define (create or modify) a custom property on the project specific default class for an entity
         * @summary Define (create or modify) a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined, if the name in the metadata differs it will be renamed
         * @param {CustomPropertyMetadata} customPropertyMetadata CustomPropertyMetadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defineCustomProperty(projectId: EntityId, entityName: string, propertyName: string, customPropertyMetadata: CustomPropertyMetadata, options?: any): AxiosPromise<void> {
            return localVarFp.defineCustomProperty(projectId, entityName, propertyName, customPropertyMetadata, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Delete a custom property on the project specific default class for an entity
         * @summary Delete a custom property on the project specific default class for an entity
         * @param {EntityId} projectId the project ID
         * @param {string} entityName the name of the mining entity for which the property shall be defined
         * @param {string} propertyName the name of the custom property to be defined
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomProperty(projectId: EntityId, entityName: string, propertyName: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCustomProperty(projectId, entityName, propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find particular metadata information for a custom property
         * @summary Find particular metadata information for a custom property
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {string} propertyName the name of the custom property for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findCustomPropertyMetadataByName(metaModelClass: string, propertyName: string, options?: any): AxiosPromise<CustomPropertyMetadata> {
            return localVarFp.findCustomPropertyMetadataByName(metaModelClass, propertyName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all custom property metadata information for a given entity class
         * @summary List all custom property metadata information for a given entity class
         * @param {string} metaModelClass the name of the class for which information should be returned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findMetaModel(metaModelClass: string, options?: any): AxiosPromise<Array<CustomPropertyMetadata>> {
            return localVarFp.findMetaModel(metaModelClass, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Refresh the custom property metadata for a certain project or in general
         * @summary Refresh the custom property metadata for a certain project or in general
         * @param {EntityId} [projectId] the ID of the project to refresh
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshCustomPropertyMetadata(projectId?: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.refreshCustomPropertyMetadata(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MetamodelControllerApi - object-oriented interface
 * @export
 * @class MetamodelControllerApi
 * @extends {BaseAPI}
 */
export class MetamodelControllerApi extends BaseAPI {
    /**
     * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Define (create or modify) a custom property on the project specific default class for an entity
     * @summary Define (create or modify) a custom property on the project specific default class for an entity
     * @param {EntityId} projectId the project ID
     * @param {string} entityName the name of the mining entity for which the property shall be defined
     * @param {string} propertyName the name of the custom property to be defined, if the name in the metadata differs it will be renamed
     * @param {CustomPropertyMetadata} customPropertyMetadata CustomPropertyMetadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetamodelControllerApi
     */
    public defineCustomProperty(projectId: EntityId, entityName: string, propertyName: string, customPropertyMetadata: CustomPropertyMetadata, options?: AxiosRequestConfig) {
        return MetamodelControllerApiFp(this.configuration).defineCustomProperty(projectId, entityName, propertyName, customPropertyMetadata, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Delete a custom property on the project specific default class for an entity
     * @summary Delete a custom property on the project specific default class for an entity
     * @param {EntityId} projectId the project ID
     * @param {string} entityName the name of the mining entity for which the property shall be defined
     * @param {string} propertyName the name of the custom property to be defined
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetamodelControllerApi
     */
    public deleteCustomProperty(projectId: EntityId, entityName: string, propertyName: string, options?: AxiosRequestConfig) {
        return MetamodelControllerApiFp(this.configuration).deleteCustomProperty(projectId, entityName, propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find particular metadata information for a custom property
     * @summary Find particular metadata information for a custom property
     * @param {string} metaModelClass the name of the class for which information should be returned
     * @param {string} propertyName the name of the custom property for which information should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetamodelControllerApi
     */
    public findCustomPropertyMetadataByName(metaModelClass: string, propertyName: string, options?: AxiosRequestConfig) {
        return MetamodelControllerApiFp(this.configuration).findCustomPropertyMetadataByName(metaModelClass, propertyName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all custom property metadata information for a given entity class
     * @summary List all custom property metadata information for a given entity class
     * @param {string} metaModelClass the name of the class for which information should be returned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetamodelControllerApi
     */
    public findMetaModel(metaModelClass: string, options?: AxiosRequestConfig) {
        return MetamodelControllerApiFp(this.configuration).findMetaModel(metaModelClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining,discovery,discovery-light  Refresh the custom property metadata for a certain project or in general
     * @summary Refresh the custom property metadata for a certain project or in general
     * @param {EntityId} [projectId] the ID of the project to refresh
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetamodelControllerApi
     */
    public refreshCustomPropertyMetadata(projectId?: EntityId, options?: AxiosRequestConfig) {
        return MetamodelControllerApiFp(this.configuration).refreshCustomPropertyMetadata(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiningUiControllerMockitoMockVuI9eZo7Api - axios parameter creator
 * @export
 */
export const MiningUiControllerMockitoMockVuI9eZo7ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get the modified index.html after adding href in base tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifiedIndexHtml: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/index.html`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiningUiControllerMockitoMockVuI9eZo7Api - functional programming interface
 * @export
 */
export const MiningUiControllerMockitoMockVuI9eZo7ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiningUiControllerMockitoMockVuI9eZo7ApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get the modified index.html after adding href in base tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifiedIndexHtml(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifiedIndexHtml(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiningUiControllerMockitoMockVuI9eZo7Api - factory interface
 * @export
 */
export const MiningUiControllerMockitoMockVuI9eZo7ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiningUiControllerMockitoMockVuI9eZo7ApiFp(configuration)
    return {
        /**
         * 
         * @summary Get the modified index.html after adding href in base tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifiedIndexHtml(options?: any): AxiosPromise<string> {
            return localVarFp.modifiedIndexHtml(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiningUiControllerMockitoMockVuI9eZo7Api - object-oriented interface
 * @export
 * @class MiningUiControllerMockitoMockVuI9eZo7Api
 * @extends {BaseAPI}
 */
export class MiningUiControllerMockitoMockVuI9eZo7Api extends BaseAPI {
    /**
     * 
     * @summary Get the modified index.html after adding href in base tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningUiControllerMockitoMockVuI9eZo7Api
     */
    public modifiedIndexHtml(options?: AxiosRequestConfig) {
        return MiningUiControllerMockitoMockVuI9eZo7ApiFp(this.configuration).modifiedIndexHtml(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MiningUiExtensionsControllerApi - axios parameter creator
 * @export
 */
export const MiningUiExtensionsControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered custom table extensions
         * @summary Gets a list of registered custom table extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableExtensions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ui/table-extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered web ui extensions
         * @summary Gets a list of registered web ui extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebUiExtensions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/ui/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MiningUiExtensionsControllerApi - functional programming interface
 * @export
 */
export const MiningUiExtensionsControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MiningUiExtensionsControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered custom table extensions
         * @summary Gets a list of registered custom table extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTableExtensions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CustomTableExtensionDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTableExtensions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered web ui extensions
         * @summary Gets a list of registered web ui extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWebUiExtensions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebUiExtensionDescription>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWebUiExtensions(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * MiningUiExtensionsControllerApi - factory interface
 * @export
 */
export const MiningUiExtensionsControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MiningUiExtensionsControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered custom table extensions
         * @summary Gets a list of registered custom table extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTableExtensions(options?: any): AxiosPromise<Array<CustomTableExtensionDescription>> {
            return localVarFp.getTableExtensions(options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered web ui extensions
         * @summary Gets a list of registered web ui extensions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWebUiExtensions(options?: any): AxiosPromise<Array<WebUiExtensionDescription>> {
            return localVarFp.getWebUiExtensions(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MiningUiExtensionsControllerApi - object-oriented interface
 * @export
 * @class MiningUiExtensionsControllerApi
 * @extends {BaseAPI}
 */
export class MiningUiExtensionsControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered custom table extensions
     * @summary Gets a list of registered custom table extensions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningUiExtensionsControllerApi
     */
    public getTableExtensions(options?: AxiosRequestConfig) {
        return MiningUiExtensionsControllerApiFp(this.configuration).getTableExtensions(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Gets a list of registered web ui extensions
     * @summary Gets a list of registered web ui extensions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MiningUiExtensionsControllerApi
     */
    public getWebUiExtensions(options?: AxiosRequestConfig) {
        return MiningUiExtensionsControllerApiFp(this.configuration).getWebUiExtensions(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ModuleControllerApi - axios parameter creator
 * @export
 */
export const ModuleControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Clear the review status for all modules on a project
         * @summary Clear the review status for all modules on a project
         * @param {EntityId} projectId the ID of the project on which to reset the review status for all modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRequiresReview: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('clearRequiresReview', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/requiresReview`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count modules to review on a project
         * @summary Count modules to review on a project
         * @param {EntityId} projectId the ID of the project for which to count modules to review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRequiresReview: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('countRequiresReview', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/requiresReview`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new module
         * @summary Create a new module
         * @param {EntityId} projectId the ID of the project
         * @param {ModulePojoPrototype} modulePojoPrototype The module to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModule: async (projectId: EntityId, modulePojoPrototype: ModulePojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createModule', 'projectId', projectId)
            // verify required parameter 'modulePojoPrototype' is not null or undefined
            assertParamExists('createModule', 'modulePojoPrototype', modulePojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modulePojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete all modules for one project
         * @summary Delete all modules for one project
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} deleteSourceObjects should be set to true to delete source objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllModules: async (projectId: EntityId, deleteSourceObjects: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAllModules', 'projectId', projectId)
            // verify required parameter 'deleteSourceObjects' is not null or undefined
            assertParamExists('deleteAllModules', 'deleteSourceObjects', deleteSourceObjects)
            const localVarPath = `/api/v1/projects/{projectId}/modules`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (deleteSourceObjects !== undefined) {
                localVarQueryParameter['deleteSourceObjects'] = deleteSourceObjects;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a module
         * @summary Delete a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModule: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('deleteModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all modules of a project
         * @summary List all modules of a project
         * @param {EntityId} projectId the ID of the project to list modules from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllModules: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllModules', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/modules`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all annotations assigned to a module
         * @summary Find all annotations assigned to a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsForModule: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAnnotationsForModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAnnotationsForModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/annotations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find error markers in the module
         * @summary Find error markers in the module
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findErrorMarkers: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findErrorMarkers', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findErrorMarkers', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/errorMarkers`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of included moduleIds for a given module
         * @summary List of included moduleIds for a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIncludedModuleIds: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findIncludedModuleIds', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findIncludedModuleIds', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/includedModuleIds`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked modules for the current given module
         * @summary Find linked modules for the current given module
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedModule: async (projectId: EntityId, path: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findLinkedModule', 'projectId', projectId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('findLinkedModule', 'path', path)
            const localVarPath = `/api/v1/projects/{projectId}/linkedModules/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its ID
         * @summary Find a module by its ID
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleById: async (projectId: EntityId, moduleId: EntityId, includeContent?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findModuleById', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findModuleById', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (includeContent !== undefined) {
                localVarQueryParameter['includeContent'] = includeContent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its linkHash
         * @summary Find a module by its linkHash
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} linkHash the linkHash of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleByLinkHash: async (projectId: EntityId, linkHash: string, includeContent?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findModuleByLinkHash', 'projectId', projectId)
            // verify required parameter 'linkHash' is not null or undefined
            assertParamExists('findModuleByLinkHash', 'linkHash', linkHash)
            const localVarPath = `/api/v1/projects/{projectId}/modules/hash/{linkHash}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"linkHash"}}`, encodeURIComponent(String(linkHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (includeContent !== undefined) {
                localVarQueryParameter['includeContent'] = includeContent;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search modules by description
         * @summary Search modules by description
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {string} name the module name to search for
         * @param {string} description the description of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModulesByDescription1: async (projectId: EntityId, path: string, name: string, description: string, includeContent?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findModulesByDescription1', 'projectId', projectId)
            // verify required parameter 'path' is not null or undefined
            assertParamExists('findModulesByDescription1', 'path', path)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('findModulesByDescription1', 'name', name)
            // verify required parameter 'description' is not null or undefined
            assertParamExists('findModulesByDescription1', 'description', description)
            const localVarPath = `/api/v1/projects/{projectId}/modules/search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (path !== undefined) {
                localVarQueryParameter['path'] = path;
            }

            if (includeContent !== undefined) {
                localVarQueryParameter['includeContent'] = includeContent;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all taxonomies of the module
         * @summary Find all taxonomies of the module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTaxonomiesForModule: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findTaxonomiesForModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findTaxonomiesForModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/taxonomies`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate module description
         * @summary Generate module description
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateModuleDescription: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('generateModuleDescription', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('generateModuleDescription', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/generateDescription`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project
         * @summary Get aggregated values for utilities used by a project
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedUtilityValues: async (projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedUtilityValues', 'projectId', projectId)
            // verify required parameter 'aggregationRequestModuleFieldName' is not null or undefined
            assertParamExists('getAggregatedUtilityValues', 'aggregationRequestModuleFieldName', aggregationRequestModuleFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/modules/utility-aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestModuleFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project as CSV
         * @summary Get aggregated values for utilities used by a project as CSV
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedUtilityValuesAsCsv: async (projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedUtilityValuesAsCsv', 'projectId', projectId)
            // verify required parameter 'aggregationRequestModuleFieldName' is not null or undefined
            assertParamExists('getAggregatedUtilityValuesAsCsv', 'aggregationRequestModuleFieldName', aggregationRequestModuleFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/modules/utility-aggregations/csv`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestModuleFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of modules
         * @summary Get aggregated values over a number of modules
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues2: async (projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedValues2', 'projectId', projectId)
            // verify required parameter 'aggregationRequestModuleFieldName' is not null or undefined
            assertParamExists('getAggregatedValues2', 'aggregationRequestModuleFieldName', aggregationRequestModuleFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/modules/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestModuleFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get assembled content for given module
         * @summary Get assembled content for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssembledContent: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAssembledContent', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getAssembledContent', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/assembled-content`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get data flow graph for given module and field
         * @summary Get data flow graph for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowGraph: async (projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraph', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraph', 'moduleId', moduleId)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraph', 'offset', offset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/code-viewer-data-flow-graph/{offset}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (assembled !== undefined) {
                localVarQueryParameter['assembled'] = assembled;
            }

            if (includingModule !== undefined) {
                localVarQueryParameter['includingModule'] = includingModule;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Runs the data flow graph query job for a given module and field
         * @summary Runs the data flow graph query job for a given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {string} [name] 
         * @param {'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowGraphJob: async (projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, name?: string, type?: 'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraphJob', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraphJob', 'moduleId', moduleId)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getCodeViewerDataFlowGraphJob', 'offset', offset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/code-viewer-data-flow-graph-job/{offset}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (assembled !== undefined) {
                localVarQueryParameter['assembled'] = assembled;
            }

            if (includingModule !== undefined) {
                localVarQueryParameter['includingModule'] = includingModule;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer data flow links for given module and field
         * @summary Get code viewer data flow links for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowLinks: async (projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowLinks', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getCodeViewerDataFlowLinks', 'moduleId', moduleId)
            // verify required parameter 'offset' is not null or undefined
            assertParamExists('getCodeViewerDataFlowLinks', 'offset', offset)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/code-viewer-data-flow-links/{offset}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"offset"}}`, encodeURIComponent(String(offset)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (assembled !== undefined) {
                localVarQueryParameter['assembled'] = assembled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer links for given module
         * @summary Get code viewer links for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerLinks: async (projectId: EntityId, moduleId: EntityId, assembled?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getCodeViewerLinks', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getCodeViewerLinks', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/code-viewer-links`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (assembled !== undefined) {
                localVarQueryParameter['assembled'] = assembled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Checks if DataLineage is possible for given module
         * @summary Checks if DataLineage is possible for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataLineageAvailableForModule: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDataLineageAvailableForModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('getDataLineageAvailableForModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/datalineage-available`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all modules for one project
         * @summary Count all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModuleCount: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getModuleCount', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/count`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Statistics of all modules for one project
         * @summary Statistics of all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModuleStatistics: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getModuleStatistics', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/statistics`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find if module has AST Nodes
         * @summary Find if module has AST Nodes
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasAstNodes: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('hasAstNodes', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('hasAstNodes', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/hasAstNodes`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules relative to the project. Example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyModuleDescriptions: async (projectId: EntityId, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('identifyModuleDescriptions', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('identifyModuleDescriptions', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/identify-module-descriptions`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Store AST Nodes for the specified Module
         * @summary Store AST Nodes for the specified Module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAstNodes: async (projectId: EntityId, moduleId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storeAstNodes', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('storeAstNodes', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/storeAst`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all dependencies of a module
         * @summary Find all dependencies of a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} maxDepth the depth of the traversal
         * @param {number} [maxGraphNodes] the number of graph nodes to be returned
         * @param {string} [query] filtering parameters
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traverseModuleDependencies: async (projectId: EntityId, moduleId: EntityId, maxDepth: number, maxGraphNodes?: number, query?: string, distinct?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('traverseModuleDependencies', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('traverseModuleDependencies', 'moduleId', moduleId)
            // verify required parameter 'maxDepth' is not null or undefined
            assertParamExists('traverseModuleDependencies', 'maxDepth', maxDepth)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/graph/dependencies`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (maxDepth !== undefined) {
                localVarQueryParameter['maxDepth'] = maxDepth;
            }

            if (maxGraphNodes !== undefined) {
                localVarQueryParameter['maxGraphNodes'] = maxGraphNodes;
            }

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }

            if (distinct !== undefined) {
                localVarQueryParameter['distinct'] = distinct;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an existing module
         * @summary Update an existing module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to be updated
         * @param {ModulePojoPrototype} modulePojoPrototype The updated module data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModule: async (projectId: EntityId, moduleId: EntityId, modulePojoPrototype: ModulePojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('updateModule', 'moduleId', moduleId)
            // verify required parameter 'modulePojoPrototype' is not null or undefined
            assertParamExists('updateModule', 'modulePojoPrototype', modulePojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(modulePojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ModuleControllerApi - functional programming interface
 * @export
 */
export const ModuleControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ModuleControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Clear the review status for all modules on a project
         * @summary Clear the review status for all modules on a project
         * @param {EntityId} projectId the ID of the project on which to reset the review status for all modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clearRequiresReview(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.clearRequiresReview(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count modules to review on a project
         * @summary Count modules to review on a project
         * @param {EntityId} projectId the ID of the project for which to count modules to review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countRequiresReview(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countRequiresReview(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new module
         * @summary Create a new module
         * @param {EntityId} projectId the ID of the project
         * @param {ModulePojoPrototype} modulePojoPrototype The module to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createModule(projectId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createModule(projectId, modulePojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete all modules for one project
         * @summary Delete all modules for one project
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} deleteSourceObjects should be set to true to delete source objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAllModules(projectId: EntityId, deleteSourceObjects: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAllModules(projectId, deleteSourceObjects, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a module
         * @summary Delete a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteModule(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all modules of a project
         * @summary List all modules of a project
         * @param {EntityId} projectId the ID of the project to list modules from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllModules(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModulePojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllModules(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all annotations assigned to a module
         * @summary Find all annotations assigned to a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAnnotationsForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AnnotationPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAnnotationsForModule(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find error markers in the module
         * @summary Find error markers in the module
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findErrorMarkers(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ErrorMarker>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findErrorMarkers(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of included moduleIds for a given module
         * @summary List of included moduleIds for a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findIncludedModuleIds(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<number>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findIncludedModuleIds(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked modules for the current given module
         * @summary Find linked modules for the current given module
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLinkedModule(projectId: EntityId, path: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LinkedModule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLinkedModule(projectId, path, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its ID
         * @summary Find a module by its ID
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findModuleById(projectId: EntityId, moduleId: EntityId, includeContent?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findModuleById(projectId, moduleId, includeContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its linkHash
         * @summary Find a module by its linkHash
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} linkHash the linkHash of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findModuleByLinkHash(projectId: EntityId, linkHash: string, includeContent?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findModuleByLinkHash(projectId, linkHash, includeContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search modules by description
         * @summary Search modules by description
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {string} name the module name to search for
         * @param {string} description the description of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findModulesByDescription1(projectId: EntityId, path: string, name: string, description: string, includeContent?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findModulesByDescription1(projectId, path, name, description, includeContent, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all taxonomies of the module
         * @summary Find all taxonomies of the module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTaxonomiesForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaxonomyPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTaxonomiesForModule(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate module description
         * @summary Generate module description
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateModuleDescription(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateModuleDescription(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project
         * @summary Get aggregated values for utilities used by a project
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedUtilityValues(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultModuleFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedUtilityValues(projectId, aggregationRequestModuleFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project as CSV
         * @summary Get aggregated values for utilities used by a project as CSV
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedUtilityValuesAsCsv(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedUtilityValuesAsCsv(projectId, aggregationRequestModuleFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of modules
         * @summary Get aggregated values over a number of modules
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedValues2(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultModuleFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedValues2(projectId, aggregationRequestModuleFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get assembled content for given module
         * @summary Get assembled content for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssembledContent(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssembledContent(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get data flow graph for given module and field
         * @summary Get data flow graph for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeViewerDataFlowGraph(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DataFlowGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeViewerDataFlowGraph(projectId, moduleId, offset, assembled, includingModule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Runs the data flow graph query job for a given module and field
         * @summary Runs the data flow graph query job for a given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {string} [name] 
         * @param {'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeViewerDataFlowGraphJob(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, name?: string, type?: 'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeViewerDataFlowGraphJob(projectId, moduleId, offset, assembled, includingModule, name, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer data flow links for given module and field
         * @summary Get code viewer data flow links for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeViewerDataFlowLinks(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeViewerLinkModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeViewerDataFlowLinks(projectId, moduleId, offset, assembled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer links for given module
         * @summary Get code viewer links for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCodeViewerLinks(projectId: EntityId, moduleId: EntityId, assembled?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CodeViewerLinkModel>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCodeViewerLinks(projectId, moduleId, assembled, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Checks if DataLineage is possible for given module
         * @summary Checks if DataLineage is possible for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDataLineageAvailableForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDataLineageAvailableForModule(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all modules for one project
         * @summary Count all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModuleCount(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModuleCount(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Statistics of all modules for one project
         * @summary Statistics of all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getModuleStatistics(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleStatisticsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getModuleStatistics(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find if module has AST Nodes
         * @summary Find if module has AST Nodes
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async hasAstNodes(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.hasAstNodes(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules relative to the project. Example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifyModuleDescriptions(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifyModuleDescriptions(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Store AST Nodes for the specified Module
         * @summary Store AST Nodes for the specified Module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeAstNodes(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeAstNodes(projectId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all dependencies of a module
         * @summary Find all dependencies of a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} maxDepth the depth of the traversal
         * @param {number} [maxGraphNodes] the number of graph nodes to be returned
         * @param {string} [query] filtering parameters
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async traverseModuleDependencies(projectId: EntityId, moduleId: EntityId, maxDepth: number, maxGraphNodes?: number, query?: string, distinct?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DependencyGraph>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.traverseModuleDependencies(projectId, moduleId, maxDepth, maxGraphNodes, query, distinct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an existing module
         * @summary Update an existing module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to be updated
         * @param {ModulePojoPrototype} modulePojoPrototype The updated module data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateModule(projectId: EntityId, moduleId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModulePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateModule(projectId, moduleId, modulePojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ModuleControllerApi - factory interface
 * @export
 */
export const ModuleControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ModuleControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Clear the review status for all modules on a project
         * @summary Clear the review status for all modules on a project
         * @param {EntityId} projectId the ID of the project on which to reset the review status for all modules
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clearRequiresReview(projectId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.clearRequiresReview(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count modules to review on a project
         * @summary Count modules to review on a project
         * @param {EntityId} projectId the ID of the project for which to count modules to review
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countRequiresReview(projectId: EntityId, options?: any): AxiosPromise<number> {
            return localVarFp.countRequiresReview(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new module
         * @summary Create a new module
         * @param {EntityId} projectId the ID of the project
         * @param {ModulePojoPrototype} modulePojoPrototype The module to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createModule(projectId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.createModule(projectId, modulePojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete all modules for one project
         * @summary Delete all modules for one project
         * @param {EntityId} projectId the ID of the project
         * @param {boolean} deleteSourceObjects should be set to true to delete source objects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAllModules(projectId: EntityId, deleteSourceObjects: boolean, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAllModules(projectId, deleteSourceObjects, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a module
         * @summary Delete a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteModule(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteModule(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List all modules of a project
         * @summary List all modules of a project
         * @param {EntityId} projectId the ID of the project to list modules from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllModules(projectId: EntityId, options?: any): AxiosPromise<Array<ModulePojo>> {
            return localVarFp.findAllModules(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all annotations assigned to a module
         * @summary Find all annotations assigned to a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAnnotationsForModule(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<Array<AnnotationPojo>> {
            return localVarFp.findAnnotationsForModule(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find error markers in the module
         * @summary Find error markers in the module
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findErrorMarkers(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<Array<ErrorMarker>> {
            return localVarFp.findErrorMarkers(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  List of included moduleIds for a given module
         * @summary List of included moduleIds for a given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findIncludedModuleIds(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<Array<number>> {
            return localVarFp.findIncludedModuleIds(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find linked modules for the current given module
         * @summary Find linked modules for the current given module
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLinkedModule(projectId: EntityId, path: string, options?: any): AxiosPromise<Array<LinkedModule>> {
            return localVarFp.findLinkedModule(projectId, path, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its ID
         * @summary Find a module by its ID
         * @param {EntityId} projectId the ID of the project to search
         * @param {EntityId} moduleId the ID of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleById(projectId: EntityId, moduleId: EntityId, includeContent?: boolean, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.findModuleById(projectId, moduleId, includeContent, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a module by its linkHash
         * @summary Find a module by its linkHash
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} linkHash the linkHash of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModuleByLinkHash(projectId: EntityId, linkHash: string, includeContent?: boolean, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.findModuleByLinkHash(projectId, linkHash, includeContent, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Search modules by description
         * @summary Search modules by description
         * @param {EntityId} projectId the ID of the project to search
         * @param {string} path the lookup path
         * @param {string} name the module name to search for
         * @param {string} description the description of the module to search for
         * @param {boolean} [includeContent] if source code needs to be included
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findModulesByDescription1(projectId: EntityId, path: string, name: string, description: string, includeContent?: boolean, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.findModulesByDescription1(projectId, path, name, description, includeContent, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all taxonomies of the module
         * @summary Find all taxonomies of the module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTaxonomiesForModule(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<Array<TaxonomyPojo>> {
            return localVarFp.findTaxonomiesForModule(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Generate module description
         * @summary Generate module description
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateModuleDescription(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.generateModuleDescription(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project
         * @summary Get aggregated values for utilities used by a project
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedUtilityValues(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: any): AxiosPromise<Array<AggregationResultModuleFieldName>> {
            return localVarFp.getAggregatedUtilityValues(projectId, aggregationRequestModuleFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project as CSV
         * @summary Get aggregated values for utilities used by a project as CSV
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedUtilityValuesAsCsv(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: any): AxiosPromise<File> {
            return localVarFp.getAggregatedUtilityValuesAsCsv(projectId, aggregationRequestModuleFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of modules
         * @summary Get aggregated values over a number of modules
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues2(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: any): AxiosPromise<Array<AggregationResultModuleFieldName>> {
            return localVarFp.getAggregatedValues2(projectId, aggregationRequestModuleFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get assembled content for given module
         * @summary Get assembled content for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssembledContent(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.getAssembledContent(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get data flow graph for given module and field
         * @summary Get data flow graph for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowGraph(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, options?: any): AxiosPromise<DataFlowGraph> {
            return localVarFp.getCodeViewerDataFlowGraph(projectId, moduleId, offset, assembled, includingModule, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Runs the data flow graph query job for a given module and field
         * @summary Runs the data flow graph query job for a given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {string} [includingModule] 
         * @param {string} [name] 
         * @param {'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS'} [type] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowGraphJob(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, name?: string, type?: 'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS', options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getCodeViewerDataFlowGraphJob(projectId, moduleId, offset, assembled, includingModule, name, type, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer data flow links for given module and field
         * @summary Get code viewer data flow links for given module and field
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} offset the offset of the field within the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerDataFlowLinks(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: any): AxiosPromise<CodeViewerLinkModel> {
            return localVarFp.getCodeViewerDataFlowLinks(projectId, moduleId, offset, assembled, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get code viewer links for given module
         * @summary Get code viewer links for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {boolean} [assembled] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCodeViewerLinks(projectId: EntityId, moduleId: EntityId, assembled?: boolean, options?: any): AxiosPromise<CodeViewerLinkModel> {
            return localVarFp.getCodeViewerLinks(projectId, moduleId, assembled, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Checks if DataLineage is possible for given module
         * @summary Checks if DataLineage is possible for given module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataLineageAvailableForModule(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<boolean> {
            return localVarFp.getDataLineageAvailableForModule(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Count all modules for one project
         * @summary Count all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModuleCount(projectId: EntityId, options?: any): AxiosPromise<number> {
            return localVarFp.getModuleCount(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Statistics of all modules for one project
         * @summary Statistics of all modules for one project
         * @param {EntityId} projectId the ID of the project to examine
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getModuleStatistics(projectId: EntityId, options?: any): AxiosPromise<ModuleStatisticsResponse> {
            return localVarFp.getModuleStatistics(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find if module has AST Nodes
         * @summary Find if module has AST Nodes
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        hasAstNodes(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<boolean> {
            return localVarFp.hasAstNodes(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules relative to the project. Example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyModuleDescriptions(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.identifyModuleDescriptions(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Store AST Nodes for the specified Module
         * @summary Store AST Nodes for the specified Module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeAstNodes(projectId: EntityId, moduleId: EntityId, options?: any): AxiosPromise<boolean> {
            return localVarFp.storeAstNodes(projectId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all dependencies of a module
         * @summary Find all dependencies of a module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {number} maxDepth the depth of the traversal
         * @param {number} [maxGraphNodes] the number of graph nodes to be returned
         * @param {string} [query] filtering parameters
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        traverseModuleDependencies(projectId: EntityId, moduleId: EntityId, maxDepth: number, maxGraphNodes?: number, query?: string, distinct?: boolean, options?: any): AxiosPromise<DependencyGraph> {
            return localVarFp.traverseModuleDependencies(projectId, moduleId, maxDepth, maxGraphNodes, query, distinct, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update an existing module
         * @summary Update an existing module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module to be updated
         * @param {ModulePojoPrototype} modulePojoPrototype The updated module data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateModule(projectId: EntityId, moduleId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: any): AxiosPromise<ModulePojo> {
            return localVarFp.updateModule(projectId, moduleId, modulePojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ModuleControllerApi - object-oriented interface
 * @export
 * @class ModuleControllerApi
 * @extends {BaseAPI}
 */
export class ModuleControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Clear the review status for all modules on a project
     * @summary Clear the review status for all modules on a project
     * @param {EntityId} projectId the ID of the project on which to reset the review status for all modules
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public clearRequiresReview(projectId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).clearRequiresReview(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Count modules to review on a project
     * @summary Count modules to review on a project
     * @param {EntityId} projectId the ID of the project for which to count modules to review
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public countRequiresReview(projectId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).countRequiresReview(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Create a new module
     * @summary Create a new module
     * @param {EntityId} projectId the ID of the project
     * @param {ModulePojoPrototype} modulePojoPrototype The module to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public createModule(projectId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).createModule(projectId, modulePojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Delete all modules for one project
     * @summary Delete all modules for one project
     * @param {EntityId} projectId the ID of the project
     * @param {boolean} deleteSourceObjects should be set to true to delete source objects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public deleteAllModules(projectId: EntityId, deleteSourceObjects: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).deleteAllModules(projectId, deleteSourceObjects, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Delete a module
     * @summary Delete a module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public deleteModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).deleteModule(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List all modules of a project
     * @summary List all modules of a project
     * @param {EntityId} projectId the ID of the project to list modules from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findAllModules(projectId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findAllModules(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find all annotations assigned to a module
     * @summary Find all annotations assigned to a module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findAnnotationsForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findAnnotationsForModule(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find error markers in the module
     * @summary Find error markers in the module
     * @param {EntityId} projectId the ID of the project to search
     * @param {EntityId} moduleId the ID of the module to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findErrorMarkers(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findErrorMarkers(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  List of included moduleIds for a given module
     * @summary List of included moduleIds for a given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findIncludedModuleIds(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findIncludedModuleIds(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find linked modules for the current given module
     * @summary Find linked modules for the current given module
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} path the lookup path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findLinkedModule(projectId: EntityId, path: string, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findLinkedModule(projectId, path, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find a module by its ID
     * @summary Find a module by its ID
     * @param {EntityId} projectId the ID of the project to search
     * @param {EntityId} moduleId the ID of the module to search for
     * @param {boolean} [includeContent] if source code needs to be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findModuleById(projectId: EntityId, moduleId: EntityId, includeContent?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findModuleById(projectId, moduleId, includeContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find a module by its linkHash
     * @summary Find a module by its linkHash
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} linkHash the linkHash of the module to search for
     * @param {boolean} [includeContent] if source code needs to be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findModuleByLinkHash(projectId: EntityId, linkHash: string, includeContent?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findModuleByLinkHash(projectId, linkHash, includeContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Search modules by description
     * @summary Search modules by description
     * @param {EntityId} projectId the ID of the project to search
     * @param {string} path the lookup path
     * @param {string} name the module name to search for
     * @param {string} description the description of the module to search for
     * @param {boolean} [includeContent] if source code needs to be included
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findModulesByDescription1(projectId: EntityId, path: string, name: string, description: string, includeContent?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findModulesByDescription1(projectId, path, name, description, includeContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find all taxonomies of the module
     * @summary Find all taxonomies of the module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public findTaxonomiesForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).findTaxonomiesForModule(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Generate module description
     * @summary Generate module description
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public generateModuleDescription(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).generateModuleDescription(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project
     * @summary Get aggregated values for utilities used by a project
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getAggregatedUtilityValues(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getAggregatedUtilityValues(projectId, aggregationRequestModuleFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values for utilities used by a project as CSV
     * @summary Get aggregated values for utilities used by a project as CSV
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getAggregatedUtilityValuesAsCsv(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getAggregatedUtilityValuesAsCsv(projectId, aggregationRequestModuleFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of modules
     * @summary Get aggregated values over a number of modules
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestModuleFieldName} aggregationRequestModuleFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getAggregatedValues2(projectId: EntityId, aggregationRequestModuleFieldName: AggregationRequestModuleFieldName, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getAggregatedValues2(projectId, aggregationRequestModuleFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get assembled content for given module
     * @summary Get assembled content for given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getAssembledContent(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getAssembledContent(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get data flow graph for given module and field
     * @summary Get data flow graph for given module and field
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} offset the offset of the field within the module
     * @param {boolean} [assembled] 
     * @param {string} [includingModule] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getCodeViewerDataFlowGraph(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getCodeViewerDataFlowGraph(projectId, moduleId, offset, assembled, includingModule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Runs the data flow graph query job for a given module and field
     * @summary Runs the data flow graph query job for a given module and field
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} offset the offset of the field within the module
     * @param {boolean} [assembled] 
     * @param {string} [includingModule] 
     * @param {string} [name] 
     * @param {'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS'} [type] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getCodeViewerDataFlowGraphJob(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, includingModule?: string, name?: string, type?: 'DATABASE_TABLE' | 'DATABASE_ACCESS' | 'ENTRY_POINT' | 'CALL' | 'FIELD_TRACING_META_DATA' | 'RESOURCE_FILE' | 'FILE_ACCESS', options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getCodeViewerDataFlowGraphJob(projectId, moduleId, offset, assembled, includingModule, name, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get code viewer data flow links for given module and field
     * @summary Get code viewer data flow links for given module and field
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} offset the offset of the field within the module
     * @param {boolean} [assembled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getCodeViewerDataFlowLinks(projectId: EntityId, moduleId: EntityId, offset: number, assembled?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getCodeViewerDataFlowLinks(projectId, moduleId, offset, assembled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get code viewer links for given module
     * @summary Get code viewer links for given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {boolean} [assembled] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getCodeViewerLinks(projectId: EntityId, moduleId: EntityId, assembled?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getCodeViewerLinks(projectId, moduleId, assembled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Checks if DataLineage is possible for given module
     * @summary Checks if DataLineage is possible for given module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getDataLineageAvailableForModule(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getDataLineageAvailableForModule(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Count all modules for one project
     * @summary Count all modules for one project
     * @param {EntityId} projectId the ID of the project to examine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getModuleCount(projectId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getModuleCount(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Statistics of all modules for one project
     * @summary Statistics of all modules for one project
     * @param {EntityId} projectId the ID of the project to examine
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public getModuleStatistics(projectId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).getModuleStatistics(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find if module has AST Nodes
     * @summary Find if module has AST Nodes
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public hasAstNodes(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).hasAstNodes(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that identifies Module descriptions for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules relative to the project. Example &#x3D; {1}, {src/file.cbl}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public identifyModuleDescriptions(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).identifyModuleDescriptions(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Store AST Nodes for the specified Module
     * @summary Store AST Nodes for the specified Module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public storeAstNodes(projectId: EntityId, moduleId: EntityId, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).storeAstNodes(projectId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find all dependencies of a module
     * @summary Find all dependencies of a module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {number} maxDepth the depth of the traversal
     * @param {number} [maxGraphNodes] the number of graph nodes to be returned
     * @param {string} [query] filtering parameters
     * @param {boolean} [distinct] filter duplicate dependencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public traverseModuleDependencies(projectId: EntityId, moduleId: EntityId, maxDepth: number, maxGraphNodes?: number, query?: string, distinct?: boolean, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).traverseModuleDependencies(projectId, moduleId, maxDepth, maxGraphNodes, query, distinct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update an existing module
     * @summary Update an existing module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module to be updated
     * @param {ModulePojoPrototype} modulePojoPrototype The updated module data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ModuleControllerApi
     */
    public updateModule(projectId: EntityId, moduleId: EntityId, modulePojoPrototype: ModulePojoPrototype, options?: AxiosRequestConfig) {
        return ModuleControllerApiFp(this.configuration).updateModule(projectId, moduleId, modulePojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectControllerApi - axios parameter creator
 * @export
 */
export const ProjectControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Create a new project
         * @summary Create a new project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject1: async (projectPojoPrototype: ProjectPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPojoPrototype' is not null or undefined
            assertParamExists('createProject1', 'projectPojoPrototype', projectPojoPrototype)
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete an entry in the auto-completion list for the received key for a project
         * @summary Delete an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the project ID
         * @param {string} key the key of the auto-completion list
         * @param {string} value the value to be deleted from auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoCompletionValue: async (projectId: EntityId, key: string, value: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteAutoCompletionValue', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('deleteAutoCompletionValue', 'key', key)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('deleteAutoCompletionValue', 'value', value)
            const localVarPath = `/api/v1/projects/{projectId}/autoCompletion/{key}/{value}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects
         * @summary List all existing projects
         * @param {boolean} [deleted] whether to include projects marked for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProjects: async (deleted?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a project by id
         * @summary Find a project by id
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectById: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findProjectById', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects of a Client
         * @summary List all existing projects of a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectsForClient1: async (clientId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findProjectsForClient1', 'clientId', clientId)
            const localVarPath = `/api/v1/clients/{clientId}/projects`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Get the auto-completion list identifiers defined on a project
         * @summary Get the auto-completion list identifiers defined on a project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoCompletionKeys: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAutoCompletionKeys', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/autoCompletion`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Retrieve an auto-completion list from a project
         * @summary Retrieve an auto-completion list from a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoCompletionList: async (projectId: EntityId, key: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAutoCompletionList', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getAutoCompletionList', 'key', key)
            const localVarPath = `/api/v1/projects/{projectId}/autoCompletion/{key}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Rename an entry in the auto-completion list for the received key for a project
         * @summary Rename an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {string} oldValue the old value in the auto-completion list
         * @param {string} newValue the value to be renamed to in the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameAutoCompletionValue: async (projectId: EntityId, key: string, oldValue: string, newValue: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('renameAutoCompletionValue', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('renameAutoCompletionValue', 'key', key)
            // verify required parameter 'oldValue' is not null or undefined
            assertParamExists('renameAutoCompletionValue', 'oldValue', oldValue)
            // verify required parameter 'newValue' is not null or undefined
            assertParamExists('renameAutoCompletionValue', 'newValue', newValue)
            const localVarPath = `/api/v1/projects/{projectId}/autoCompletion/{key}/{oldValue}/{newValue}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)))
                .replace(`{${"oldValue"}}`, encodeURIComponent(String(oldValue)))
                .replace(`{${"newValue"}}`, encodeURIComponent(String(newValue)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Set the entries of an auto-completion list for a project
         * @summary Set the entries of an auto-completion list for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {Array<string>} requestBody Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoCompletionList: async (projectId: EntityId, key: string, requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('setAutoCompletionList', 'projectId', projectId)
            // verify required parameter 'key' is not null or undefined
            assertParamExists('setAutoCompletionList', 'key', key)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('setAutoCompletionList', 'requestBody', requestBody)
            const localVarPath = `/api/v1/projects/{projectId}/autoCompletion/{key}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"key"}}`, encodeURIComponent(String(key)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Reset a projects configuration
         * @summary Reset a projects configuration
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProjectDefaultConfiguration: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('setProjectDefaultConfiguration', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/defaultConfiguration`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Update an existing project
         * @summary Update an existing project
         * @param {EntityId} projectId the ID of the project to be updated
         * @param {ProjectPojoPrototype} projectPojoPrototype The updated project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject: async (projectId: EntityId, projectPojoPrototype: ProjectPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateProject', 'projectId', projectId)
            // verify required parameter 'projectPojoPrototype' is not null or undefined
            assertParamExists('updateProject', 'projectPojoPrototype', projectPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectControllerApi - functional programming interface
 * @export
 */
export const ProjectControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Create a new project
         * @summary Create a new project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject1(projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject1(projectPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete an entry in the auto-completion list for the received key for a project
         * @summary Delete an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the project ID
         * @param {string} key the key of the auto-completion list
         * @param {string} value the value to be deleted from auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAutoCompletionValue(projectId: EntityId, key: string, value: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAutoCompletionValue(projectId, key, value, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects
         * @summary List all existing projects
         * @param {boolean} [deleted] whether to include projects marked for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllProjects(deleted?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllProjects(deleted, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a project by id
         * @summary Find a project by id
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProjectById(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProjectById(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects of a Client
         * @summary List all existing projects of a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProjectsForClient1(clientId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProjectsForClient1(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Get the auto-completion list identifiers defined on a project
         * @summary Get the auto-completion list identifiers defined on a project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoCompletionKeys(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoCompletionKeys(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Retrieve an auto-completion list from a project
         * @summary Retrieve an auto-completion list from a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAutoCompletionList(projectId: EntityId, key: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAutoCompletionList(projectId, key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Rename an entry in the auto-completion list for the received key for a project
         * @summary Rename an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {string} oldValue the old value in the auto-completion list
         * @param {string} newValue the value to be renamed to in the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async renameAutoCompletionValue(projectId: EntityId, key: string, oldValue: string, newValue: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.renameAutoCompletionValue(projectId, key, oldValue, newValue, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Set the entries of an auto-completion list for a project
         * @summary Set the entries of an auto-completion list for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {Array<string>} requestBody Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setAutoCompletionList(projectId: EntityId, key: string, requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setAutoCompletionList(projectId, key, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Reset a projects configuration
         * @summary Reset a projects configuration
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setProjectDefaultConfiguration(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setProjectDefaultConfiguration(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Update an existing project
         * @summary Update an existing project
         * @param {EntityId} projectId the ID of the project to be updated
         * @param {ProjectPojoPrototype} projectPojoPrototype The updated project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProject(projectId: EntityId, projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProject(projectId, projectPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectControllerApi - factory interface
 * @export
 */
export const ProjectControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectControllerApiFp(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Create a new project
         * @summary Create a new project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject1(projectPojoPrototype: ProjectPojoPrototype, options?: any): AxiosPromise<ProjectPojo> {
            return localVarFp.createProject1(projectPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete an entry in the auto-completion list for the received key for a project
         * @summary Delete an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the project ID
         * @param {string} key the key of the auto-completion list
         * @param {string} value the value to be deleted from auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAutoCompletionValue(projectId: EntityId, key: string, value: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAutoCompletionValue(projectId, key, value, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects
         * @summary List all existing projects
         * @param {boolean} [deleted] whether to include projects marked for deletion
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllProjects(deleted?: boolean, options?: any): AxiosPromise<Array<ProjectPojo>> {
            return localVarFp.findAllProjects(deleted, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a project by id
         * @summary Find a project by id
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectById(projectId: EntityId, options?: any): AxiosPromise<ProjectPojo> {
            return localVarFp.findProjectById(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects of a Client
         * @summary List all existing projects of a Client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectsForClient1(clientId: number, options?: any): AxiosPromise<Array<ProjectPojo>> {
            return localVarFp.findProjectsForClient1(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Get the auto-completion list identifiers defined on a project
         * @summary Get the auto-completion list identifiers defined on a project
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoCompletionKeys(projectId: EntityId, options?: any): AxiosPromise<Set<string>> {
            return localVarFp.getAutoCompletionKeys(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Retrieve an auto-completion list from a project
         * @summary Retrieve an auto-completion list from a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAutoCompletionList(projectId: EntityId, key: string, options?: any): AxiosPromise<Set<string>> {
            return localVarFp.getAutoCompletionList(projectId, key, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Rename an entry in the auto-completion list for the received key for a project
         * @summary Rename an entry in the auto-completion list for the received key for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {string} oldValue the old value in the auto-completion list
         * @param {string} newValue the value to be renamed to in the auto-completion list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameAutoCompletionValue(projectId: EntityId, key: string, oldValue: string, newValue: string, options?: any): AxiosPromise<void> {
            return localVarFp.renameAutoCompletionValue(projectId, key, oldValue, newValue, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Set the entries of an auto-completion list for a project
         * @summary Set the entries of an auto-completion list for a project
         * @param {EntityId} projectId the ID of the project
         * @param {string} key the key of the auto-completion list
         * @param {Array<string>} requestBody Entries
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setAutoCompletionList(projectId: EntityId, key: string, requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.setAutoCompletionList(projectId, key, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Reset a projects configuration
         * @summary Reset a projects configuration
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setProjectDefaultConfiguration(projectId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.setProjectDefaultConfiguration(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Update an existing project
         * @summary Update an existing project
         * @param {EntityId} projectId the ID of the project to be updated
         * @param {ProjectPojoPrototype} projectPojoPrototype The updated project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProject(projectId: EntityId, projectPojoPrototype: ProjectPojoPrototype, options?: any): AxiosPromise<ProjectPojo> {
            return localVarFp.updateProject(projectId, projectPojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectControllerApi - object-oriented interface
 * @export
 * @class ProjectControllerApi
 * @extends {BaseAPI}
 */
export class ProjectControllerApi extends BaseAPI {
    /**
     * User Role(s): client-admin | Project Nature(s): mining  Create a new project
     * @summary Create a new project
     * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public createProject1(projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).createProject1(projectPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Delete an entry in the auto-completion list for the received key for a project
     * @summary Delete an entry in the auto-completion list for the received key for a project
     * @param {EntityId} projectId the project ID
     * @param {string} key the key of the auto-completion list
     * @param {string} value the value to be deleted from auto-completion list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public deleteAutoCompletionValue(projectId: EntityId, key: string, value: string, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).deleteAutoCompletionValue(projectId, key, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects
     * @summary List all existing projects
     * @param {boolean} [deleted] whether to include projects marked for deletion
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public findAllProjects(deleted?: boolean, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).findAllProjects(deleted, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Find a project by id
     * @summary Find a project by id
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public findProjectById(projectId: EntityId, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).findProjectById(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  List all existing projects of a Client
     * @summary List all existing projects of a Client
     * @param {number} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public findProjectsForClient1(clientId: number, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).findProjectsForClient1(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Get the auto-completion list identifiers defined on a project
     * @summary Get the auto-completion list identifiers defined on a project
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getAutoCompletionKeys(projectId: EntityId, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).getAutoCompletionKeys(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Retrieve an auto-completion list from a project
     * @summary Retrieve an auto-completion list from a project
     * @param {EntityId} projectId the ID of the project
     * @param {string} key the key of the auto-completion list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public getAutoCompletionList(projectId: EntityId, key: string, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).getAutoCompletionList(projectId, key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Rename an entry in the auto-completion list for the received key for a project
     * @summary Rename an entry in the auto-completion list for the received key for a project
     * @param {EntityId} projectId the ID of the project
     * @param {string} key the key of the auto-completion list
     * @param {string} oldValue the old value in the auto-completion list
     * @param {string} newValue the value to be renamed to in the auto-completion list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public renameAutoCompletionValue(projectId: EntityId, key: string, oldValue: string, newValue: string, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).renameAutoCompletionValue(projectId, key, oldValue, newValue, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Set the entries of an auto-completion list for a project
     * @summary Set the entries of an auto-completion list for a project
     * @param {EntityId} projectId the ID of the project
     * @param {string} key the key of the auto-completion list
     * @param {Array<string>} requestBody Entries
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public setAutoCompletionList(projectId: EntityId, key: string, requestBody: Array<string>, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).setAutoCompletionList(projectId, key, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Reset a projects configuration
     * @summary Reset a projects configuration
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public setProjectDefaultConfiguration(projectId: EntityId, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).setProjectDefaultConfiguration(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining  Update an existing project
     * @summary Update an existing project
     * @param {EntityId} projectId the ID of the project to be updated
     * @param {ProjectPojoPrototype} projectPojoPrototype The updated project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerApi
     */
    public updateProject(projectId: EntityId, projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig) {
        return ProjectControllerApiFp(this.configuration).updateProject(projectId, projectPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProjectControllerV2Api - axios parameter creator
 * @export
 */
export const ProjectControllerV2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Changes the project natures
         * @summary Changes the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be changed
         * @param {Set<string>} requestBody The Set of project natures to assign. Available values : DISCOVERY, DISCOVERY_LIGHT, MINING, DB_CUTTER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProjectNatures: async (projectId: EntityId, requestBody: Set<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('changeProjectNatures', 'projectId', projectId)
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('changeProjectNatures', 'requestBody', requestBody)
            const localVarPath = `/api/v2/projects/{projectId}/natures`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Creates a new Project
         * @summary Creates a new Project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject: async (projectPojoPrototype: ProjectPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectPojoPrototype' is not null or undefined
            assertParamExists('createProject', 'projectPojoPrototype', projectPojoPrototype)
            const localVarPath = `/api/v2/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Deletes a project with complete cascading effect
         * @summary Deletes a project with complete cascading effect
         * @param {EntityId} projectId the ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteProject', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Fetch number of projects for client
         * @summary Fetch number of projects for client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectCount: async (clientId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findProjectCount', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/projects/count`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  find the project natures
         * @summary find the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectNatures: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findProjectNatures', 'projectId', projectId)
            const localVarPath = `/api/v2/projects/{projectId}/natures`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Paginates over the Projects for a Client
         * @summary Paginates over the Projects for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectsForClient: async (clientId: number, page?: number, size?: number, sortBy?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('findProjectsForClient', 'clientId', clientId)
            const localVarPath = `/api/v2/clients/{clientId}/projects`
                .replace(`{${"clientId"}}`, encodeURIComponent(String(clientId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy) {
                localVarQueryParameter['sortBy'] = sortBy;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectControllerV2Api - functional programming interface
 * @export
 */
export const ProjectControllerV2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectControllerV2ApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Changes the project natures
         * @summary Changes the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be changed
         * @param {Set<string>} requestBody The Set of project natures to assign. Available values : DISCOVERY, DISCOVERY_LIGHT, MINING, DB_CUTTER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async changeProjectNatures(projectId: EntityId, requestBody: Set<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.changeProjectNatures(projectId, requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Creates a new Project
         * @summary Creates a new Project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProject(projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProject(projectPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Deletes a project with complete cascading effect
         * @summary Deletes a project with complete cascading effect
         * @param {EntityId} projectId the ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteProject(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteProject(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Fetch number of projects for client
         * @summary Fetch number of projects for client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProjectCount(clientId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProjectCount(clientId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  find the project natures
         * @summary find the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProjectNatures(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProjectNatures(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Paginates over the Projects for a Client
         * @summary Paginates over the Projects for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findProjectsForClient(clientId: number, page?: number, size?: number, sortBy?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PagedProjectPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findProjectsForClient(clientId, page, size, sortBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProjectControllerV2Api - factory interface
 * @export
 */
export const ProjectControllerV2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectControllerV2ApiFp(configuration)
    return {
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Changes the project natures
         * @summary Changes the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be changed
         * @param {Set<string>} requestBody The Set of project natures to assign. Available values : DISCOVERY, DISCOVERY_LIGHT, MINING, DB_CUTTER
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeProjectNatures(projectId: EntityId, requestBody: Set<string>, options?: any): AxiosPromise<void> {
            return localVarFp.changeProjectNatures(projectId, requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Creates a new Project
         * @summary Creates a new Project
         * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProject(projectPojoPrototype: ProjectPojoPrototype, options?: any): AxiosPromise<ProjectPojo> {
            return localVarFp.createProject(projectPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  Deletes a project with complete cascading effect
         * @summary Deletes a project with complete cascading effect
         * @param {EntityId} projectId the ID of the Project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProject(projectId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteProject(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Fetch number of projects for client
         * @summary Fetch number of projects for client
         * @param {number} clientId the ID of the client to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectCount(clientId: number, options?: any): AxiosPromise<number> {
            return localVarFp.findProjectCount(clientId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): client-admin | Project Nature(s): mining  find the project natures
         * @summary find the project natures
         * @param {EntityId} projectId the ID of the project for which natures have to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectNatures(projectId: EntityId, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.findProjectNatures(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Paginates over the Projects for a Client
         * @summary Paginates over the Projects for a Client
         * @param {number} clientId the ID of the client to search
         * @param {number} [page] the page number to be fetched
         * @param {number} [size] the size of each page
         * @param {Array<string>} [sortBy] the sort conditions as string array
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findProjectsForClient(clientId: number, page?: number, size?: number, sortBy?: Array<string>, options?: any): AxiosPromise<PagedProjectPojo> {
            return localVarFp.findProjectsForClient(clientId, page, size, sortBy, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectControllerV2Api - object-oriented interface
 * @export
 * @class ProjectControllerV2Api
 * @extends {BaseAPI}
 */
export class ProjectControllerV2Api extends BaseAPI {
    /**
     * User Role(s): client-admin | Project Nature(s): mining  Changes the project natures
     * @summary Changes the project natures
     * @param {EntityId} projectId the ID of the project for which natures have to be changed
     * @param {Set<string>} requestBody The Set of project natures to assign. Available values : DISCOVERY, DISCOVERY_LIGHT, MINING, DB_CUTTER
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public changeProjectNatures(projectId: EntityId, requestBody: Set<string>, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).changeProjectNatures(projectId, requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining  Creates a new Project
     * @summary Creates a new Project
     * @param {ProjectPojoPrototype} projectPojoPrototype The project to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public createProject(projectPojoPrototype: ProjectPojoPrototype, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).createProject(projectPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining  Deletes a project with complete cascading effect
     * @summary Deletes a project with complete cascading effect
     * @param {EntityId} projectId the ID of the Project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public deleteProject(projectId: EntityId, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).deleteProject(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Fetch number of projects for client
     * @summary Fetch number of projects for client
     * @param {number} clientId the ID of the client to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public findProjectCount(clientId: number, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).findProjectCount(clientId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): client-admin | Project Nature(s): mining  find the project natures
     * @summary find the project natures
     * @param {EntityId} projectId the ID of the project for which natures have to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public findProjectNatures(projectId: EntityId, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).findProjectNatures(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery,discovery-light  Paginates over the Projects for a Client
     * @summary Paginates over the Projects for a Client
     * @param {number} clientId the ID of the client to search
     * @param {number} [page] the page number to be fetched
     * @param {number} [size] the size of each page
     * @param {Array<string>} [sortBy] the sort conditions as string array
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectControllerV2Api
     */
    public findProjectsForClient(clientId: number, page?: number, size?: number, sortBy?: Array<string>, options?: AxiosRequestConfig) {
        return ProjectControllerV2ApiFp(this.configuration).findProjectsForClient(clientId, page, size, sortBy, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ReferenceControllerApi - axios parameter creator
 * @export
 */
export const ReferenceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new reference
         * @summary Create a new reference
         * @param {EntityId} projectId the project ID
         * @param {number} moduleId the ID of the module
         * @param {ModuleRelationshipPojoPrototype} moduleRelationshipPojoPrototype The reference to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReference: async (projectId: EntityId, moduleId: number, moduleRelationshipPojoPrototype: ModuleRelationshipPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createReference', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('createReference', 'moduleId', moduleId)
            // verify required parameter 'moduleRelationshipPojoPrototype' is not null or undefined
            assertParamExists('createReference', 'moduleRelationshipPojoPrototype', moduleRelationshipPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/references`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleRelationshipPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a reference
         * @summary Delete a reference
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to delete
         * @param {number} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReference: async (projectId: EntityId, referenceId: string, moduleId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteReference', 'projectId', projectId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('deleteReference', 'referenceId', referenceId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('deleteReference', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/references/{referenceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all references by from and to module id\'s
         * @summary Find all references by from and to module id\'s
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the from ID of the module
         * @param {EntityId} referencedModuleId the to ID of the module
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} relationship relationship of the reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllByFromAndToModuleIds: async (projectId: EntityId, moduleId: EntityId, referencedModuleId: EntityId, relationship: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllByFromAndToModuleIds', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAllByFromAndToModuleIds', 'moduleId', moduleId)
            // verify required parameter 'referencedModuleId' is not null or undefined
            assertParamExists('findAllByFromAndToModuleIds', 'referencedModuleId', referencedModuleId)
            // verify required parameter 'relationship' is not null or undefined
            assertParamExists('findAllByFromAndToModuleIds', 'relationship', relationship)
            const localVarPath = `/api/v1/projects/{projectId}/references/{moduleId}/{referencedModuleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)))
                .replace(`{${"referencedModuleId"}}`, encodeURIComponent(String(referencedModuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (relationship !== undefined) {
                localVarQueryParameter['relationship'] = relationship;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {string} [relationship] the relationship of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReferencesForModule: async (projectId: EntityId, moduleId: EntityId, direction?: string, relationship?: string, distinct?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllReferencesForModule', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAllReferencesForModule', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/references`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (relationship !== undefined) {
                localVarQueryParameter['relationship'] = relationship;
            }

            if (distinct !== undefined) {
                localVarQueryParameter['distinct'] = distinct;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for a given project
         * @summary Get all references for a given project
         * @param {EntityId} projectId the project ID
         * @param {string} [direction] the direction of the references to list
         * @param {string} [relationship] the relationship of the references to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReferencesForProject: async (projectId: EntityId, direction?: string, relationship?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllReferencesForProject', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/references`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (relationship !== undefined) {
                localVarQueryParameter['relationship'] = relationship;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {Array<string>} [relationships] the possible relationships of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllforModuleMultipleTypes: async (projectId: EntityId, moduleId: EntityId, direction?: string, relationships?: Array<string>, distinct?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllforModuleMultipleTypes', 'projectId', projectId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findAllforModuleMultipleTypes', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/references-multiple-types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (relationships) {
                localVarQueryParameter['relationships'] = relationships;
            }

            if (distinct !== undefined) {
                localVarQueryParameter['distinct'] = distinct;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a reference by id
         * @summary Find a reference by id
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to find
         * @param {number} moduleId the ID of the module to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReferenceById: async (projectId: EntityId, referenceId: string, moduleId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findReferenceById', 'projectId', projectId)
            // verify required parameter 'referenceId' is not null or undefined
            assertParamExists('findReferenceById', 'referenceId', referenceId)
            // verify required parameter 'moduleId' is not null or undefined
            assertParamExists('findReferenceById', 'moduleId', moduleId)
            const localVarPath = `/api/v1/projects/{projectId}/modules/{moduleId}/references/{referenceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"referenceId"}}`, encodeURIComponent(String(referenceId)))
                .replace(`{${"moduleId"}}`, encodeURIComponent(String(moduleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of references
         * @summary Get aggregated values over a number of references
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestRelationshipFieldName} aggregationRequestRelationshipFieldName The aggregation request
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} [relationship] limit aggregation to relationships of certain type (optional but highly recommended, will speed up the query)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues1: async (projectId: EntityId, aggregationRequestRelationshipFieldName: AggregationRequestRelationshipFieldName, relationship?: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedValues1', 'projectId', projectId)
            // verify required parameter 'aggregationRequestRelationshipFieldName' is not null or undefined
            assertParamExists('getAggregatedValues1', 'aggregationRequestRelationshipFieldName', aggregationRequestRelationshipFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/references/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (relationship !== undefined) {
                localVarQueryParameter['relationship'] = relationship;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestRelationshipFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReferenceControllerApi - functional programming interface
 * @export
 */
export const ReferenceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ReferenceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new reference
         * @summary Create a new reference
         * @param {EntityId} projectId the project ID
         * @param {number} moduleId the ID of the module
         * @param {ModuleRelationshipPojoPrototype} moduleRelationshipPojoPrototype The reference to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createReference(projectId: EntityId, moduleId: number, moduleRelationshipPojoPrototype: ModuleRelationshipPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleRelationshipPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createReference(projectId, moduleId, moduleRelationshipPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a reference
         * @summary Delete a reference
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to delete
         * @param {number} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteReference(projectId: EntityId, referenceId: string, moduleId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteReference(projectId, referenceId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all references by from and to module id\'s
         * @summary Find all references by from and to module id\'s
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the from ID of the module
         * @param {EntityId} referencedModuleId the to ID of the module
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} relationship relationship of the reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllByFromAndToModuleIds(projectId: EntityId, moduleId: EntityId, referencedModuleId: EntityId, relationship: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModuleRelationshipPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllByFromAndToModuleIds(projectId, moduleId, referencedModuleId, relationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {string} [relationship] the relationship of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllReferencesForModule(projectId: EntityId, moduleId: EntityId, direction?: string, relationship?: string, distinct?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModuleRelationshipPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllReferencesForModule(projectId, moduleId, direction, relationship, distinct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for a given project
         * @summary Get all references for a given project
         * @param {EntityId} projectId the project ID
         * @param {string} [direction] the direction of the references to list
         * @param {string} [relationship] the relationship of the references to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllReferencesForProject(projectId: EntityId, direction?: string, relationship?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModuleRelationshipPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllReferencesForProject(projectId, direction, relationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {Array<string>} [relationships] the possible relationships of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllforModuleMultipleTypes(projectId: EntityId, moduleId: EntityId, direction?: string, relationships?: Array<string>, distinct?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ModuleRelationshipPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllforModuleMultipleTypes(projectId, moduleId, direction, relationships, distinct, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a reference by id
         * @summary Find a reference by id
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to find
         * @param {number} moduleId the ID of the module to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findReferenceById(projectId: EntityId, referenceId: string, moduleId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModuleRelationshipPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findReferenceById(projectId, referenceId, moduleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of references
         * @summary Get aggregated values over a number of references
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestRelationshipFieldName} aggregationRequestRelationshipFieldName The aggregation request
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} [relationship] limit aggregation to relationships of certain type (optional but highly recommended, will speed up the query)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedValues1(projectId: EntityId, aggregationRequestRelationshipFieldName: AggregationRequestRelationshipFieldName, relationship?: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultRelationshipFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedValues1(projectId, aggregationRequestRelationshipFieldName, relationship, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ReferenceControllerApi - factory interface
 * @export
 */
export const ReferenceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ReferenceControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new reference
         * @summary Create a new reference
         * @param {EntityId} projectId the project ID
         * @param {number} moduleId the ID of the module
         * @param {ModuleRelationshipPojoPrototype} moduleRelationshipPojoPrototype The reference to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createReference(projectId: EntityId, moduleId: number, moduleRelationshipPojoPrototype: ModuleRelationshipPojoPrototype, options?: any): AxiosPromise<ModuleRelationshipPojo> {
            return localVarFp.createReference(projectId, moduleId, moduleRelationshipPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a reference
         * @summary Delete a reference
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to delete
         * @param {number} moduleId the ID of the module
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteReference(projectId: EntityId, referenceId: string, moduleId: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteReference(projectId, referenceId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find all references by from and to module id\'s
         * @summary Find all references by from and to module id\'s
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the from ID of the module
         * @param {EntityId} referencedModuleId the to ID of the module
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} relationship relationship of the reference
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllByFromAndToModuleIds(projectId: EntityId, moduleId: EntityId, referencedModuleId: EntityId, relationship: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: any): AxiosPromise<Array<ModuleRelationshipPojo>> {
            return localVarFp.findAllByFromAndToModuleIds(projectId, moduleId, referencedModuleId, relationship, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {string} [relationship] the relationship of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReferencesForModule(projectId: EntityId, moduleId: EntityId, direction?: string, relationship?: string, distinct?: boolean, options?: any): AxiosPromise<Array<ModuleRelationshipPojo>> {
            return localVarFp.findAllReferencesForModule(projectId, moduleId, direction, relationship, distinct, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for a given project
         * @summary Get all references for a given project
         * @param {EntityId} projectId the project ID
         * @param {string} [direction] the direction of the references to list
         * @param {string} [relationship] the relationship of the references to list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllReferencesForProject(projectId: EntityId, direction?: string, relationship?: string, options?: any): AxiosPromise<Array<ModuleRelationshipPojo>> {
            return localVarFp.findAllReferencesForProject(projectId, direction, relationship, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
         * @summary Get all references for one module
         * @param {EntityId} projectId the ID of the project
         * @param {EntityId} moduleId the ID of the module
         * @param {string} [direction] the direction of the references
         * @param {Array<string>} [relationships] the possible relationships of the references
         * @param {boolean} [distinct] filter duplicate dependencies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllforModuleMultipleTypes(projectId: EntityId, moduleId: EntityId, direction?: string, relationships?: Array<string>, distinct?: boolean, options?: any): AxiosPromise<Array<ModuleRelationshipPojo>> {
            return localVarFp.findAllforModuleMultipleTypes(projectId, moduleId, direction, relationships, distinct, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a reference by id
         * @summary Find a reference by id
         * @param {EntityId} projectId the project ID
         * @param {string} referenceId the ID of the reference to find
         * @param {number} moduleId the ID of the module to search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findReferenceById(projectId: EntityId, referenceId: string, moduleId: number, options?: any): AxiosPromise<ModuleRelationshipPojo> {
            return localVarFp.findReferenceById(projectId, referenceId, moduleId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of references
         * @summary Get aggregated values over a number of references
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestRelationshipFieldName} aggregationRequestRelationshipFieldName The aggregation request
         * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} [relationship] limit aggregation to relationships of certain type (optional but highly recommended, will speed up the query)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues1(projectId: EntityId, aggregationRequestRelationshipFieldName: AggregationRequestRelationshipFieldName, relationship?: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: any): AxiosPromise<Array<AggregationResultRelationshipFieldName>> {
            return localVarFp.getAggregatedValues1(projectId, aggregationRequestRelationshipFieldName, relationship, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReferenceControllerApi - object-oriented interface
 * @export
 * @class ReferenceControllerApi
 * @extends {BaseAPI}
 */
export class ReferenceControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Create a new reference
     * @summary Create a new reference
     * @param {EntityId} projectId the project ID
     * @param {number} moduleId the ID of the module
     * @param {ModuleRelationshipPojoPrototype} moduleRelationshipPojoPrototype The reference to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public createReference(projectId: EntityId, moduleId: number, moduleRelationshipPojoPrototype: ModuleRelationshipPojoPrototype, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).createReference(projectId, moduleId, moduleRelationshipPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Delete a reference
     * @summary Delete a reference
     * @param {EntityId} projectId the project ID
     * @param {string} referenceId the ID of the reference to delete
     * @param {number} moduleId the ID of the module
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public deleteReference(projectId: EntityId, referenceId: string, moduleId: number, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).deleteReference(projectId, referenceId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find all references by from and to module id\'s
     * @summary Find all references by from and to module id\'s
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the from ID of the module
     * @param {EntityId} referencedModuleId the to ID of the module
     * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} relationship relationship of the reference
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public findAllByFromAndToModuleIds(projectId: EntityId, moduleId: EntityId, referencedModuleId: EntityId, relationship: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).findAllByFromAndToModuleIds(projectId, moduleId, referencedModuleId, relationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
     * @summary Get all references for one module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {string} [direction] the direction of the references
     * @param {string} [relationship] the relationship of the references
     * @param {boolean} [distinct] filter duplicate dependencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public findAllReferencesForModule(projectId: EntityId, moduleId: EntityId, direction?: string, relationship?: string, distinct?: boolean, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).findAllReferencesForModule(projectId, moduleId, direction, relationship, distinct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all references for a given project
     * @summary Get all references for a given project
     * @param {EntityId} projectId the project ID
     * @param {string} [direction] the direction of the references to list
     * @param {string} [relationship] the relationship of the references to list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public findAllReferencesForProject(projectId: EntityId, direction?: string, relationship?: string, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).findAllReferencesForProject(projectId, direction, relationship, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all references for one module
     * @summary Get all references for one module
     * @param {EntityId} projectId the ID of the project
     * @param {EntityId} moduleId the ID of the module
     * @param {string} [direction] the direction of the references
     * @param {Array<string>} [relationships] the possible relationships of the references
     * @param {boolean} [distinct] filter duplicate dependencies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public findAllforModuleMultipleTypes(projectId: EntityId, moduleId: EntityId, direction?: string, relationships?: Array<string>, distinct?: boolean, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).findAllforModuleMultipleTypes(projectId, moduleId, direction, relationships, distinct, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find a reference by id
     * @summary Find a reference by id
     * @param {EntityId} projectId the project ID
     * @param {string} referenceId the ID of the reference to find
     * @param {number} moduleId the ID of the module to search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public findReferenceById(projectId: EntityId, referenceId: string, moduleId: number, options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).findReferenceById(projectId, referenceId, moduleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of references
     * @summary Get aggregated values over a number of references
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestRelationshipFieldName} aggregationRequestRelationshipFieldName The aggregation request
     * @param {'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES'} [relationship] limit aggregation to relationships of certain type (optional but highly recommended, will speed up the query)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReferenceControllerApi
     */
    public getAggregatedValues1(projectId: EntityId, aggregationRequestRelationshipFieldName: AggregationRequestRelationshipFieldName, relationship?: 'NONE' | 'INCLUDES' | 'CONTAINS' | 'REFERENCES' | 'CALLS' | 'ACCESSES' | 'ARTIFICIAL' | 'PRECEDES', options?: AxiosRequestConfig) {
        return ReferenceControllerApiFp(this.configuration).getAggregatedValues1(projectId, aggregationRequestRelationshipFieldName, relationship, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SavedSearchControllerApi - axios parameter creator
 * @export
 */
export const SavedSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new Saved Search record
         * @summary Create a new Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch: async (projectId: EntityId, savedSearchPojoPrototype: SavedSearchPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createSavedSearch', 'projectId', projectId)
            // verify required parameter 'savedSearchPojoPrototype' is not null or undefined
            assertParamExists('createSavedSearch', 'savedSearchPojoPrototype', savedSearchPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/savedSearches`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearchPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a Saved Search record
         * @summary Delete a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch: async (projectId: EntityId, id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteSavedSearch', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSavedSearch', 'id', id)
            const localVarPath = `/api/v1/projects/{projectId}/savedSearches/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find Saved Search records by its usage
         * @summary Find Saved Search records by its usage
         * @param {EntityId} projectId the project ID
         * @param {string} usage the usage of the Saved Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUsage: async (projectId: EntityId, usage: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findByUsage', 'projectId', projectId)
            // verify required parameter 'usage' is not null or undefined
            assertParamExists('findByUsage', 'usage', usage)
            const localVarPath = `/api/v1/projects/{projectId}/savedSearches/{usage}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"usage"}}`, encodeURIComponent(String(usage)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the count of the SavedSearches for the provided projectId.
         * @summary Returns the count of the SavedSearches for the provided projectId.
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardSavedSearchCounts: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getDashboardSavedSearchCounts', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/dashboard/savedSearchCounts`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a Saved Search record
         * @summary Update a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be updated
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedSearch: async (projectId: EntityId, id: number, savedSearchPojoPrototype: SavedSearchPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateSavedSearch', 'projectId', projectId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateSavedSearch', 'id', id)
            // verify required parameter 'savedSearchPojoPrototype' is not null or undefined
            assertParamExists('updateSavedSearch', 'savedSearchPojoPrototype', savedSearchPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/savedSearches/{id}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(savedSearchPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SavedSearchControllerApi - functional programming interface
 * @export
 */
export const SavedSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SavedSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new Saved Search record
         * @summary Create a new Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSavedSearch(projectId: EntityId, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearchPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSavedSearch(projectId, savedSearchPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a Saved Search record
         * @summary Delete a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSavedSearch(projectId: EntityId, id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSavedSearch(projectId, id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find Saved Search records by its usage
         * @summary Find Saved Search records by its usage
         * @param {EntityId} projectId the project ID
         * @param {string} usage the usage of the Saved Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findByUsage(projectId: EntityId, usage: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearchPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findByUsage(projectId, usage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the count of the SavedSearches for the provided projectId.
         * @summary Returns the count of the SavedSearches for the provided projectId.
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDashboardSavedSearchCounts(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SavedSearchCountResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDashboardSavedSearchCounts(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a Saved Search record
         * @summary Update a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be updated
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSavedSearch(projectId: EntityId, id: number, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SavedSearchPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSavedSearch(projectId, id, savedSearchPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SavedSearchControllerApi - factory interface
 * @export
 */
export const SavedSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SavedSearchControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Create a new Saved Search record
         * @summary Create a new Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSavedSearch(projectId: EntityId, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: any): AxiosPromise<SavedSearchPojo> {
            return localVarFp.createSavedSearch(projectId, savedSearchPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Delete a Saved Search record
         * @summary Delete a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSavedSearch(projectId: EntityId, id: number, options?: any): AxiosPromise<void> {
            return localVarFp.deleteSavedSearch(projectId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find Saved Search records by its usage
         * @summary Find Saved Search records by its usage
         * @param {EntityId} projectId the project ID
         * @param {string} usage the usage of the Saved Search
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findByUsage(projectId: EntityId, usage: string, options?: any): AxiosPromise<Array<SavedSearchPojo>> {
            return localVarFp.findByUsage(projectId, usage, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Returns the count of the SavedSearches for the provided projectId.
         * @summary Returns the count of the SavedSearches for the provided projectId.
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDashboardSavedSearchCounts(projectId: EntityId, options?: any): AxiosPromise<Array<SavedSearchCountResponse>> {
            return localVarFp.getDashboardSavedSearchCounts(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Update a Saved Search record
         * @summary Update a Saved Search record
         * @param {EntityId} projectId the project ID
         * @param {number} id the id of the Saved Seach to be updated
         * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSavedSearch(projectId: EntityId, id: number, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: any): AxiosPromise<SavedSearchPojo> {
            return localVarFp.updateSavedSearch(projectId, id, savedSearchPojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SavedSearchControllerApi - object-oriented interface
 * @export
 * @class SavedSearchControllerApi
 * @extends {BaseAPI}
 */
export class SavedSearchControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Create a new Saved Search record
     * @summary Create a new Saved Search record
     * @param {EntityId} projectId the project ID
     * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchControllerApi
     */
    public createSavedSearch(projectId: EntityId, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: AxiosRequestConfig) {
        return SavedSearchControllerApiFp(this.configuration).createSavedSearch(projectId, savedSearchPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Delete a Saved Search record
     * @summary Delete a Saved Search record
     * @param {EntityId} projectId the project ID
     * @param {number} id the id of the Saved Seach to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchControllerApi
     */
    public deleteSavedSearch(projectId: EntityId, id: number, options?: AxiosRequestConfig) {
        return SavedSearchControllerApiFp(this.configuration).deleteSavedSearch(projectId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find Saved Search records by its usage
     * @summary Find Saved Search records by its usage
     * @param {EntityId} projectId the project ID
     * @param {string} usage the usage of the Saved Search
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchControllerApi
     */
    public findByUsage(projectId: EntityId, usage: string, options?: AxiosRequestConfig) {
        return SavedSearchControllerApiFp(this.configuration).findByUsage(projectId, usage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Returns the count of the SavedSearches for the provided projectId.
     * @summary Returns the count of the SavedSearches for the provided projectId.
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchControllerApi
     */
    public getDashboardSavedSearchCounts(projectId: EntityId, options?: AxiosRequestConfig) {
        return SavedSearchControllerApiFp(this.configuration).getDashboardSavedSearchCounts(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Update a Saved Search record
     * @summary Update a Saved Search record
     * @param {EntityId} projectId the project ID
     * @param {number} id the id of the Saved Seach to be updated
     * @param {SavedSearchPojoPrototype} savedSearchPojoPrototype The savedSearch to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SavedSearchControllerApi
     */
    public updateSavedSearch(projectId: EntityId, id: number, savedSearchPojoPrototype: SavedSearchPojoPrototype, options?: AxiosRequestConfig) {
        return SavedSearchControllerApiFp(this.configuration).updateSavedSearch(projectId, id, savedSearchPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SemanticSearchControllerApi - axios parameter creator
 * @export
 */
export const SemanticSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  null
         * @param {EntityId} projectId the project ID
         * @param {string} query the search query, needs to be at least 5 characters long
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRag: async (projectId: EntityId, query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('searchRag', 'projectId', projectId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchRag', 'query', query)
            const localVarPath = `/api/v1/projects/{projectId}/semantic-search/search-rag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SemanticSearchControllerApi - functional programming interface
 * @export
 */
export const SemanticSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SemanticSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  null
         * @param {EntityId} projectId the project ID
         * @param {string} query the search query, needs to be at least 5 characters long
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchRag(projectId: EntityId, query: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SemanticSearchResultPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchRag(projectId, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SemanticSearchControllerApi - factory interface
 * @export
 */
export const SemanticSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SemanticSearchControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining  null
         * @param {EntityId} projectId the project ID
         * @param {string} query the search query, needs to be at least 5 characters long
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchRag(projectId: EntityId, query: string, options?: any): AxiosPromise<SemanticSearchResultPojo> {
            return localVarFp.searchRag(projectId, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SemanticSearchControllerApi - object-oriented interface
 * @export
 * @class SemanticSearchControllerApi
 * @extends {BaseAPI}
 */
export class SemanticSearchControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining  null
     * @param {EntityId} projectId the project ID
     * @param {string} query the search query, needs to be at least 5 characters long
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SemanticSearchControllerApi
     */
    public searchRag(projectId: EntityId, query: string, options?: AxiosRequestConfig) {
        return SemanticSearchControllerApiFp(this.configuration).searchRag(projectId, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatementControllerApi - axios parameter creator
 * @export
 */
export const StatementControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values over a number of statements
         * @summary Get aggregated values over a number of statements
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestStatementFieldName} aggregationRequestStatementFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementAggregatedValues: async (projectId: EntityId, aggregationRequestStatementFieldName: AggregationRequestStatementFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getStatementAggregatedValues', 'projectId', projectId)
            // verify required parameter 'aggregationRequestStatementFieldName' is not null or undefined
            assertParamExists('getStatementAggregatedValues', 'aggregationRequestStatementFieldName', aggregationRequestStatementFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/statements/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestStatementFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatementControllerApi - functional programming interface
 * @export
 */
export const StatementControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatementControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values over a number of statements
         * @summary Get aggregated values over a number of statements
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestStatementFieldName} aggregationRequestStatementFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatementAggregatedValues(projectId: EntityId, aggregationRequestStatementFieldName: AggregationRequestStatementFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultStatementFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatementAggregatedValues(projectId, aggregationRequestStatementFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatementControllerApi - factory interface
 * @export
 */
export const StatementControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatementControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values over a number of statements
         * @summary Get aggregated values over a number of statements
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestStatementFieldName} aggregationRequestStatementFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatementAggregatedValues(projectId: EntityId, aggregationRequestStatementFieldName: AggregationRequestStatementFieldName, options?: any): AxiosPromise<Array<AggregationResultStatementFieldName>> {
            return localVarFp.getStatementAggregatedValues(projectId, aggregationRequestStatementFieldName, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatementControllerApi - object-oriented interface
 * @export
 * @class StatementControllerApi
 * @extends {BaseAPI}
 */
export class StatementControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): mining,discovery  Get aggregated values over a number of statements
     * @summary Get aggregated values over a number of statements
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestStatementFieldName} aggregationRequestStatementFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatementControllerApi
     */
    public getStatementAggregatedValues(projectId: EntityId, aggregationRequestStatementFieldName: AggregationRequestStatementFieldName, options?: AxiosRequestConfig) {
        return StatementControllerApiFp(this.configuration).getStatementAggregatedValues(projectId, aggregationRequestStatementFieldName, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxonomyControllerApi - axios parameter creator
 * @export
 */
export const TaxonomyControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTaxonomiesToModules: async (projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('bulkUpdateTaxonomiesToModules', 'projectId', projectId)
            // verify required parameter 'taxonomyAssignmentsSetRequest' is not null or undefined
            assertParamExists('bulkUpdateTaxonomiesToModules', 'taxonomyAssignmentsSetRequest', taxonomyAssignmentsSetRequest)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/bulk-assignment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyAssignmentsSetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy
         * @summary Create a new taxonomy
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The taxonomy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxonomy: async (projectId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createTaxonomy', 'projectId', projectId)
            // verify required parameter 'taxonomyPojoPrototype' is not null or undefined
            assertParamExists('createTaxonomy', 'taxonomyPojoPrototype', taxonomyPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a taxonomy
         * @summary Delete a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the taxonomy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxonomy: async (projectId: EntityId, taxonomyId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteTaxonomy', 'projectId', projectId)
            // verify required parameter 'taxonomyId' is not null or undefined
            assertParamExists('deleteTaxonomy', 'taxonomyId', taxonomyId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/{taxonomyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"taxonomyId"}}`, encodeURIComponent(String(taxonomyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomies for one module
         * @summary Get all taxonomies for one module
         * @param {EntityId} projectId the project ID
         * @param {string} [type] restricts the type of the returned taxonomies
         * @param {Array<EntityId>} [countOnlyModulesWithTaxonomyId] includes only modules that have a certain taxonomy in the reference count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTaxonomies: async (projectId: EntityId, type?: string, countOnlyModulesWithTaxonomyId?: Array<EntityId>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllTaxonomies', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (countOnlyModulesWithTaxonomyId) {
                localVarQueryParameter['countOnlyModulesWithTaxonomyId'] = countOnlyModulesWithTaxonomyId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a taxonomy by ID
         * @summary Find a taxonomy by ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTaxonomyById: async (projectId: EntityId, taxonomyId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findTaxonomyById', 'projectId', projectId)
            // verify required parameter 'taxonomyId' is not null or undefined
            assertParamExists('findTaxonomyById', 'taxonomyId', taxonomyId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/{taxonomyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"taxonomyId"}}`, encodeURIComponent(String(taxonomyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of taxonomies
         * @summary Get aggregated values over a number of taxonomies
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestTaxonomyFieldName} aggregationRequestTaxonomyFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues: async (projectId: EntityId, aggregationRequestTaxonomyFieldName: AggregationRequestTaxonomyFieldName, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAggregatedValues', 'projectId', projectId)
            // verify required parameter 'aggregationRequestTaxonomyFieldName' is not null or undefined
            assertParamExists('getAggregatedValues', 'aggregationRequestTaxonomyFieldName', aggregationRequestTaxonomyFieldName)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/aggregations`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(aggregationRequestTaxonomyFieldName, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Retrieve assigned taxonomies to modules
         * @summary Retrieve assigned taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsGetRequest} taxonomyAssignmentsGetRequest The module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedTaxonomyByModule: async (projectId: EntityId, taxonomyAssignmentsGetRequest: TaxonomyAssignmentsGetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getAssignedTaxonomyByModule', 'projectId', projectId)
            // verify required parameter 'taxonomyAssignmentsGetRequest' is not null or undefined
            assertParamExists('getAssignedTaxonomyByModule', 'taxonomyAssignmentsGetRequest', taxonomyAssignmentsGetRequest)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/assignments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyAssignmentsGetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @summary Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlocValues: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getSlocValues', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/aggregations/sloc-by-type`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets all taxonomies for one project
         * @summary Gets all taxonomies for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxonomyReport: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('getTaxonomyReport', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/reports`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyTechnicalTaxonomies: async (projectId: EntityId, moduleMatcher: ModuleMatcher, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('identifyTechnicalTaxonomies', 'projectId', projectId)
            // verify required parameter 'moduleMatcher' is not null or undefined
            assertParamExists('identifyTechnicalTaxonomies', 'moduleMatcher', moduleMatcher)
            const localVarPath = `/api/v1/projects/{projectId}/identify-technical-taxonomies`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(moduleMatcher, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Import the taxonomy assignments from csv file.
         * @summary Import the taxonomy assignments from csv file.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTaxonomy: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('importTaxonomy', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('importTaxonomy', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/import`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Assign taxonomies to modules
         * @summary Assign taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssignedTaxonomyByModule: async (projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateAssignedTaxonomyByModule', 'projectId', projectId)
            // verify required parameter 'taxonomyAssignmentsSetRequest' is not null or undefined
            assertParamExists('updateAssignedTaxonomyByModule', 'taxonomyAssignmentsSetRequest', taxonomyAssignmentsSetRequest)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/assignments`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyAssignmentsSetRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy
         * @summary Update a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID of the taxonomy to update
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxonomy: async (projectId: EntityId, taxonomyId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateTaxonomy', 'projectId', projectId)
            // verify required parameter 'taxonomyId' is not null or undefined
            assertParamExists('updateTaxonomy', 'taxonomyId', taxonomyId)
            // verify required parameter 'taxonomyPojoPrototype' is not null or undefined
            assertParamExists('updateTaxonomy', 'taxonomyPojoPrototype', taxonomyPojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/{taxonomyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"taxonomyId"}}`, encodeURIComponent(String(taxonomyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyPojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  null
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateImportTaxonomy: async (projectId: EntityId, file: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('validateImportTaxonomy', 'projectId', projectId)
            // verify required parameter 'file' is not null or undefined
            assertParamExists('validateImportTaxonomy', 'file', file)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomies/import/validate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxonomyControllerApi - functional programming interface
 * @export
 */
export const TaxonomyControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxonomyControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async bulkUpdateTaxonomiesToModules(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.bulkUpdateTaxonomiesToModules(projectId, taxonomyAssignmentsSetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy
         * @summary Create a new taxonomy
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The taxonomy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaxonomy(projectId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaxonomy(projectId, taxonomyPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a taxonomy
         * @summary Delete a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the taxonomy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxonomy(projectId: EntityId, taxonomyId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxonomy(projectId, taxonomyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomies for one module
         * @summary Get all taxonomies for one module
         * @param {EntityId} projectId the project ID
         * @param {string} [type] restricts the type of the returned taxonomies
         * @param {Array<EntityId>} [countOnlyModulesWithTaxonomyId] includes only modules that have a certain taxonomy in the reference count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTaxonomies(projectId: EntityId, type?: string, countOnlyModulesWithTaxonomyId?: Array<EntityId>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaxonomyPojo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTaxonomies(projectId, type, countOnlyModulesWithTaxonomyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a taxonomy by ID
         * @summary Find a taxonomy by ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findTaxonomyById(projectId: EntityId, taxonomyId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findTaxonomyById(projectId, taxonomyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of taxonomies
         * @summary Get aggregated values over a number of taxonomies
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestTaxonomyFieldName} aggregationRequestTaxonomyFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAggregatedValues(projectId: EntityId, aggregationRequestTaxonomyFieldName: AggregationRequestTaxonomyFieldName, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AggregationResultTaxonomyFieldName>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAggregatedValues(projectId, aggregationRequestTaxonomyFieldName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Retrieve assigned taxonomies to modules
         * @summary Retrieve assigned taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsGetRequest} taxonomyAssignmentsGetRequest The module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsGetRequest: TaxonomyAssignmentsGetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyAssignmentsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAssignedTaxonomyByModule(projectId, taxonomyAssignmentsGetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @summary Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSlocValues(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSlocValues(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets all taxonomies for one project
         * @summary Gets all taxonomies for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTaxonomyReport(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TaxonomyReport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTaxonomyReport(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async identifyTechnicalTaxonomies(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.identifyTechnicalTaxonomies(projectId, moduleMatcher, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Import the taxonomy assignments from csv file.
         * @summary Import the taxonomy assignments from csv file.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importTaxonomy(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importTaxonomy(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Assign taxonomies to modules
         * @summary Assign taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAssignedTaxonomyByModule(projectId, taxonomyAssignmentsSetRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy
         * @summary Update a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID of the taxonomy to update
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaxonomy(projectId: EntityId, taxonomyId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyPojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaxonomy(projectId, taxonomyId, taxonomyPojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  null
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateImportTaxonomy(projectId: EntityId, file: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateImportTaxonomy(projectId, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxonomyControllerApi - factory interface
 * @export
 */
export const TaxonomyControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxonomyControllerApiFp(configuration)
    return {
        /**
         * User Role(s): editor | Project Nature(s): mining  Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bulkUpdateTaxonomiesToModules(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.bulkUpdateTaxonomiesToModules(projectId, taxonomyAssignmentsSetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy
         * @summary Create a new taxonomy
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The taxonomy to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxonomy(projectId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: any): AxiosPromise<TaxonomyPojo> {
            return localVarFp.createTaxonomy(projectId, taxonomyPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Delete a taxonomy
         * @summary Delete a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the taxonomy ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxonomy(projectId: EntityId, taxonomyId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTaxonomy(projectId, taxonomyId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomies for one module
         * @summary Get all taxonomies for one module
         * @param {EntityId} projectId the project ID
         * @param {string} [type] restricts the type of the returned taxonomies
         * @param {Array<EntityId>} [countOnlyModulesWithTaxonomyId] includes only modules that have a certain taxonomy in the reference count
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTaxonomies(projectId: EntityId, type?: string, countOnlyModulesWithTaxonomyId?: Array<EntityId>, options?: any): AxiosPromise<Array<TaxonomyPojo>> {
            return localVarFp.findAllTaxonomies(projectId, type, countOnlyModulesWithTaxonomyId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Find a taxonomy by ID
         * @summary Find a taxonomy by ID
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findTaxonomyById(projectId: EntityId, taxonomyId: EntityId, options?: any): AxiosPromise<TaxonomyPojo> {
            return localVarFp.findTaxonomyById(projectId, taxonomyId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of taxonomies
         * @summary Get aggregated values over a number of taxonomies
         * @param {EntityId} projectId the ID of the project
         * @param {AggregationRequestTaxonomyFieldName} aggregationRequestTaxonomyFieldName The aggregation request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAggregatedValues(projectId: EntityId, aggregationRequestTaxonomyFieldName: AggregationRequestTaxonomyFieldName, options?: any): AxiosPromise<Array<AggregationResultTaxonomyFieldName>> {
            return localVarFp.getAggregatedValues(projectId, aggregationRequestTaxonomyFieldName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Retrieve assigned taxonomies to modules
         * @summary Retrieve assigned taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsGetRequest} taxonomyAssignmentsGetRequest The module IDs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsGetRequest: TaxonomyAssignmentsGetRequest, options?: any): AxiosPromise<TaxonomyAssignmentsGetResponse> {
            return localVarFp.getAssignedTaxonomyByModule(projectId, taxonomyAssignmentsGetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @summary Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
         * @param {EntityId} projectId the ID of the project
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSlocValues(projectId: EntityId, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getSlocValues(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Gets all taxonomies for one project
         * @summary Gets all taxonomies for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxonomyReport(projectId: EntityId, options?: any): AxiosPromise<Array<TaxonomyReport>> {
            return localVarFp.getTaxonomyReport(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @summary Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
         * @param {EntityId} projectId the ID of the project
         * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; {1}, {src/file.cbl}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        identifyTechnicalTaxonomies(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.identifyTechnicalTaxonomies(projectId, moduleMatcher, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Import the taxonomy assignments from csv file.
         * @summary Import the taxonomy assignments from csv file.
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importTaxonomy(projectId: EntityId, file: File, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.importTaxonomy(projectId, file, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  Assign taxonomies to modules
         * @summary Assign taxonomies to modules
         * @param {EntityId} projectId the ID of the project
         * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updateAssignedTaxonomyByModule(projectId, taxonomyAssignmentsSetRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy
         * @summary Update a taxonomy
         * @param {EntityId} projectId the project ID
         * @param {EntityId} taxonomyId the ID of the taxonomy to update
         * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxonomy(projectId: EntityId, taxonomyId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: any): AxiosPromise<TaxonomyPojo> {
            return localVarFp.updateTaxonomy(projectId, taxonomyId, taxonomyPojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): editor | Project Nature(s): mining  null
         * @param {EntityId} projectId the ID of the project
         * @param {File} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateImportTaxonomy(projectId: EntityId, file: File, options?: any): AxiosPromise<object> {
            return localVarFp.validateImportTaxonomy(projectId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxonomyControllerApi - object-oriented interface
 * @export
 * @class TaxonomyControllerApi
 * @extends {BaseAPI}
 */
export class TaxonomyControllerApi extends BaseAPI {
    /**
     * User Role(s): editor | Project Nature(s): mining  Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that Assign taxonomies to given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public bulkUpdateTaxonomiesToModules(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).bulkUpdateTaxonomiesToModules(projectId, taxonomyAssignmentsSetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy
     * @summary Create a new taxonomy
     * @param {EntityId} projectId the project ID
     * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The taxonomy to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public createTaxonomy(projectId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).createTaxonomy(projectId, taxonomyPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Delete a taxonomy
     * @summary Delete a taxonomy
     * @param {EntityId} projectId the project ID
     * @param {EntityId} taxonomyId the taxonomy ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public deleteTaxonomy(projectId: EntityId, taxonomyId: EntityId, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).deleteTaxonomy(projectId, taxonomyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all taxonomies for one module
     * @summary Get all taxonomies for one module
     * @param {EntityId} projectId the project ID
     * @param {string} [type] restricts the type of the returned taxonomies
     * @param {Array<EntityId>} [countOnlyModulesWithTaxonomyId] includes only modules that have a certain taxonomy in the reference count
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public findAllTaxonomies(projectId: EntityId, type?: string, countOnlyModulesWithTaxonomyId?: Array<EntityId>, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).findAllTaxonomies(projectId, type, countOnlyModulesWithTaxonomyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Find a taxonomy by ID
     * @summary Find a taxonomy by ID
     * @param {EntityId} projectId the project ID
     * @param {EntityId} taxonomyId the ID to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public findTaxonomyById(projectId: EntityId, taxonomyId: EntityId, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).findTaxonomyById(projectId, taxonomyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get aggregated values over a number of taxonomies
     * @summary Get aggregated values over a number of taxonomies
     * @param {EntityId} projectId the ID of the project
     * @param {AggregationRequestTaxonomyFieldName} aggregationRequestTaxonomyFieldName The aggregation request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public getAggregatedValues(projectId: EntityId, aggregationRequestTaxonomyFieldName: AggregationRequestTaxonomyFieldName, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).getAggregatedValues(projectId, aggregationRequestTaxonomyFieldName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Retrieve assigned taxonomies to modules
     * @summary Retrieve assigned taxonomies to modules
     * @param {EntityId} projectId the ID of the project
     * @param {TaxonomyAssignmentsGetRequest} taxonomyAssignmentsGetRequest The module IDs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public getAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsGetRequest: TaxonomyAssignmentsGetRequest, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).getAssignedTaxonomyByModule(projectId, taxonomyAssignmentsGetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
     * @summary Get map contains the Taxonomy type names and sum of SLOC of all Modules that have a Taxonomy of that type assigned.
     * @param {EntityId} projectId the ID of the project
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public getSlocValues(projectId: EntityId, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).getSlocValues(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Gets all taxonomies for one project
     * @summary Gets all taxonomies for one project
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public getTaxonomyReport(projectId: EntityId, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).getTaxonomyReport(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @summary Starts a job that identifies Technical Taxonomies for the given modules and returns the job Id. See the job status at \'/v1/jobs/{jobId}/info\'
     * @param {EntityId} projectId the ID of the project
     * @param {ModuleMatcher} moduleMatcher List of id\&#39;s and/or the file paths of the modules to identify the candidates for example &#x3D; {1}, {src/file.cbl}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public identifyTechnicalTaxonomies(projectId: EntityId, moduleMatcher: ModuleMatcher, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).identifyTechnicalTaxonomies(projectId, moduleMatcher, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Import the taxonomy assignments from csv file.
     * @summary Import the taxonomy assignments from csv file.
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public importTaxonomy(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).importTaxonomy(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  Assign taxonomies to modules
     * @summary Assign taxonomies to modules
     * @param {EntityId} projectId the ID of the project
     * @param {TaxonomyAssignmentsSetRequest} taxonomyAssignmentsSetRequest Module IDs along with Taxonomies ID and states
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public updateAssignedTaxonomyByModule(projectId: EntityId, taxonomyAssignmentsSetRequest: TaxonomyAssignmentsSetRequest, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).updateAssignedTaxonomyByModule(projectId, taxonomyAssignmentsSetRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Update a taxonomy
     * @summary Update a taxonomy
     * @param {EntityId} projectId the project ID
     * @param {EntityId} taxonomyId the ID of the taxonomy to update
     * @param {TaxonomyPojoPrototype} taxonomyPojoPrototype The updated taxonomy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public updateTaxonomy(projectId: EntityId, taxonomyId: EntityId, taxonomyPojoPrototype: TaxonomyPojoPrototype, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).updateTaxonomy(projectId, taxonomyId, taxonomyPojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): editor | Project Nature(s): mining  null
     * @param {EntityId} projectId the ID of the project
     * @param {File} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyControllerApi
     */
    public validateImportTaxonomy(projectId: EntityId, file: File, options?: AxiosRequestConfig) {
        return TaxonomyControllerApiFp(this.configuration).validateImportTaxonomy(projectId, file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TaxonomyTypeControllerApi - axios parameter creator
 * @export
 */
export const TaxonomyTypeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy type
         * @summary Create a new taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The taxonomy type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxonomyType: async (projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('createTaxonomyType', 'projectId', projectId)
            // verify required parameter 'taxonomyTypePojoPrototype' is not null or undefined
            assertParamExists('createTaxonomyType', 'taxonomyTypePojoPrototype', taxonomyTypePojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomy-types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyTypePojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} taxonomyTypeName the taxonomy type name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxonomyType: async (projectId: EntityId, taxonomyTypeName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('deleteTaxonomyType', 'projectId', projectId)
            // verify required parameter 'taxonomyTypeName' is not null or undefined
            assertParamExists('deleteTaxonomyType', 'taxonomyTypeName', taxonomyTypeName)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomy-types/{taxonomyTypeName}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"taxonomyTypeName"}}`, encodeURIComponent(String(taxonomyTypeName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomy types for one project
         * @summary Get all taxonomy types for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTaxonomyTypes: async (projectId: EntityId, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('findAllTaxonomyTypes', 'projectId', projectId)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomy-types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy type
         * @summary Update a taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxonomyType: async (projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('updateTaxonomyType', 'projectId', projectId)
            // verify required parameter 'taxonomyTypePojoPrototype' is not null or undefined
            assertParamExists('updateTaxonomyType', 'taxonomyTypePojoPrototype', taxonomyTypePojoPrototype)
            const localVarPath = `/api/v1/projects/{projectId}/taxonomy-types`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(taxonomyTypePojoPrototype, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxonomyTypeControllerApi - functional programming interface
 * @export
 */
export const TaxonomyTypeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TaxonomyTypeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy type
         * @summary Create a new taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The taxonomy type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyTypePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createTaxonomyType(projectId, taxonomyTypePojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} taxonomyTypeName the taxonomy type name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTaxonomyType(projectId: EntityId, taxonomyTypeName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTaxonomyType(projectId, taxonomyTypeName, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomy types for one project
         * @summary Get all taxonomy types for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAllTaxonomyTypes(projectId: EntityId, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAllTaxonomyTypes(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy type
         * @summary Update a taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TaxonomyTypePojo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateTaxonomyType(projectId, taxonomyTypePojoPrototype, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TaxonomyTypeControllerApi - factory interface
 * @export
 */
export const TaxonomyTypeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TaxonomyTypeControllerApiFp(configuration)
    return {
        /**
         * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy type
         * @summary Create a new taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The taxonomy type to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: any): AxiosPromise<TaxonomyTypePojo> {
            return localVarFp.createTaxonomyType(projectId, taxonomyTypePojoPrototype, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @summary Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
         * @param {EntityId} projectId the project ID
         * @param {string} taxonomyTypeName the taxonomy type name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxonomyType(projectId: EntityId, taxonomyTypeName: string, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.deleteTaxonomyType(projectId, taxonomyTypeName, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): viewer | Project Nature(s): mining  Get all taxonomy types for one project
         * @summary Get all taxonomy types for one project
         * @param {EntityId} projectId the project ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAllTaxonomyTypes(projectId: EntityId, options?: any): AxiosPromise<void> {
            return localVarFp.findAllTaxonomyTypes(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * User Role(s): manager | Project Nature(s): mining  Update a taxonomy type
         * @summary Update a taxonomy type
         * @param {EntityId} projectId the project ID
         * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The updated taxonomy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: any): AxiosPromise<TaxonomyTypePojo> {
            return localVarFp.updateTaxonomyType(projectId, taxonomyTypePojoPrototype, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TaxonomyTypeControllerApi - object-oriented interface
 * @export
 * @class TaxonomyTypeControllerApi
 * @extends {BaseAPI}
 */
export class TaxonomyTypeControllerApi extends BaseAPI {
    /**
     * User Role(s): manager | Project Nature(s): mining  Create a new taxonomy type
     * @summary Create a new taxonomy type
     * @param {EntityId} projectId the project ID
     * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The taxonomy type to create
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyTypeControllerApi
     */
    public createTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: AxiosRequestConfig) {
        return TaxonomyTypeControllerApiFp(this.configuration).createTaxonomyType(projectId, taxonomyTypePojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
     * @summary Starts a job that deletes a taxonomy type along with taxonomies for the given the taxonomy type name and returns the job Id.See the job status at \'/v1/jobs/{jobId}/info
     * @param {EntityId} projectId the project ID
     * @param {string} taxonomyTypeName the taxonomy type name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyTypeControllerApi
     */
    public deleteTaxonomyType(projectId: EntityId, taxonomyTypeName: string, options?: AxiosRequestConfig) {
        return TaxonomyTypeControllerApiFp(this.configuration).deleteTaxonomyType(projectId, taxonomyTypeName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): viewer | Project Nature(s): mining  Get all taxonomy types for one project
     * @summary Get all taxonomy types for one project
     * @param {EntityId} projectId the project ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyTypeControllerApi
     */
    public findAllTaxonomyTypes(projectId: EntityId, options?: AxiosRequestConfig) {
        return TaxonomyTypeControllerApiFp(this.configuration).findAllTaxonomyTypes(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * User Role(s): manager | Project Nature(s): mining  Update a taxonomy type
     * @summary Update a taxonomy type
     * @param {EntityId} projectId the project ID
     * @param {TaxonomyTypePojoPrototype} taxonomyTypePojoPrototype The updated taxonomy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxonomyTypeControllerApi
     */
    public updateTaxonomyType(projectId: EntityId, taxonomyTypePojoPrototype: TaxonomyTypePojoPrototype, options?: AxiosRequestConfig) {
        return TaxonomyTypeControllerApiFp(this.configuration).updateTaxonomyType(projectId, taxonomyTypePojoPrototype, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UniversalSearchControllerApi - axios parameter creator
 * @export
 */
export const UniversalSearchControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Searches in the entire project
         * @summary Searches in the entire project
         * @param {EntityId} projectId the project ID
         * @param {string} query the term to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchQueryInProject: async (projectId: EntityId, query: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('searchQueryInProject', 'projectId', projectId)
            // verify required parameter 'query' is not null or undefined
            assertParamExists('searchQueryInProject', 'query', query)
            const localVarPath = `/api/v1/projects/{projectId}/universal-search`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UniversalSearchControllerApi - functional programming interface
 * @export
 */
export const UniversalSearchControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UniversalSearchControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Searches in the entire project
         * @summary Searches in the entire project
         * @param {EntityId} projectId the project ID
         * @param {string} query the term to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchQueryInProject(projectId: EntityId, query: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UniversalSearchResult>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchQueryInProject(projectId, query, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UniversalSearchControllerApi - factory interface
 * @export
 */
export const UniversalSearchControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UniversalSearchControllerApiFp(configuration)
    return {
        /**
         * User Role(s): viewer | Project Nature(s): discovery,mining  Searches in the entire project
         * @summary Searches in the entire project
         * @param {EntityId} projectId the project ID
         * @param {string} query the term to be searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchQueryInProject(projectId: EntityId, query: string, options?: any): AxiosPromise<Array<UniversalSearchResult>> {
            return localVarFp.searchQueryInProject(projectId, query, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UniversalSearchControllerApi - object-oriented interface
 * @export
 * @class UniversalSearchControllerApi
 * @extends {BaseAPI}
 */
export class UniversalSearchControllerApi extends BaseAPI {
    /**
     * User Role(s): viewer | Project Nature(s): discovery,mining  Searches in the entire project
     * @summary Searches in the entire project
     * @param {EntityId} projectId the project ID
     * @param {string} query the term to be searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UniversalSearchControllerApi
     */
    public searchQueryInProject(projectId: EntityId, query: string, options?: AxiosRequestConfig) {
        return UniversalSearchControllerApiFp(this.configuration).searchQueryInProject(projectId, query, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VersionControllerApi - axios parameter creator
 * @export
 */
export const VersionControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The returned map contains the key \'version\' describing the api server version.
         * @summary API server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/version`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            await setApiKeyToObject(localVarQueryParameter, "access_token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionControllerApi - functional programming interface
 * @export
 */
export const VersionControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * The returned map contains the key \'version\' describing the api server version.
         * @summary API server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVersion(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: string; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVersion(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VersionControllerApi - factory interface
 * @export
 */
export const VersionControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionControllerApiFp(configuration)
    return {
        /**
         * The returned map contains the key \'version\' describing the api server version.
         * @summary API server version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVersion(options?: any): AxiosPromise<{ [key: string]: string; }> {
            return localVarFp.getVersion(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionControllerApi - object-oriented interface
 * @export
 * @class VersionControllerApi
 * @extends {BaseAPI}
 */
export class VersionControllerApi extends BaseAPI {
    /**
     * The returned map contains the key \'version\' describing the api server version.
     * @summary API server version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionControllerApi
     */
    public getVersion(options?: AxiosRequestConfig) {
        return VersionControllerApiFp(this.configuration).getVersion(options).then((request) => request(this.axios, this.basePath));
    }
}


