/*
 * Copyright (c) 2024 innoWake gmbh Germany. All rights reserved.
 */
package innowake.mining.server.service;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import org.apache.commons.collections4.map.HashedMap;
import org.apache.commons.lang3.ArrayUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.innowake.innovationlab.commons.model.Column;
import com.innowake.innovationlab.commons.model.Index;
import com.innowake.innovationlab.commons.model.LegacyDatabase;
import com.innowake.innovationlab.commons.model.Routine;
import com.innowake.innovationlab.commons.model.Schema;
import com.innowake.innovationlab.commons.model.Table;
import com.innowake.innovationlab.commons.model.Trigger;
import com.innowake.innovationlab.commons.model.View;
import com.innowake.innovationlab.commons.model.ViewColumn;

import innowake.mining.shared.access.FieldInfoService;
import innowake.mining.shared.access.EntityId;
import innowake.mining.shared.access.ModuleService;
import innowake.mining.shared.entities.FieldInfoPojoPrototype;
import innowake.mining.shared.entities.ModulePojo;
import innowake.mining.shared.entities.ModulePojoPrototype;
import innowake.mining.shared.entities.ModuleRelationshipPojoPrototype;
import innowake.mining.shared.model.Creator;
import innowake.mining.shared.model.Identification;
import innowake.mining.shared.model.Origin;
import innowake.mining.shared.model.RelationshipType;
import innowake.mining.shared.model.Storage;
import innowake.mining.shared.model.Technology;
import innowake.mining.shared.model.Type;

/**
 * Service for importing database schemas.
 */
@Service
public class DataSchemaImportService {

	private final ModuleService moduleService;
	private final FieldInfoService fieldInfoService;

	public DataSchemaImportService(@Autowired final ModuleService moduleService, @Autowired final FieldInfoService fieldInfoService) {
		this.moduleService = moduleService;
		this.fieldInfoService = fieldInfoService;
	}

	/**
	 * Imports the database schemas as generated by DB Crawler.
	 * 
	 * @param projectId ID of the project to import into.
	 * @param dbData Database schema information to import.
	 */
	public void importSchema(final EntityId projectId, final LegacyDatabase dbData) {
		/* process each schema */
		for (final Schema schema : dbData.getSchemes()) {
			deleteSchema(projectId, schema.getName());
			final var schemaModule = prepareModule(projectId, schema.getName(), Type.SCHEMA, Collections.emptyMap());
			final EntityId schemaId = moduleService.create(schemaModule);
			
			/* maps names of imported tables to record IDs for reference edge generation */
			final Map<String, EntityId> tableIds = new HashedMap<>();
			/* collects sets of referenced tables of imported tables/views by record ID,
			 * this is for generating reference edges independent of import order */ 
			final Map<EntityId, Set<String>> tableReferences = new HashMap<>();
			
			/* process tables */
			for (final Table table : schema.getTables()) {
				final var tableModule = prepareModule(projectId, table.getName(), Type.TABLE, Collections.emptyMap());
				final EntityId tableId = moduleService.create(tableModule.setParent(schemaId));
				insertContains(schemaId, tableId);
				tableIds.put(table.getName(), tableId);
				
				final Map<String, String> foreignKeys = new HashedMap<>();
				table.getForeignKeys().forEach(fk -> fk.getColumnReferences().forEach(r -> foreignKeys.put(r.getForeignKey(), r.getPrimaryKey())));
				
				/* process columns of the table */
				int nColumn = 1;
				for (final Column column : table.getColumns()) {
					final Map<String, Object> properties = new HashMap<>();
					final FieldInfoPojoPrototype field = new FieldInfoPojoPrototype()
																		.setOrdinal(nColumn)
																		.setName(column.getName())
																		.setProperties(properties);
					properties.put("type", column.getDataType());
					properties.put("default", column.getDefaultValue());
					properties.put("size", String.valueOf(column.getSize()));
					if (column.isAutoIncremented()) {
						properties.put("autoIncrement", "");
					}
					final String foreignRef = foreignKeys.get(column.getName());
					if (foreignRef != null) {
						field.setReference(foreignRef);
						final String[] refPath = foreignRef.split("\\.");
						if (refPath.length > 1) {
							tableReferences.computeIfAbsent(tableId, k -> new HashSet<>()).add(refPath[refPath.length - 2]);
						}
					}
					if (table.getPrimaryKey() != null) {
						final int keyIdx = table.getPrimaryKey().getColumns().indexOf(column.getName());
						if (keyIdx >= 0) {
							properties.put("primaryKey", String.valueOf(keyIdx + 1));
						}
					}
					insertFieldInfo(tableId, field);
					nColumn++;
				}
				
				/* process indices of the table */
				for (final Index index : table.getIndices()) {
					final var indexModule = prepareModule(projectId, index.getName(), Type.INDEX, Collections.emptyMap());
					final EntityId indexId = moduleService.create(indexModule);
					insertContains(tableId, indexId);
					
					int nIndexColumn = 1;
					for (final String column : index.getColumns()) {
						insertFieldInfo(indexId, new FieldInfoPojoPrototype()
														.setOrdinal(nIndexColumn)
														.setName(column)
														.setReference(column));
						nIndexColumn++;
					}
				}
			}
			
			/* process views */
			for (final View view : schema.getViews()) {
				final var viewModule = prepareModule(projectId, view.getName(), Type.VIEW, Collections.emptyMap());
				final EntityId viewId = moduleService.create(viewModule);
				insertContains(schemaId, viewId);
				tableIds.put(view.getName(), viewId);
				
				/* process columns of the view */
				int nColumn = 1;
				for (final ViewColumn column : view.getViewColumns()) {
					if (column != null) {
						final FieldInfoPojoPrototype field = new FieldInfoPojoPrototype()
																	.setOrdinal(nColumn)
																	.setName(column.getName());
						final String targetColumn = column.getTargetColumn();
						field.setReference(targetColumn);
						final String[] refPath = targetColumn != null ? targetColumn.split("\\.") : ArrayUtils.EMPTY_STRING_ARRAY;
						if (refPath.length > 1) {
							tableReferences.computeIfAbsent(viewId, k -> new HashSet<>()).add(refPath[refPath.length - 2]);
						}
						insertFieldInfo(viewId, field);
						nColumn++;
					}
				}
			}
			
			/* establish relations between tables and views */
			for (final Map.Entry<EntityId, Set<String>> ref : tableReferences.entrySet()) {
				for (final String refTable : ref.getValue()) {
					final EntityId refTableId = tableIds.get(refTable);
					if (refTableId != null) {
						final var reference = new ModuleRelationshipPojoPrototype()
								.setRelationship(RelationshipType.REFERENCES)
								.setSrcModule(ref.getKey())
								.setDstModule(refTableId);
						moduleService.createRelationship(reference);
					}
				}
			}
			
			/* process triggers */
			for (final Trigger trigger : schema.getTriggers()) {
				final String[] tablePath = trigger.getTableName().split("\\.");
				final var tableId = tableIds.get(tablePath[tablePath.length - 1]);
				if (tableId != null) {
					final Map<String, Object> info = new HashMap<>(2);
					info.put("event", trigger.getEventName());
					info.put("timing", trigger.getEventTiming());

					final ModulePojoPrototype triggerMod = prepareModule(projectId, trigger.getName(), Type.TRIGGER, info);
					triggerMod.setContent(trigger.getStatement());
					final var triggerId = moduleService.create(triggerMod);
					insertContains(tableId, triggerId);
				}
			}
			
			/* process procedures */
			for (final Routine proc : schema.getRoutines()) {
				final Map<String, Object> info = new HashMap<>(2);
				info.put("type", proc.getType().name());
				info.put("language", proc.getBodyType().name()); 
				final ModulePojoPrototype procMod = prepareModule(projectId, proc.getName(), Type.STORED_PROCEDURE, info);
				procMod.setContent(proc.getDefinition());
				final var procId = moduleService.create(procMod);
				insertContains(schemaId, procId);
				
				/* process parameters of the procedure */
				int nParam = 1;
				for (final String param : proc.getParameters()) {
					final FieldInfoPojoPrototype field = new FieldInfoPojoPrototype()
							.setOrdinal(nParam)
							.setName(param);
					insertFieldInfo(procId, field);
					nParam++;
				}
			}
		}
	}

	/**
	 * Deletes a schema and all its contained modules.
	 * 
	 * @param projectId ID of the Project containing the schema.
	 * @param name Name of the Schema Module to delete.
	 */
	public void deleteSchema(final EntityId projectId, final String name) {
		for (final ModulePojo modSchema : moduleService.findModules(b -> b.ofProject(projectId)
																			.withName(name)
																			.withType(Type.SCHEMA))) {
			moduleService.deleteModules(b -> b.ofProject(projectId)
												.withSourceRelationshipsFrom(modSchema.identity(), RelationshipType.CONTAINS));
			moduleService.deleteModules(b -> b.ofProject(projectId)
												.byUid(modSchema.getUid()));
		}
	}

	private ModulePojoPrototype prepareModule(final EntityId projectId, final String name, final Type type, final Map<String, Object> info) {
		final var module = new ModulePojoPrototype();
		module.setProject(projectId);
		module.setName(name);
		module.setTechnology(Technology.SQL);
		module.setType(type);
		module.setOrigin(Origin.CUSTOM);
		module.setStorage(Storage.DATABASE);
		module.setIdentification(Identification.IDENTIFIED);
		module.setCreator(Creator.API);
		module.setInfo(info);
		return module;
	}

	private void insertContains(final EntityId parent, final EntityId contained) {
		moduleService.createRelationship(new ModuleRelationshipPojoPrototype()
											.setSrcModule(parent)
											.setDstModule(contained)
											.setRelationship(RelationshipType.CONTAINS));
	}

	private void insertFieldInfo(final EntityId moduleId, final FieldInfoPojoPrototype info) {
		info.setModule(moduleId);
		fieldInfoService.create(info);
	}
}
