/* Copyright (c) 2020 innoWake gmbh Germany. All rights reserved. */
package innowake.mining.keycloak;

import static org.apache.http.HttpStatus.SC_CREATED;
import static org.apache.http.HttpStatus.SC_NO_CONTENT;
import static org.apache.http.HttpStatus.SC_OK;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.net.URLConnection;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.UUID;
import java.util.stream.Collectors;
import org.apache.commons.collections4.CollectionUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.keycloak.representations.idm.CredentialRepresentation;
import org.keycloak.representations.idm.RealmRepresentation;
import org.keycloak.representations.idm.RoleRepresentation;
import org.keycloak.representations.idm.UserRepresentation;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import innowake.mining.keycloak.model.AccessInformation;
import innowake.mining.keycloak.model.HttpMethod;
import innowake.mining.keycloak.model.Member;
import innowake.mining.keycloak.model.PaginatedResponse;
import innowake.mining.keycloak.model.ProjectNature;
import innowake.mining.keycloak.model.ProjectRole;
import innowake.mining.keycloak.model.UserRole;

/**
 * Abstract Test class to aid in testing the extended Keycloak Endpoints.</br>
 * This class is responsible for creating and setting up the realm before each test case.</br>
 * This test realm can then be used for testing the endpoints.</br>
 * The class also provides a few methods that can aid in testing these endpoints,
 * such as providing the access token for a user.</br></br>
 * 
 * Before the tests run a check is made whether there is already a Keycloak instance running on port 8180. </br>
 * If not a new Keycloak instance will be set up automatically using the Testcontainers library. </br>
 * If yes the already running keycloak instance is used for the tests. </br>
 * For this to work the keycloak instance MUST be configured the following way before runnning any test: </br>
 * The project needs to be deployed in the Keycloak instance. </br>
 * It is also MANDATORY to create a <i>"Confidential"</i> Client in the <i>"master"</i> Realm.</br>
 * The name of this client should be as specified in the below REALM_CREATOR_CLIENT variable.</br>
 * To do this, navigate to "master" realm and create a new client named "realm-creator".</br>
 * In the Access Type, please select <i>"Confidential"</i> and please enable the following properties:</br>
 * 		<li>Service Accounts Enabled</li>
 * 		<li>Authorization Enabled</li>
 * </br>Now, navigate to the <i>"Service Account Roles"</i> tab and assign the <i>"create-realm"</i> role to this client.
 * </br>
 * Also, please set the System property realm_creator_client_secret with the value that was generated by Keycloak.</br>
 * You can do this by adding -Drealm_creator_client_secret="client secret" to the VM arguments in your eclipse run configuration.</br>
 * The value can be found by clicking on the client's Credentials tab.</br>
 */

public abstract class AbstractTest {

	/**
	 * System property to enable or disable integration tests that extend the {@link AbstractTest} class.
	 * <p>All integration tests are skipped if the value is '{@code true}':</p>
	 * <pre>
	 * VM arguments: -Dinnowake.integration.tests.skip=true
	 * <pre>
	 */
	/* If you change or remove this system property then adjust the mining-api-server/pom.xml */
	public static final String SYSTEM_PROPERTY_SKIP_INTEGRATION_TESTS = "innowake.integration.tests.skip";

	protected static final String SPI_ID = "admin";
	protected static final String PASSWORD = "password";

	protected static final Integer ONE = Integer.valueOf(1);
	protected static final Integer TWO = Integer.valueOf(2);
	protected static final Integer THREE = Integer.valueOf(3);
	protected static final Integer GROUP_COUNT = Integer.valueOf(2);
	protected static final ObjectMapper MAPPER = new ObjectMapper();
	protected static final int PAGE_SIZE = 2;
	protected static final int PROJECT_ROLE_COUNT = 7;
	protected static final int CLIENT_ONE_MEMBER_COUNT = 7;
	protected static final int PROJECT_ONE_MEMBER_COUNT = 3;
	protected static final int CLIENT_ONE_ADMIN_COUNT = 1;
	protected static final int PROJECT_ONE_NATURES_COUNT = 1;
	protected static final int PROJECT_TWO_NATURES_COUNT = 2;
	protected static final int PROJECT_THREE_NATURES_COUNT = 3;
	protected static String AUTH_SERVER_URL;
	protected static String BASE_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s";
	protected static String CLIENTS_WITH_ID_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d";
	protected static String CLIENT_MEMBERS_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/members";
	protected static String PROJECT_WITH_ID_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/projects/%d";
	protected static String PROJECT_MEMBERS_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/projects/%d/members";
	protected static String MEMBER_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/users/%s";

	protected String testRealmName;

	/*
	 * Please replace the values for these variables with the credentials that you use in your local instance
	 * to access the Admin Console. (If you're using a local instance)
	 */
	private static final String ADMIN_USERNAME = "admin";
	private static final String ADMIN_PASSWORD = "Worx2000";
	private static final String USERS_JSON = "users.json";
	private static final String REALM_CREATION_JSON = "test-realm-export.json";
	private static String realmJson;
	private static Map<String, UserRepresentation> usersMap;

	private static final String REALM_CREATOR_CLIENT = "realm-creator";
	/* Please set the below system property with the one mentioned in the local Keycloak instance (if you're using a local instance) */
	private static final String REALM_CREATOR_CLIENT_SECRET = System.getProperty("realmCreatorClientSecret", "110b5a99-37c0-4780-84f5-dcef5b1dac4e");



	/**
	 * Method to load the Realm JSON, the User-Role Mappings JSON and to set up the Keycloak instance. This method is run only once so that we don't have to
	 * read the JSON file and set up the Keycloak instance for each test.
	 *
	 * @throws IOException while converting the {@link InputStream Input Stream} to {@link String}
	 */
	@BeforeAll
	public static void setUp() throws IOException {
		try (final InputStream jsonStream = AbstractTest.class.getClassLoader().getResourceAsStream(REALM_CREATION_JSON)) {
			realmJson = IOUtils.toString(jsonStream);
		}

		try (final InputStream userRoleMappingJsonStream = AbstractTest.class.getClassLoader().getResourceAsStream(USERS_JSON)) {
			final String userRoleMappingJsonString = IOUtils.toString(userRoleMappingJsonStream);
			usersMap = MAPPER.readValue(userRoleMappingJsonString, new TypeReference<Map<String, UserRepresentation>>() {});
		}

		final String keycloakUrl = KeycloakTestContainerService.INSTANCE.ensureContainer(ADMIN_USERNAME, ADMIN_PASSWORD, REALM_CREATOR_CLIENT_SECRET);

		AUTH_SERVER_URL = keycloakUrl + "/";
		BASE_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s";
		CLIENTS_WITH_ID_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d";
		CLIENT_MEMBERS_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/members";
		PROJECT_WITH_ID_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/projects/%d";
		PROJECT_MEMBERS_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/clients/%d/projects/%d/members";
		MEMBER_URL_PATTERN = AUTH_SERVER_URL + "realms/%s/%s/users/%s";
	}
	
	/**
	 * Method to set up the test realm that can be used for testing the various endpoints. This method creates a test realm, the corresponding realm roles, the
	 * users, and also assigns appropriate roles to the users while also adding them to appropriate "user groups".
	 *
	 * @throws IOException while making the HTTP connection
	 */
	@BeforeEach
	public void setupRealm() throws IOException {
		/* Create Realm */
		createRealm();
		/* Create users */
		createUsersInRealm();
		/* We need to fetch the list of users that we created as we need the ID in order to assign roles to the users. */
		/* Unfortunately, we could not be assign the roles while creating the users. */
		assignRolesToUsers(getUsersFromRealm());
	}

	/**
	 * Method to delete the test realm after each test has been run.
	 *
	 * @throws IOException while making the HTTP connection
	 */
	@AfterEach
	public void deleteTestRealm() throws IOException {
		final String accessToken = getAccessTokenForRealmManagement();
		final HttpURLConnection deleteRealmCon = makeHttpCallAndGetConnection(
				AUTH_SERVER_URL + "admin/realms/" + testRealmName,
				HttpMethod.DELETE,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, deleteRealmCon.getResponseCode());
	}

	/**
	 * Generic method that can be used to make HTTP connections.
	 *
	 * @param urlString The URL to make the connection to
	 * @param method The HTTP Method type
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @param bodyJson Body parameters in a JSON format
	 * @return The HTTP Connection that can be used to validate if the connection was successful
	 * @throws IOException while making the HTTP connection
	 */
	protected static HttpURLConnection makeHttpCallAndGetConnection(
			final String urlString,
			final String method,
			final String accessToken,
			final String bodyJson) throws IOException {
		final URL url = new URL(urlString);
		final HttpURLConnection con = (HttpURLConnection) url.openConnection();
		con.setRequestMethod(method);
		con.setRequestProperty("Content-Type", "application/json");
		con.setRequestProperty("Accept", "*/*");
		con.setRequestProperty("Authorization", "bearer " + accessToken);
		con.setDoOutput(true);
		if (bodyJson != null && ! bodyJson.isEmpty()) {
			try (final OutputStream os = con.getOutputStream()) {
				final byte[] input = bodyJson.getBytes("utf-8");
				os.write(input, 0, input.length);
			}
		}
		return con;
	}

	/**
	 * Method to make an HTTP GET call without any body parameters.
	 *
	 * @param url The URL to make the connection to
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return The HTTP Connection that can be used to validate if the connection was successful
	 * @throws IOException while making the HTTP connection
	 */
	protected static HttpURLConnection getRequestWithoutBodyParams(final String url, final String accessToken) throws IOException {
		return makeHttpCallAndGetConnection(url, HttpMethod.GET, accessToken, null);
	}

	/**
	 * Method to return the access token that can be used for general management of the test realm.
	 * This access token is generated using the confidential client that was created in the master realm.
	 *
	 * @return Access token that can be used for realm management
	 * @throws IOException while making the HTTP connection
	 */
	protected static String getAccessTokenForRealmManagement() throws IOException {
		final URL url = new URL(AUTH_SERVER_URL + "realms/master/protocol/openid-connect/token");
		final HttpURLConnection accessTokenCon = (HttpURLConnection) url.openConnection();
		accessTokenCon.setRequestMethod(HttpMethod.POST);
		accessTokenCon.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
		accessTokenCon.setRequestProperty("Accept", "*/*");
		accessTokenCon.setDoOutput(true);
		final String jsonInputString = "grant_type=client_credentials&"
				+ "client_id=" + REALM_CREATOR_CLIENT
				+ "&username=" + ADMIN_USERNAME
				+ "&password=" + ADMIN_PASSWORD
				+ "&client_secret=" + REALM_CREATOR_CLIENT_SECRET;
		try (final OutputStream os = accessTokenCon.getOutputStream()) {
			final byte[] input = jsonInputString.getBytes("utf-8");
			os.write(input, 0, input.length);
		}
		final AccessInformation token = getResult(accessTokenCon, AccessInformation.class);
		return token.getAccessToken();
	}

	/**
	 * Method to generate the access token for the test realm.
	 * This access token is to be used to test the various endpoints.
	 *
	 * @param userName The username of the user for which access token is generated
	 * @param password Corresponding password
	 * @return The access token that has been generated
	 * @throws IOException while making the HTTP connection
	 */
	protected String getAccessTokenForTestRealm(final String userName, final String password) throws IOException {
		final URL url = new URL(AUTH_SERVER_URL + "realms/" + testRealmName + "/protocol/openid-connect/token");
		final HttpURLConnection con = (HttpURLConnection) url.openConnection();
		con.setRequestMethod(HttpMethod.POST);
		con.setRequestProperty("Content-Type", "application/x-www-form-urlencoded");
		con.setRequestProperty("Accept", "*/*");
		con.setDoOutput(true);
		final String jsonInputString = "grant_type=password&"
				+ "client_id=backend"
				+ "&username=" + userName
				+ "&password=" + password;
		try (final OutputStream os = con.getOutputStream()) {
			final byte[] input = jsonInputString.getBytes("utf-8");
			os.write(input, 0, input.length);
		}
		final AccessInformation token = getResult(con, AccessInformation.class);
		return token.getAccessToken();
	}

	/**
	 * Method to extract the result from a {@link URLConnection URL Connection}.
	 *
	 * @param <T> The type to cast the result to
	 * @param connection The {@link URLConnection URL Connection}
	 * @return The result extracted from the response in the {@link URLConnection URL Connection}
	 * @throws IOException while converting the {@link InputStream Response Input Stream} to {@link String}
	 */
	protected <T> T getResult(final URLConnection connection) throws IOException {
		return getResult(connection, new TypeReference<T>() {});
	}

	/**
	 * Method to extract the result from a {@link URLConnection URL Connection} and map it to the specified {@link TypeReference Type Reference}.
	 *
	 * @param <T> The type to cast the result to
	 * @param connection The {@link URLConnection URL Connection}
	 * @param reference The {@link TypeReference Type Reference} to map the result to
	 * @return The result extracted from the response in the {@link URLConnection URL Connection}
	 *         that has been mapped to the specified {@link TypeReference Type Reference}
	 * @throws IOException while converting the {@link InputStream Response Input Stream} to {@link String}
	 */
	protected static <T> T getResult(final URLConnection connection, final TypeReference<T> reference) throws IOException {
		try (final InputStream responseStream = connection.getInputStream()) {
			final String response = IOUtils.toString(responseStream);
			return MAPPER.readValue(response, reference);
		}
	}

	/**
	 * Method to extract the result from a {@link URLConnection URL Connection} and map it to the specified {@link Class}.
	 *
	 * @param <T> The type to cast the result to
	 * @param connection The {@link URLConnection URL Connection}
	 * @param classType The {@link Class} to map the result to
	 * @return The result extracted from the response in the {@link URLConnection URL Connection} that has been mapped to the specified {@link Class}
	 * @throws IOException while converting the {@link InputStream Response Input Stream} to {@link String}
	 */
	protected static <T> T getResult(final URLConnection connection, final Class<T> classType) throws IOException {
		try (final InputStream responseStream = connection.getInputStream()) {
			final String response = IOUtils.toString(responseStream);
			return MAPPER.readValue(response, classType);
		}
	}

	/**
	 * Method to fetch the specified User directly from the realm.
	 *
	 * @param userName The User to fetch
	 * @return The {@link UserRepresentation User} identified by the specified username
	 * @throws IOException while making the HTTP connection
	 */
	protected UserRepresentation getUserFromRealmByUserName(final String userName) throws IOException {
		final HttpURLConnection connection = getRequestWithoutBodyParams(AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/users?username=" + userName,
				getAccessTokenForRealmManagement());
		assertEquals(SC_OK, connection.getResponseCode());
		final List<UserRepresentation> users = getResult(connection, new TypeReference<List<UserRepresentation>>() {});
		assertNotNull(users);
		assertEquals(1, users.size());
		return users.get(0);
	}

	/**
	 * Method to get the count of groups in the test realm.
	 *
	 * @return The count of groups in the test realm
	 * @throws IOException while making the HTTP connection
	 */
	protected Integer getGroupCountInTestRealm() throws IOException {
		final String getGroupsCountUrl = AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/groups/count";
		final HttpURLConnection getGroupsConBeforeCreatingClient = getRequestWithoutBodyParams(getGroupsCountUrl, getAccessTokenForRealmManagement());
		assertEquals(SC_OK, getGroupsConBeforeCreatingClient.getResponseCode());
		final Map<String, Integer> groupCountMap = getResult(getGroupsConBeforeCreatingClient);
		assertTrue(groupCountMap.containsKey("count"));
		return groupCountMap.get("count");
	}

	/**
	 * Method to get the specified role directly from the test realm.
	 *
	 * @param roleName The role to fetch
	 * @return The {@link RoleRepresentation Role} identified by the specified role name
	 * @throws IOException while making the HTTP connection
	 */
	protected RoleRepresentation getRoleByNameFromTestRealm(final String roleName) throws IOException {
		final HttpURLConnection getAdminRoleForNewClientCon =
				getRequestWithoutBodyParams(AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/roles/" + roleName, getAccessTokenForRealmManagement());
		assertEquals(SC_OK, getAdminRoleForNewClientCon.getResponseCode());
		return getResult(getAdminRoleForNewClientCon, RoleRepresentation.class);
	}

	/**
	 * Method to fetch all roles in the test realm.
	 *
	 * @return A {@link List} of {@link RoleRepresentation Roles} that are present in the test realm
	 * @throws IOException while making the HTTP connection
	 */
	protected List<RoleRepresentation> getRolesInTestRealm() throws IOException {
		final String getRealmRolesUrl = AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/roles";
		final HttpURLConnection getRealmRolesBeforeCreatingProjectCon = getRequestWithoutBodyParams(getRealmRolesUrl, getAccessTokenForRealmManagement());
		assertEquals(SC_OK, getRealmRolesBeforeCreatingProjectCon.getResponseCode());
		return getResult(getRealmRolesBeforeCreatingProjectCon, new TypeReference<List<RoleRepresentation>>() {});
	}

	/**
	 * Method to fetch the default {@link ProjectNature Project Natures} for the given Project.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link List} of Project's default {@link ProjectNature Project Natures}
	 * @throws IOException while making the HTTP connection
	 */
	protected List<ProjectNature> getDefaultNaturesForProject(final Integer clientId, final Integer projectId, final String accessToken) throws IOException {
		final HttpURLConnection findProjectNaturesCon = getRequestWithoutBodyParams(
				String.format(PROJECT_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "/projectNatures", accessToken);
		assertEquals(SC_OK, findProjectNaturesCon.getResponseCode());
		return getResult(findProjectNaturesCon, new TypeReference<List<ProjectNature>>() {});
	}

	/**
	 * Method to get the specified {@link Member} that has access to the specified Project.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param memberId The ID of the Member
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return {@link Member} that belongs to the specified Project
	 * @throws IOException while making the HTTP connection
	 */
	protected Member getProjectMemberByMemberID(final Integer clientId, final Integer projectId, final String memberId, final String accessToken)
			throws IOException {
		final HttpURLConnection findMemberByIdCon = getRequestWithoutBodyParams(
				String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "/" + memberId, accessToken);
		assertEquals(SC_OK, findMemberByIdCon.getResponseCode());
		return getResult(findMemberByIdCon, Member.class);
	}

	/**
	 * Method to return all {@link Member Members} that have access to the specified Project.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of {@link Member Members} that have access to the Project
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getProjectMembers(final Integer clientId, final Integer projectId, final String accessToken) throws IOException {
		return getMembers(String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId), accessToken);
	}

	/**
	 * Method to return a {@link PaginatedResponse Page} of {@link Member Members} that have <i>Client Admin</i> access to the specified Client.
	 *
	 * @param clientId The ID of the Client
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of {@link Member Members} that have <i>Client Admin</i> access to the specified Client
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getClientAdmins(final Integer clientId, final String accessToken) throws IOException {
		return getMembers(String.format(CLIENTS_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId) + "/admins", accessToken);
	}

	/**
	 * Method to extract {@link ProjectRole Project Role} from a {@link Member} for the given Project.
	 *
	 * @param member The {@link Member} to get the {@link ProjectRole Project Role} from
	 * @param projectId The ID of the Project
	 * @return The {@link ProjectRole Project Role} in the {@link Member} for the given Project if it exists, or else {@code null}
	 */
	protected ProjectRole getProjectRoleFromMember(final Member member, final Integer projectId) {
		return member.getProjectRoles().stream().filter(role -> role.getProjectId().equals(Long.valueOf(projectId.longValue()))).findFirst().orElse(null);
	}

	/**
	 * Method fetch all {@link Member Members} for the given Client.
	 *
	 * @param clientId The ID of the Client
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of all {@link Member Members} for the given Client
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getMembersForClient(final Integer clientId, final String accessToken) throws IOException {
		return getMembers(String.format(CLIENT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId), accessToken);
	}

	/**
	 * Method to paginate over a given Client's {@link Member Members}.
	 *
	 * @param clientId The ID of the Client
	 * @param page The page number, zero-based
	 * @param size The size of the page
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of Client's {@link Member Members}
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getMembersForClientPaginated(
			final Integer clientId,
			final int page,
			final int size,
			final String accessToken) throws IOException {
		return getMembers(String.format(CLIENT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId) + "?page=" + page + "&size=" + size, accessToken);
	}

	/**
	 * Method to paginate over a given Project's {@link Member Members}.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param page The page number, zero-based
	 * @param size The size of the page
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of Project's {@link Member Members}
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getMembersForProjectPaginated(
			final Integer clientId,
			final Integer projectId,
			final int page,
			final int size,
			final String accessToken) throws IOException {
		return getMembers(
				String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "?page=" + page + "&size=" + size,
				accessToken);
	}

	/**
	 * Method to paginate over a given Client's {@link Member Members}
	 * that have the <i>Client Admin</i> access to the Client.
	 *
	 * @param clientId The ID of the Client
	 * @param page The page number, zero-based
	 * @param size The size of the page
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return A {@link PaginatedResponse Page} of Client's {@link Member Members} that
	 * 			have the <i>Client Admin</i> access 
	 * @throws IOException while making the HTTP connection
	 */
	protected PaginatedResponse<Member> getClientAdminsPaginated(
			final Integer clientId,
			final int page,
			final int size,
			final String accessToken) throws IOException {
		return getMembers(String.format(CLIENTS_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId) + "/admins?page=" + page + "&size=" + size, accessToken);
	}

	/**
	 * Method to delete the roles for the specified Client.
	 *
	 * @param clientId The ID of the Client
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void deleteClient(final Integer clientId, final String accessToken) throws IOException {
		final HttpURLConnection deleteClientCon = makeHttpCallAndGetConnection(
				String.format(CLIENTS_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId),
				HttpMethod.DELETE,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, deleteClientCon.getResponseCode());
	}

	/**
	 * Method to delete the roles for the specified Project.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void deleteProject(final Integer clientId, final Integer projectId, final String accessToken) throws IOException {
		final HttpURLConnection deleteProjectCon = makeHttpCallAndGetConnection(
				String.format(PROJECT_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId),
				HttpMethod.DELETE,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, deleteProjectCon.getResponseCode());
	}

	/**
	 * Method to change the default {@link ProjectNature Project Natures} for the given Project.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param projectNatures The {@link List} of {@link ProjectNature Project Natures} to update to
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void changeProjectNatures(
			final Integer clientId,
			final Integer projectId,
			final List<ProjectNature> projectNatures,
			final String accessToken) throws IOException {
		final String naturesStr = projectNatures.stream().map(ProjectNature::name).collect(Collectors.joining(","));
		final HttpURLConnection changeProjectNaturesCon = makeHttpCallAndGetConnection(
				String.format(PROJECT_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "?projectNatures=" + naturesStr,
				HttpMethod.PUT,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, changeProjectNaturesCon.getResponseCode());
	}

	/**
	 * Method to remove the <i>Client Admin</i> role for the given {@link Member} for the specified Client.
	 *
	 * @param clientId The ID of the Client
	 * @param memberId The ID of the {@link Member}
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void deleteClientAdminByMemberId(final Integer clientId, final String memberId, final String accessToken) throws IOException {
		final HttpURLConnection deleteClientAdminCon = makeHttpCallAndGetConnection(
				String.format(CLIENTS_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId) + "/admins/" + memberId,
				HttpMethod.DELETE,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, deleteClientAdminCon.getResponseCode());
	}

	/**
	 * Method to remove {@link ProjectRole Project Role} for the given {@link Member}.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param memberId The ID of the {@link Member}
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void deleteProjectMemberById(
			final Integer clientId,
			final Integer projectId,
			final String memberId,
			final String accessToken) throws IOException {
		final HttpURLConnection deleteProjectMemberCon = makeHttpCallAndGetConnection(
				String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "/" + memberId,
				HttpMethod.DELETE,
				accessToken,
				null);
		assertEquals(SC_NO_CONTENT, deleteProjectMemberCon.getResponseCode());
	}

	/**
	 * Method to add {@link ProjectRole Project Role} to the given {@link Member}.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param memberEmail The Email ID of the {@link Member}
	 * @param userRole The {@link UserRole User Role} to assign to the {@link Member}
	 * @param projectNatures The {@link List} of {@link ProjectNature Project Natures} to assign to the {@link Member}
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @return The {@link Member} with the updated {@link ProjectRole Project Role}
	 * @throws IOException while making the HTTP connection
	 */
	protected Member addProjectRoleToMember(
			final Integer clientId,
			final Integer projectId,
			final String memberEmail,
			final UserRole userRole,
			final List<ProjectNature> projectNatures,
			final String accessToken) throws IOException {
		/* We need to create the Member JSON instead of creating the Member object and converting it to JSON.
		 * We cannot use the constructor provided in the Member class as we do not have
		 * access to the RoleModel to provide the projectRole. */
		final String memberJson = createMemberJsonWithEmail(memberEmail, projectId, userRole, projectNatures);
		final HttpURLConnection addProjectRoleToMemberCon = makeHttpCallAndGetConnection(
				String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId),
				HttpMethod.POST,
				accessToken,
				memberJson);
		assertEquals(SC_OK, addProjectRoleToMemberCon.getResponseCode());
		return getResult(addProjectRoleToMemberCon, Member.class);
	}

	/**
	 * Method to add the given {@link Member} as a <i>Client Admin</i> for the specified Client.
	 *
	 * @param clientId The ID of the Client
	 * @param memberEmail The Email ID of the {@link Member}
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void addMemberAsClientAdmin(final Integer clientId, final String memberEmail, final String accessToken) throws IOException {
		/* We need to create the Member JSON instead of creating the Member object and converting it to JSON.
		 * We cannot use the constructor provided in the Member class as we do not have
		 * access to the RoleModel to provide the projectRole. */
		final String memberJson = "{ \"email\": \"" + memberEmail + "\" }";
		final HttpURLConnection addAdminClientCon = makeHttpCallAndGetConnection(
				String.format(CLIENTS_WITH_ID_URL_PATTERN, testRealmName, SPI_ID, clientId) + "/admins",
				HttpMethod.POST,
				accessToken,
				memberJson);
		assertEquals(SC_OK, addAdminClientCon.getResponseCode());
	}

	/**
	 * Method to assign the given {@link UserRole User Role} to the given {@link Member}.
	 *
	 * @param clientId The ID of the Client
	 * @param projectId The ID of the Project
	 * @param memberId The ID of the {@link Member}
	 * @param userRole The {@link UserRole User Role} to assign
	 * @param accessToken The access token to authenticate and authorize the connection
	 * @throws IOException while making the HTTP connection
	 */
	protected void assignUserRoleToMember(
			final Integer clientId,
			final Integer projectId,
			final String memberId,
			final UserRole userRole,
			final String accessToken) throws IOException {
		final String memberToUpdateJson = createMemberJsonWithID(memberId, projectId, userRole, Collections.emptyList());
		final String projectMemberURL = String.format(PROJECT_MEMBERS_URL_PATTERN, testRealmName, SPI_ID, clientId, projectId) + "/" + memberId;
		final HttpURLConnection assingEditorRoleToMemberCon = makeHttpCallAndGetConnection(
			projectMemberURL,
			HttpMethod.PUT,
			accessToken,
			memberToUpdateJson);
		assertEquals(SC_OK, assingEditorRoleToMemberCon.getResponseCode());
	}

	/**
	 * Method to validate that the given user does not exist in the test realm.
	 *
	 * @param userEmail The Email ID of the user to validate
	 * @throws IOException while making the HTTP connection
	 */
	protected void assertUserDoesNotExist(final String userEmail) throws IOException {
		final HttpURLConnection con = getRequestWithoutBodyParams(
				AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/users?username=" + userEmail,
				getAccessTokenForRealmManagement());
		assertEquals(SC_OK, con.getResponseCode());
		final List<UserRepresentation> members = getResult(con);
		assertTrue(members.isEmpty());
	}

	/**
	 * Method to create the JSON for the {@link Member} object, identified by the Email ID.
	 * This can now be used in HTTP connections to pass information through the request.
	 *
	 * @param email The Email ID of the {@link Member}
	 * @param projectId The ID of the Project in order to specify the {@link ProjectRole Project Role} for the {@link Member}
	 * @param userRole The {@link UserRole User Role} assigned to the {@link Member} for given Project ID
	 * @param projectNatures The {@link List} of {@link ProjectNature Project Natures} assigned to the {@link Member} for given Project ID
	 * @return The {@link Member} object as a JSON
	 */
	protected String createMemberJsonWithEmail(
			final String email,
			final Integer projectId,
			final UserRole userRole,
			final List<ProjectNature> projectNatures) {
		final StringBuilder builder = new StringBuilder("{");
		builder.append("\"email\": \"");
		if (StringUtils.isEmpty(email)) {
			builder.append("");
		} else {
			builder.append(email);
		}
		builder.append("\",");
		builder.append(getProjectRoleJson(projectId, userRole, projectNatures));
		builder.append("}");
		return builder.toString();
	}

	/**
	 * Method to create the JSON for the {@link Member} object, identified by the Member ID.
	 * This can now be used in HTTP connections to pass information through the request.
	 *
	 * @param id The ID of the {@link Member}
	 * @param projectId The ID of the Project in order to specify the {@link ProjectRole Project Role} for the {@link Member}
	 * @param userRole The {@link UserRole User Role} assigned to the {@link Member} for given Project ID
	 * @param projectNatures The {@link List} of {@link ProjectNature Project Natures} assigned to the {@link Member} for given Project ID
	 * @return The {@link Member} object as a JSON
	 */
	protected String createMemberJsonWithID(
			final String id,
			final Integer projectId,
			final UserRole userRole,
			final List<ProjectNature> projectNatures) {
		final StringBuilder builder = new StringBuilder("{");
		builder.append("\"id\": \"");
		if (StringUtils.isEmpty(id)) {
			builder.append("");
		} else {
			builder.append(id);
		}
		builder.append("\",");
		builder.append(getProjectRoleJson(projectId, userRole, projectNatures));
		builder.append("}");
		return builder.toString();
	}

	private String getProjectRoleJson(final Integer projectId, final UserRole userRole, final List<ProjectNature> projectNatures) {
		final StringBuilder builder = new StringBuilder("\"projectRoles\": [{");
		if (projectId != null) {
			builder.append("\"projectId\": ").append(projectId);
		}
		if (userRole != null) {
			builder.append(",\"userRole\": \"").append(userRole.name()).append("\"");
		}
		if ( ! CollectionUtils.isEmpty(projectNatures)) {
			final String projectNaturesStr = projectNatures.stream()
			                                               .map(nature -> "\"" + nature.name() + "\"")
			                                               .collect(Collectors.joining(","));
			builder.append(",\"projectNatures\":[").append(projectNaturesStr).append("]");
		}
		builder.append("}]");
		return builder.toString();
	}

	private PaginatedResponse<Member> getMembers(final String url, final String accessToken) throws IOException {
		final HttpURLConnection con = getRequestWithoutBodyParams(url, accessToken);
		assertEquals(SC_OK, con.getResponseCode());
		return getResult(con, new TypeReference<PaginatedResponse<Member>>() {});
	}

	private void assignRolesToUsers(final List<UserRepresentation> users) throws IOException {
		/* Get all Realm Roles that are present in the Realm. */
		final List<RoleRepresentation> realmRoles = getRolesInTestRealm();
		final Map<String, RoleRepresentation> rolesMap = realmRoles.stream().collect(Collectors.toMap(role -> role.getName(), role -> role));
		final String accessToken = getAccessTokenForRealmManagement();
		for (final UserRepresentation user : users) {
			final UserRepresentation userFromJSONFile = usersMap.get(user.getUsername());
			for (final String role : userFromJSONFile.getRealmRoles()) {
				assignRoleForUser(user, rolesMap.get(role), accessToken);
			}
		}
	}

	private void createUser(
			final UserRepresentation user,
			final String accessToken) throws IOException {
		final UserRepresentation userToCreate = new UserRepresentation();
		userToCreate.setUsername(user.getEmail());
		userToCreate.setEmail(user.getEmail());
		userToCreate.setFirstName(user.getFirstName());
		userToCreate.setLastName(user.getLastName());
		userToCreate.setEnabled(Boolean.TRUE);
		final List<String> groups = user.getGroups();
		if ( ! CollectionUtils.isEmpty(groups)) {
			userToCreate.setGroups(groups);
		}
		final CredentialRepresentation credential = new CredentialRepresentation();
		credential.setType("password");
		credential.setTemporary(Boolean.FALSE);
		credential.setValue(PASSWORD);
		userToCreate.setCredentials(Arrays.asList(credential));
		final String userJson = MAPPER.writeValueAsString(userToCreate);
		final HttpURLConnection createAdminCon = makeHttpCallAndGetConnection(
				AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/users",
				HttpMethod.POST,
				accessToken,
				userJson);
		assertEquals(SC_CREATED, createAdminCon.getResponseCode());
	}

	private void assignRoleForUser(final UserRepresentation user, final RoleRepresentation role, final String accessToken) throws IOException {
		assertNotNull(user);
		assertNotNull(role);
		final String roleJSON = MAPPER.writeValueAsString(Arrays.asList(role));
		final HttpURLConnection updateAdminUserCon = makeHttpCallAndGetConnection(
				AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/users/" + user.getId() + "/role-mappings/realm",
				HttpMethod.POST,
				accessToken,
				roleJSON);
		assertEquals(SC_NO_CONTENT, updateAdminUserCon.getResponseCode());
	}

	private void createRealm() throws IOException {
		testRealmName = UUID.randomUUID().toString();
		final RealmRepresentation realm = MAPPER.readValue(realmJson, RealmRepresentation.class);
		realm.setRealm(testRealmName);
		realm.setId(testRealmName);
		final String realmJsonToCreate = MAPPER.writeValueAsString(realm);
		final HttpURLConnection createRealmCon = makeHttpCallAndGetConnection(
				AUTH_SERVER_URL + "admin/realms/",
				HttpMethod.POST,
				getAccessTokenForRealmManagement(),
				realmJsonToCreate);
		assertEquals(SC_CREATED, createRealmCon.getResponseCode());
	}

	private void createUsersInRealm() throws IOException {
		for (final Entry<String, UserRepresentation> entry : usersMap.entrySet()) {
			final UserRepresentation user = entry.getValue();
			createUser(user, getAccessTokenForRealmManagement());
		}
	}

	private List<UserRepresentation> getUsersFromRealm() throws IOException {
		final HttpURLConnection getUsersFromRealmCon = getRequestWithoutBodyParams(
				AUTH_SERVER_URL + "admin/realms/" + testRealmName + "/users",
				getAccessTokenForRealmManagement());
		assertEquals(SC_OK, getUsersFromRealmCon.getResponseCode());
		return getResult(getUsersFromRealmCon, new TypeReference<List<UserRepresentation>>() {});
	}
}